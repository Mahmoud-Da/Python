*** 1- Pypi ***

- In the last section we explored python standard library. Now even though this library is very
comprehensive, it doesn't have everything that we potentially need when building a real application.

- There are times that we need features not implemented in python standard library.
That's where pypi or python package index comes into picture. Pypi is like npm or node package
manager for javascript developers. It's basically a repository of python packages built by people
like us.

- So if we head over to pypi.org, on this page we can see that currently we have
almost 600,000 projects registered in this repository.
-------------------code----------------------
https://pypi.org/
-------------------code----------------------

- For pretty much anything we imagine,
there is a python package here. Let's say we want to work with pdf files in our application.

- simply search for pdf. As we can see currently we have over 2,000 projects for working with pdf
files. Here are a few examples. This first package is a two-dimensional barcode generator.
We also have this package for managing and processing pdf files. 

- The next one is for converting a pdf file to text. We can also convert a pdf to image and so on. So we have tons and tons of packages for
working with pdf files. Of course not all of these are useful, some of them are buggy or incomplete,
but if we do a little bit of research, we can find a good and stable package for our projects.


- Alternatively, we can also google the best python packages for working with pdf files and see what
other people in the community say. So in this section we're going to learn about all the tooling we need
to install these packages and publish our own packages to this repository.

*** 2- Pip ***

- To install a package from pypi, we use a tool called pip.
Now if we're on mac, similar to python, we should use pip3.
-------------------code----------------------
$ pip3
-------------------code----------------------

- Now with this tool we can do various things, such as installing packages,
uninstalling them, upgrading them, or listing the currently installed
packages.

- Let's take a look at a few examples. So here to
install a package, as the first argument we pass, install,
and as the second argument, we specify the name of the target package.
So here we're going to install this requests package, which
we're going to use to send http requests.

-------------------code----------------------
$ pip3 install requests
-------------------code----------------------

- So, let's go ahead.
Alright, this is successfully installed,
but here down the bottom we have a warning in yellow that is saying we're
using pip version 24.3.1. However, version 25.0.1 is
available. So this version 24.3.1 is the version that came with my python
installation, but because pip is developed independently, we need to
upgrade it from time to time.
-------------------code----------------------
[notice] A new release of pip is available: 24.3.1 -> 25.0.1
-------------------code----------------------

- So, right below that we can see the command that
we need to run to upgrade pip.
-------------------code----------------------
pip3 install --upgrade pip
-------------------code----------------------

- Alright, now we have the latest version of pip.
Let's look at the packages that are
currently installed on my machine. So pip list.
-------------------code----------------------
$ pip3 list

Package            Version
------------------ ---------
certifi            2025.1.31
charset-normalizer 3.4.1
idna               3.10
pip                25.0.1
requests           2.32.3
urllib3            2.3.0
-------------------code----------------------

- Here in this list we can see we have installed
the version 2.32.3 of the requests package.
This version we see here is what we call semantic versioning.

- The first number represents the major version, the second
number represents the minor version, and the third number represents the patches
or bug fixes.


- Now back on pipi.org
let's search for the requests package. So here we have a few
packages with a similar name. We've got requests, request 3, and request 2.
And they're not always in the same order, so make sure to pick the
requests package without 2 or 3.

- Now on this page, on the left side we can see the
release history of this package. So the latest version that we've installed
is 2.32.3. There are times that we want to install an earlier
version, perhaps the latest version has a bug, or is incompatible
with the other packages we're referencing.
 
- how to install an earlier version. So back on the terminal, let's
say we want to install version 2.32.0. That is very easy. 
Just like before pip install requests, now we add two equal signs, followed by the version 2.32.0.
So as we can see, this successfully uninstalled
the latest version that was version 2.32.3, and then installed
version 2.32.0.
-------------------code----------------------
$ pip3 install requests==2.32.0
-------------------code----------------------

- Now here we can also use wildcards, for example,
pip install requests equal 2.32 asterisk. That means
install the latest compatible version with version 2.32.
So if there are any patches or bug fixes, include those as well.
-------------------code----------------------
$ pip3 install requests==2.32.*
-------------------code----------------------

- Now here on pypi.org, we can see we have three 2.32
versions, this is the base version, and then we got a couple more versions
before version 2.33. So when we run this command, pip will install
the latest compatible version with 2.32.0, which is 2.32.2.
Let's take a look. Now we got this message requirement, already
satisfied, because we already have version 2.32.0
installed. 

- So first we need to uninstall it before we install
the latest compatible version with this. So, that is very easy.
Pip, this time we're going to use uninstall and then request.
We don't care about the version. this is asking for confirmation so let's go ahead.
Now requests version 2.32.0 is uninstalled.
-------------------code----------------------
$ pip3 uninstall requests
-------------------code----------------------

- So now let's install
requests version 2.32 point asterisk. This will install
the latest compatible version with 2.32.
-------------------code----------------------
$ pip3 install requests==2.32.*
-------------------code----------------------

- We also have another syntax for installing the latest compatible version.
So instead of two we use a tilde
equal sign, and then here we specify a specific version.
Let's say 2.32.0 Once again, this will install the latest compatible version
with 2.32.0 which is 2.32.2.
-------------------code----------------------
$ pip3 install requests~=2.32.0
-------------------code----------------------

- Now we can use this asterisk with a minor version as well.
For example, let me uninstall this first so pip uninstall requests
ok, let's go ahead good now, pip instal requests 2.0 asterisk
This will install the latest compatible version with version 2.
-------------------code----------------------
$ pip3 install requests==2.*
-------------------code----------------------

- So back to the release history if we scroll to the very top
we can see the latest compatible version with version 2
is 2.32.3 Let's go ahead and run this
there we go so we successfully installed requests 2.32.3

- Now we can use this package just like the modules
in python standard library so we import request.
-------------------code----------------------
import requests
-------------------code----------------------

- now we have a module object with these members
we can read about these on the documentation for this package
so back on pipeui.org here on the page for the requests package
if we scroll down we can see a link to the documentation

- Now, back to our code we're going to call the get method
let's send an http request to google.com this returns
a response object for now let's simply print
the response on the terminal.

let's run the program so we got a response with the status
200 which indicates success
-------------------code----------------------
response = requests.get("http://google.com")
print(response)
# <Response [200]>
-------------------code----------------------

*** 3- Virtual Environments ***

- In the last lecture we learned how to install a package using pip. Now
let's run pip list, we can see
currently we have installed requests version 2.32.3.

-------------------code----------------------
$ pip3 list

Package            Version
------------------ ---------
certifi            2025.1.31
charset-normalizer 3.4.1
idna               3.10
pip                25.0.1
requests           2.32.3
urllib3            2.3.0
-------------------code----------------------

- there is a problem here. Let's say we have another
project and in that project we want to use an earlier version of this package.
With the current structure we cannot have two versions of any
of these packages side by side. We can have only a single version.
To solve this problem we need to create an isolated virtual
environment for each application and install these dependencies into
that virtual isolated environment.

- how to do that. So, here in the project folder we run python
dash m venv and then specify the name of a directory for containing this virtual environment. By convention
we call that env. 
-------------------code----------------------
$ python3 -m venv env
-------------------code----------------------

- PS: Now don't worry about memorizing any of these
because later we're going to show we a better
and simpler way. So technically we're never going to execute
this command after we show we the latest tools. we're just going to
take we on a step by step journey so we understand
exactly how these various tools come together.

So, let's go ahead and run this command.
Good. Now here on the file explorer panel we can see we have a new directory and
in this directory we have this config file with these parameters.
-------------------code----------------------
home = /Library/Frameworks/Python.framework/Versions/3.13/bin
include-system-site-packages = false
version = 3.13.1
executable = /Library/Frameworks/Python.framework/Versions/3.13/bin/python3.13
command = /Library/Frameworks/Python.framework/Versions/3.13/bin/python3 -m venv /Users/mahmouddabbbagh/moody/Python/Complete-Python-Mastery/10-Python-Package-Index/env
-------------------code----------------------

- Home is referencing the directory
where my python interpreter is installed. And here's the version of that interpreter.
So we're using c python version 3.13.1 We also have this bin or binary directory
where we have a bunch of tools like pip, pip3, python, python3 and so on.
Next to that we have include which is currently empty.
We have lib, inside of this directory we have python 3.13.1 and inside of that we have site packages.

Note: Now this directory structure is slightly different on windows
so if we're a windows user don't get hung up on these subtle differences.
Focus on the big picture. What matters here is that this site packages directory
is where we'll install the packages for this application.

- So a virtual directory is an isolated environment
where we have a specific python interpreter in this case c python version 3.13.1
as well as a bunch of packages that this application needs.

- Okay, now that we have a virtual environment
we need to activate it. Here in the bin folder
we have a script called activate.
We need to run this from the terminal.
So, back in the terminal, if we're on windows
we execute this script directly.
-------------------code----------------------
$ env\bin\activate.bat
-------------------code----------------------

-  If we're on mac or linux,
we will have to type source slash bin slash activate.
-------------------code----------------------
$ source env/bin/activate
(env) 10-Python-Package-Index +[feature/12_3]
-------------------code----------------------

There we go. Now we can see the name of the currently active
virtual environment. In this case, that is env.
We could call this anything, but by convention we use env.
So now that we are in the virtual environment
for this application, let's go ahead and install an earlier version of requests package.
-------------------code----------------------
$ pip3 install requests==2.32.1
-------------------code----------------------


- So as we can see we have installed
requests
version 2.32.1 which is different from the request package
that we installed globally on this machine. This is specific to this application.
Now back to our directory structure.
Now under the site packages directory we have this new directory
requests. This is where we have installed
the request package for this application.

- Finally, whenever we are done we need to deactivate
this virtual environment.
So, we run deactivate.
-------------------code----------------------
deactivate
-------------------code----------------------

*** 4- Pipenv ***

- So we have learned about pip and creating virtual environments. As we have noticed,
using these tools requires memorizing various commands and arguments. There's a lot to remember.
That's where pipenv comes in the picture. Pipenv is a tool that combines pip and virtual environments
into a single toolchain. So we don't have to use pip or virtual environments separately.
If we're familiar with npm or node package manager, pipenv is the equivalent tool in the
python world. So it's a dependency manager for python projects. Now we might be curious why
we didn't start this section with pipenv. Because as we told we, pipenv internally uses pip and virtual
environments, so we need to understand how exactly it works under the hood. Also, as we look at
various websites, we will come across pip or virtual environments, so we wanted to make sure
that these tools are not foreign to us.

- how to use pipenv.
Here on the terminal, first we need to install it.
-------------------code----------------------
$ pip3 install pipenv
-------------------code---------------------- 

- Alright, now, back to VS code, we're going to delete this env directory because we don't need it anymore.
We're going to use pipenv to automatically create a virtual directory. So delete, good.
Now back to the terminal, instead of using pip to install a package, we use pipenv.
-------------------code---------------------- 
$ pipenv install requests
-------------------code----------------------

- This tool created a couple of files, pip file, and pip file.lock,
we'll look at this later. It also created a virtual environment for us, and installed this request
package inside of that virtual environment.

- But that virtual environment is not here. Where is it? Let me show we. So here on the terminal, let's run pipenv, dash dash, venv.
This is the path to our virtual environment directory. As we can tell, this directory is not part of our
project, and this is a deliberate decision. Because as we install various packages, we'll end up with
hundreds or even thousands of files in this virtual environment. And this will increase the size of our
project. So we want to exclude this virtual environment from our project directory.
-------------------code---------------------- 
$ pipenv --venv
# /Users/mahmouddabbbagh/.local/share/virtualenvs/10-Python-Package-Index-Aaz2bPmn
-------------------code----------------------

- Now, we're going to uninstall the request package that we installed globally using pip.
So, pip, uninstall, requests.
-------------------code---------------------- 
$ pip3 uninstall requests
-------------------code---------------------- 

- So we installed a dependency using pipenv, now let's run our application. But for this demo,
we're not going to use code runner, we will see why in a second. So let's run python
app3.py. We got a module not found error. No module named requests. Because we removed the requests package
from the list of global packages. And here, python doesn't know where to locate this package.
It has no knowledge of this new virtual environment.
-------------------code---------------------- 
import requests
ModuleNotFoundError: No module named 'requests'
-------------------code---------------------- 

- So we need to activate it. Once again,
we use the same tool, that is pipenv, and as the first argument, we pass shell.
-------------------code---------------------- 
pipenv shell
-------------------code---------------------- 

- So, as we can see, it's activated the virtual environment for this project. Now let's run our
program one more time. We got a response, beautiful. So python could successfully locate
the requests package.
-------------------code---------------------- 
(10-Python-Package-Index) 10-Python-Package-Index +[main] $ python3 app3.py
<Response [200]>
-------------------code---------------------- 

-  So here, we're currently in the virtual environment for this project.
If we want to deactivate it, simply type exit. Now we're outside of the virtual environment.
-------------------code---------------------- 
exit
-------------------code---------------------- 

*** 5- Virtual Environments in VSCode ***

Note: this lecture no need to do it only to understand
if we want to fix the code-runner issue.

- So in the last lecture, we didn't run this program using the code-runner. we used the terminal.
Now let's see what happens when we run this program using the code-runner extension. So there we go.
We get the same error. No module named requests. 
-------------------code---------------------- 
import requests
ModuleNotFoundError: No module named 'requests'
-------------------code---------------------- 

- Because code-runner is running this program using the python interpreter that is installed globally, and that python interpreter
cannot find the requests module. To fix this problem, we need to tell code-runner
to use the python interpreter in our virtual environment. So, back in the terminal,
let's find the virtual environment directory for this project, pipenv
dash dash venv.

-------------------code---------------------- 
$ pipenv --venv
# /Users/mahmouddabbbagh/.local/share/virtualenvs/10-Python-Package-Index-Aaz2bPmn
-------------------code----------------------

- There we go. Now, let's open this.
So this is our directory structure that we have seen before. Here in this virtual environment,
inside of the bin folder, we've got python 3. If we're on windows, we have python.
So we need to get the pass to this python interpreter, and give it to the code-runner extension.
Back in vscode, on the top, let's go to the code menu, then preferences, and settings.
Here click this dot dot dot, and open settings.json Now if we scroll down, we should see code-runner dot executor map.
We said this earlier in the course. In case we missed that step, simply add
a new key value pair here, the key is code dash runner dot executor map.
When we press enter, it automatically generates all these settings.

- Now here we have the path to python, as we can see, we've changed this to python 3.
Now we need to replace this with the path to the python interpreter in our virtual environment.

- So this is the path to our virtual environment. Let's copy the venv path, then back to user settings.
And replace python3 with to the pass to our venv.

- So we're referencing the python interpreter in or virtual environment.
Let's save the changes, back to app3.py, let's run this program using the code-runner extension.
There we go. So we fixed the issue with code-runner, but we have a red underline here,
unable to import requests. So vscode cannot find our requests module.

- To fix this problem, we need to tell vscode which python interpreter to use.
Now if we look at the status bar here, we can see python 3.13 Click this, in this list we should see various python interpreters.
Now look at the last one with the venv name.

- This is the path to the python interpreter in our virtual environment.
If we don't see this on our machine, we need to go back to the user settings page.
And add a new setting. That is "python.pythonPath".
We set this to the pass to the python interpreter in our virtual environment.

- Now after we add this, we need to restart vscode.
Then when we go back to app.py, here in the list of virtual environments,
we should see this new python interpreter.
we can see the compilation error is gone. But we got this other error, linter pilot is not installed.
Because earlier we installed this globally, and now it's not available in this isolated virtual environment.
So we need to go ahead and install it.
Alright, the error is gone.

*** 6- Pipfile ***

- Let me install a package using pipenv, two files get automatically created.
pipfile and pipfile.lock. These two files are
used to keep track of the dependencies of our project and their version.

- So first we're going to open up pipfile. Here we
have four sections. The first one is "source", that specifies the
address of the repository where these packages are downloaded from.
Below that we have "dev" or development packages.
These are the packages that we use as part of our development, such as packages
that we use for automated testing. They're only used during development.
So they don't have to exist for our application to run. Below
that, we've got the packages that our application is dependent on.
In this case we're dependent on the "request" package, and this
asterisk we see , because we didn't specify a version when installing this
package. This asterisk means the latest version. If we
specify the version.
-------------------code----------------------
[packages]
requests = "*"
-------------------code----------------------

- And finally, below that we've got
requires, that specifies the version of Python we need to run this application.
So this is our pip file. Now let's look at pipfile.lock. This is a JSON file that lists the
dependencies of our application and their exact version.
we've got this section called meta, don't worry about that. Below
that we have default, and inside of the default we've got all the dependencies of our
application and their exact version. "certify" Now we didn't explicitly install
this package, this is one of the dependencies of the requests package.

- So all the packages that we installed and their dependencies and their
dependencies are listed in this file. So the version that is installed on my machine
is this version.

- Now if we scroll down, we can find the requests package, and here's the
version that is installed on our machine.
-------------------code----------------------
"requests": {
            "hashes": [
                "sha256:55365417734eb18255590a9ff9eb97e9e1da868d4ccd6402399eaf68af20a760",
                "sha256:70761cfe03c773ceb22aa2f671b4757976145175cdfca038c02654d061d6dcc6"
            ],
            "index": "pypi",
            "markers": "python_version >= '3.8'",
            "version": "==2.32.3"
}
-------------------code----------------------

- Now with all the information stored in
this file, we can take our source code put it on another machine, like
a production environment, and reproduce
this exact execution environment. And this minimizes or
eliminates the situation where our application runs on our machine, but
doesn't run on another machine, because
there's a different version of one of these dependencies on that machine.

- Now to see this workflow in action.
So here on the terminal, let's find the virtual environment
for this project.
-------------------code---------------------- 
$ pipenv --venv
# /Users/mahmouddabbbagh/.local/share/virtualenvs/10-Python-Package-Index-Aaz2bPmn
-------------------code----------------------


- Next we're going to delete this directory
to simulate the scenario where we copy our project onto another machine.
On that machine, this virtual environment does not exist. All we have
is the source code of our application.
-------------------code----------------------
$ rm -rf /Users/mahmouddabbbagh/.local/share/virtualenvs/10-Python-Package-Index-Aaz2bPmn
-------------------code----------------------

- So now if we run pipenv, dash dash venv
one more time, it tells us that no virtual environment has been created
for this project yet.
-------------------code---------------------- 
$ pipenv --venv
No virtualenv has been created for this project yet!
Aborted!
-------------------code---------------------- 

- All we have is this source code
and our pip files that specify the dependencies of our application.
So now we need to install all these dependencies.
And that is very easy. We run pipenv install without any additional arguments.
When we run this command, pipenv will look at our pip file
and install all the dependencies of our application.
-------------------code---------------------- 
$ pipenv install
-------------------code---------------------- 

- Now, let's run pipenv, dash dash venv. We can see we have this virtual
environment, and in this virtual environment
we've got all the dependencies of this project.
-------------------code---------------------- 
$ pipenv --venv
# /Users/mahmouddabbbagh/.local/share/virtualenvs/10-Python-Package-Index-Ssz2bPmn
-------------------code----------------------

- Now these dependencies are installed
based on the version specified here.
So, for the request package, we're asking for the very latest version.
However, on my machine at the time of development,
we've been using version 2.32.3. So chances are in the future
when we put this project on a different machine and install the dependencies,
we might have a newer version of the request package.

- In that case, those dependencies installed on that machine
will be different from the dependencies on my development machine.
If we want to install the exact same versions listed here, we should tell pipenv to ignore the pip file
and use pip file.lock. So back on the terminal,
we run pipenv install, and then supply an additional parameter,
dash dash, ignore, dash, pip file.

-------------------code----------------------
$ pipenv install --ignore-pipfile
-------------------code----------------------

- As we can see, this time pipenv installed the dependencies
from pip file.lock.

*** 7- Managing Dependencies ***

- So we have learned the basics of pipenv, now let's take a look at a few useful
commands for managing the dependencies of our application. 

- We can run pipenv graph to see the list of all the installed
dependencies. So currently we have installed requests
version 2.20.1, and below that we can see the dependencies
of the requests package itself.
-------------------code----------------------
$ pipenv graph
requests==2.32.3
├── certifi
├── charset-normalizer
├── idna
└── urllib3
-------------------code----------------------

- Now let's uninstall the requests package. So pipenv
uninstall requests. So the request
package is gone, if we look at the pip file, it's not here anymore.
-------------------code----------------------
$ pipenv uninstall requests
Uninstalling requests...
Found existing installation: requests 2.32.3
Uninstalling requests-2.32.3:
  Successfully uninstalled requests-2.32.3
-------------------code----------------------

- Also if we run pipenv graph,
it's gone. However, the dependencies
of the request package are still here
because pipenv doesn't know if these
dependencies are used somewhere in our application
or not. However, if we take this project, put it on a different
machine, and install all these dependencies from scratch, these packages will not
end up there, because currently we have not referenced them in our pip file.
-------------------code----------------------
$ pipenv graph
certifi==2025.1.31
charset-normalizer==3.4.1
idna==3.10
urllib3==2.3.0
-------------------code----------------------

- Now let's install an earlier version of the requests
package. So pipenv install requests version 2.32 point asterisk
Alright, now in our pip file we can see we have the request package
with the version that we have requested and if we look at pipfile.log
we can see the actual version
that is installed. That is 2.32.3.
-------------------code----------------------
pipenv install requests==2.32
-------------------code----------------------
PS: instead of using * we can skip all the number 
ex: 2.32.* => 2.32

- Now to find the outdated packages we can run pipenv update dash dash
we get this yellow warning, skip update of package requests
so this is the version that we have installed as we can see there is a newer
version available, but pipenv won't be able to install that, because
in our pip file we ask for the most recent version compatible with 2.32.
-------------------code----------------------
$ pipenv update --outdated
Package 'requests' out-of-date: <Version('2.32.0')> installed, <Version('2.32.3')> available.
All packages are up to date!
-------------------code----------------------

- Now we have two choices, we can update this package
for all packages in our project
to update all packages we run pipenv update
and to update a specific package we add its name here so requests
-------------------code----------------------
$ pipenv update requests
-------------------code----------------------

- now all our dependencies are up to date, so
if we look at pip file dot log we can see that we have
requests version 2.32.3 and similarly if we run pipenv
graph we can see that we have installed the latest version of the request package

-------------------code----------------------
pipenv graph
requests==2.32.3
├── certifi
├── charset-normalizer
├── idna
└── urllib3
-------------------code----------------------

*** 8- Publishing Packages ***

- In this lecture we're going to show we how to publish our own packages to
pypi.org. The first step is to create a new account.

- Next here on the terminal, we need to install
three tools globally. So pip, or pip3, install, setup tools, wheel,
and twine. You will see these in action momentarily.
-------------------code----------------------
$ pip3 install setuptools wheel twine
-------------------code----------------------

- So let's go ahead. Alright, now we're going to start with a brand new project, let's say
we're going to create a package to work with pdf files. So we're going to create
a new directory, call it moody pdf.
-------------------code----------------------
$ mkdir moody_pdf
-------------------code----------------------

- Now let's go to this directory, and open vscode.
Now as a best practice, we should create a high level directory with the same name as our package.
-------------------code----------------------
$ moody_pdf
-------------------code----------------------

- So, we're going to call that
moody pdf, here potentially we could have another directory for unit tests,
we're going to look at unit tests in the future. Perhaps we could have
another top level directory for some sample data and so on.
All our source code will end up here.
-------------------code----------------------
tests/
data/
-------------------code----------------------

- Now in this directory, we should add
an init file, so python will see this as a package.
Now let's add a couple of modules, so we're going to add a new file, call that pdf to text and pdf to image.
-------------------code----------------------
pdf2text.py
__init__.py
pdf2image.py
-------------------code----------------------

and inside of each file we're going to write a basic function
like convert, so convert, that simply prints pdf to text.
-------------------code----------------------
def convert():
    print("pdf2text")
-------------------code----------------------

-------------------code----------------------
def convert():
    print("pdf2image")
-------------------code----------------------


- So this is a basic structure for a package.
-------------------code----------------------
data			moody_pdf		tests
-------------------code----------------------

- Now, in order to publish this to pypi, we need to add
three files here. The most important one is setup.py.
So, at the root of this project, we add a new file, setup.py.
Here on the top we should import setup tools that we installed earlier.
-------------------code----------------------
import setuptools
-------------------code----------------------

- This module has a method called setup. We call this method
and pass a few keyword arguments. Here are the essential ones.
The first one is name. We should set this to a unique name for our package
so it doesn't conflict with another package in pypi repository.
In this demo, we're going to set this to moody pdf.

- Next one is version.
we're going to set this to version 1.0. We need a long description.
For now, we're going to set this to an empty string. We're going to come back to this in a second.
And finally, we need to tell what packages
are going to be distributed. Because in this project currently
we have one package that is moody pdf, and in this package
we have these two modules. So we need to tell setup tools
about the modules and packages that we're going to publish.
-------------------code----------------------
setup.py
-------------------code----------------------

- So, here we add packages and we set it to
setuptools.packages.

This method will look at our project
and automatically discover the packages
that we have defined. However, we need to tell it to exclude two
directories, tests and data because they don't include source code. So, we pass an array here
with a couple of strings tests and data. So this is our setup file.

-------------------code----------------------
setuptools.setup(name="moodypdf",
                 version=1.0,
                 long_description="",
                 packages=setuptools.find_packages(
                     exclude=["tests", "data", "env"])
                 )
-------------------code----------------------
PS: we add env cause we have env file from the previous lecture




- Now we should create a readme file.
What we put in the readme file will be displayed in the homepage of our package
on pypi.

So, here in the root of the project let's add readme
and by convention we use all capital readme and then lowercase md
which is short for markdown.
-------------------code----------------------
README.md
-------------------code----------------------

- So here we can use the markdown syntax
for now we're just going to go with a simple example
this is the homepage of our project.
-------------------code----------------------
This is the homepage of our project.
-------------------code----------------------


- we also need a license file so once again in the root of the project
let's add license
-------------------code----------------------
LICENSE
-------------------code----------------------

- now if we head over to
choosealicense.com we can find a basic template for this
license file, so let's say we care about sharing improvements
click that here we can see a basic license
agreement template on the top we're going to click this button to copy
this to clipboard and then paste it into this file
that's our license.
-------------------code----------------------
https://choosealicense.com
-------------------code----------------------

 
- Now back to setup.py
we should set this long description to the content of our readme file
we should import the path class
and then create a pass object set it to readme.md and then call read text
-------------------code----------------------
import setuptools
from pathlib import Path

setuptools.setup(name="moodypdf",
                 version=1.0,
                 long_description=Path("README.md").read_text(),
                 packages=setuptools.find_packages(
                     exclude=["tests", "data", "env"])
                 )
-------------------code----------------------



- we added three files to our project a readme file, a license file
and a setup.py now we need to generate a distribution package
and that's pretty easy we open up the terminal
and run 
-------------------code----------------------
$ python3 setup.py sdist bdist_wheel
-------------------code----------------------

Note: sdist which is short for source distribution and bdist
underline wheel which is short for built distribution
so with this command we're going to generate.


- python setup.py two distribution packages
a source distribution and a built distribution
let's go ahead alright, now here we have
two new directories build and dist in the dist directory
we have a wheel file which is a built distribution
and a source distribution both these are zip files
we can unzip them and see what is inside if we're adventurous
-------------------code----------------------
moodypdf-1.0-py3-none-any.whl	moodypdf-1.0.tar.gz
-------------------code----------------------
- now that we have
these two distribution packages the final step
is to upload them to pypi.org back in the terminal
we use twine.

- so we're telling twine to upload all the files
in the dist directory
-------------------code----------------------
$ twine upload dist/*
-------------------code----------------------


- so back tp pypi.org if we search for
moody pdf we can find that here the current version is version 1
here on the homepage we have the content of our readme file so we can easily
install this package just like the other packages on pypi.

- for example
here in our project we're going to use pipenv
to install moody pdf.
-------------------code----------------------
pipenv install moodypdf
-------------------code----------------------

run the program and here's the output
so this verifies that we successfully
published a package to pypi.
-------------------code----------------------
from moodypdf import pdf2text

pdf2text.convert()
-------------------code----------------------
