*** 1- Pypi ***

- In the last section we explored python standard library. Now even though this library is very
comprehensive, it doesn't have everything that we potentially need when building a real application.

- There are times that we need features not implemented in python standard library.
That's where pypi or python package index comes into picture. Pypi is like npm or node package
manager for javascript developers. It's basically a repository of python packages built by people
like us.

- So if we head over to pypi.org, on this page we can see that currently we have
almost 600,000 projects registered in this repository.
-------------------code----------------------
https://pypi.org/
-------------------code----------------------

- For pretty much anything we imagine,
there is a python package here. Let's say we want to work with pdf files in our application.

- simply search for pdf. As we can see currently we have over 2,000 projects for working with pdf
files. Here are a few examples. This first package is a two-dimensional barcode generator.
We also have this package for managing and processing pdf files. 

- The next one is for converting a pdf file to text. We can also convert a pdf to image and so on. So we have tons and tons of packages for
working with pdf files. Of course not all of these are useful, some of them are buggy or incomplete,
but if we do a little bit of research, we can find a good and stable package for our projects.


- Alternatively, we can also google the best python packages for working with pdf files and see what
other people in the community say. So in this section we're going to learn about all the tooling we need
to install these packages and publish our own packages to this repository.

*** 2- Pip ***

- To install a package from pypi, we use a tool called pip.
Now if we're on mac, similar to python, we should use pip3.
-------------------code----------------------
$ pip3
-------------------code----------------------

- Now with this tool we can do various things, such as installing packages,
uninstalling them, upgrading them, or listing the currently installed
packages.

- Let's take a look at a few examples. So here to
install a package, as the first argument we pass, install,
and as the second argument, we specify the name of the target package.
So here we're going to install this requests package, which
we're going to use to send http requests.

-------------------code----------------------
$ pip3 install requests
-------------------code----------------------

- So, let's go ahead.
Alright, this is successfully installed,
but here down the bottom we have a warning in yellow that is saying we're
using pip version 24.3.1. However, version 25.0.1 is
available. So this version 24.3.1 is the version that came with my python
installation, but because pip is developed independently, we need to
upgrade it from time to time.
-------------------code----------------------
[notice] A new release of pip is available: 24.3.1 -> 25.0.1
-------------------code----------------------

- So, right below that we can see the command that
we need to run to upgrade pip.
-------------------code----------------------
pip3 install --upgrade pip
-------------------code----------------------

- Alright, now we have the latest version of pip.
Let's look at the packages that are
currently installed on my machine. So pip list.
-------------------code----------------------
$ pip3 list

Package            Version
------------------ ---------
certifi            2025.1.31
charset-normalizer 3.4.1
idna               3.10
pip                25.0.1
requests           2.32.3
urllib3            2.3.0
-------------------code----------------------

- Here in this list we can see we have installed
the version 2.32.3 of the requests package.
This version we see here is what we call semantic versioning.

- The first number represents the major version, the second
number represents the minor version, and the third number represents the patches
or bug fixes.


- Now back on pipi.org
let's search for the requests package. So here we have a few
packages with a similar name. We've got requests, request 3, and request 2.
And they're not always in the same order, so make sure to pick the
requests package without 2 or 3.

- Now on this page, on the left side we can see the
release history of this package. So the latest version that we've installed
is 2.32.3. There are times that we want to install an earlier
version, perhaps the latest version has a bug, or is incompatible
with the other packages we're referencing.
 
- how to install an earlier version. So back on the terminal, let's
say we want to install version 2.32.0. That is very easy. 
Just like before pip install requests, now we add two equal signs, followed by the version 2.32.0.
So as we can see, this successfully uninstalled
the latest version that was version 2.32.3, and then installed
version 2.32.0.
-------------------code----------------------
$ pip3 install requests==2.32.0
-------------------code----------------------

- Now here we can also use wildcards, for example,
pip install requests equal 2.32 asterisk. That means
install the latest compatible version with version 2.32.
So if there are any patches or bug fixes, include those as well.
-------------------code----------------------
$ pip3 install requests==2.32.*
-------------------code----------------------

- Now here on pypi.org, we can see we have three 2.32
versions, this is the base version, and then we got a couple more versions
before version 2.33. So when we run this command, pip will install
the latest compatible version with 2.32.0, which is 2.32.2.
Let's take a look. Now we got this message requirement, already
satisfied, because we already have version 2.32.0
installed. 

- So first we need to uninstall it before we install
the latest compatible version with this. So, that is very easy.
Pip, this time we're going to use uninstall and then request.
We don't care about the version. this is asking for confirmation so let's go ahead.
Now requests version 2.32.0 is uninstalled.
-------------------code----------------------
$ pip3 uninstall requests
-------------------code----------------------

- So now let's install
requests version 2.32 point asterisk. This will install
the latest compatible version with 2.32.
-------------------code----------------------
$ pip3 install requests==2.32.*
-------------------code----------------------

- We also have another syntax for installing the latest compatible version.
So instead of two we use a tilde
equal sign, and then here we specify a specific version.
Let's say 2.32.0 Once again, this will install the latest compatible version
with 2.32.0 which is 2.32.2.
-------------------code----------------------
$ pip3 install requests~=2.32.0
-------------------code----------------------

- Now we can use this asterisk with a minor version as well.
For example, let me uninstall this first so pip uninstall requests
ok, let's go ahead good now, pip instal requests 2.0 asterisk
This will install the latest compatible version with version 2.
-------------------code----------------------
$ pip3 install requests==2.*
-------------------code----------------------

- So back to the release history if we scroll to the very top
we can see the latest compatible version with version 2
is 2.32.3 Let's go ahead and run this
there we go so we successfully installed requests 2.32.3

- Now we can use this package just like the modules
in python standard library so we import request.
-------------------code----------------------
import requests
-------------------code----------------------

- now we have a module object with these members
we can read about these on the documentation for this package
so back on pipeui.org here on the page for the requests package
if we scroll down we can see a link to the documentation

- Now, back to our code we're going to call the get method
let's send an http request to google.com this returns
a response object for now let's simply print
the response on the terminal.

let's run the program so we got a response with the status
200 which indicates success
-------------------code----------------------
response = requests.get("http://google.com")
print(response)
# <Response [200]>
-------------------code----------------------

*** 3- Virtual Environments ***

- In the last lecture we learned how to install a package using pip. Now
let's run pip list, we can see
currently we have installed requests version 2.32.3.

-------------------code----------------------
$ pip3 list

Package            Version
------------------ ---------
certifi            2025.1.31
charset-normalizer 3.4.1
idna               3.10
pip                25.0.1
requests           2.32.3
urllib3            2.3.0
-------------------code----------------------

- there is a problem here. Let's say we have another
project and in that project we want to use an earlier version of this package.
With the current structure we cannot have two versions of any
of these packages side by side. We can have only a single version.
To solve this problem we need to create an isolated virtual
environment for each application and install these dependencies into
that virtual isolated environment.

- how to do that. So, here in the project folder we run python
dash m venv and then specify the name of a directory for containing this virtual environment. By convention
we call that env. 
-------------------code----------------------
$ python3 -m venv env
-------------------code----------------------

- PS: Now don't worry about memorizing any of these
because later we're going to show we a better
and simpler way. So technically we're never going to execute
this command after we show we the latest tools. we're just going to
take we on a step by step journey so we understand
exactly how these various tools come together.

So, let's go ahead and run this command.
Good. Now here on the file explorer panel we can see we have a new directory and
in this directory we have this config file with these parameters.
-------------------code----------------------
home = /Library/Frameworks/Python.framework/Versions/3.13/bin
include-system-site-packages = false
version = 3.13.1
executable = /Library/Frameworks/Python.framework/Versions/3.13/bin/python3.13
command = /Library/Frameworks/Python.framework/Versions/3.13/bin/python3 -m venv /Users/mahmouddabbbagh/moody/Python/Complete-Python-Mastery/10-Python-Package-Index/env
-------------------code----------------------

- Home is referencing the directory
where my python interpreter is installed. And here's the version of that interpreter.
So we're using c python version 3.13.1 We also have this bin or binary directory
where we have a bunch of tools like pip, pip3, python, python3 and so on.
Next to that we have include which is currently empty.
We have lib, inside of this directory we have python 3.13.1 and inside of that we have site packages.

Note: Now this directory structure is slightly different on windows
so if we're a windows user don't get hung up on these subtle differences.
Focus on the big picture. What matters here is that this site packages directory
is where we'll install the packages for this application.

- So a virtual directory is an isolated environment
where we have a specific python interpreter in this case c python version 3.13.1
as well as a bunch of packages that this application needs.

- Okay, now that we have a virtual environment
we need to activate it. Here in the bin folder
we have a script called activate.
We need to run this from the terminal.
So, back in the terminal, if we're on windows
we execute this script directly.
-------------------code----------------------
$ env\bin\activate.bat
-------------------code----------------------

-  If we're on mac or linux,
we will have to type source slash bin slash activate.
-------------------code----------------------
$ source env/bin/activate
(env) 10-Python-Package-Index +[feature/12_3]
-------------------code----------------------

There we go. Now we can see the name of the currently active
virtual environment. In this case, that is env.
We could call this anything, but by convention we use env.
So now that we are in the virtual environment
for this application, let's go ahead and install an earlier version of requests package.
-------------------code----------------------
$ pip3 install requests==2.32.1
-------------------code----------------------


- So as we can see we have installed
requests
version 2.32.1 which is different from the request package
that we installed globally on this machine. This is specific to this application.
Now back to our directory structure.
Now under the site packages directory we have this new directory
requests. This is where we have installed
the request package for this application.

- Finally, whenever we are done we need to deactivate
this virtual environment.
So, we run deactivate.
-------------------code----------------------
deactivate
-------------------code----------------------

*** 4- Pipenv ***

- So we have learned about pip and creating virtual environments. As we have noticed,
using these tools requires memorizing various commands and arguments. There's a lot to remember.
That's where pipenv comes in the picture. Pipenv is a tool that combines pip and virtual environments
into a single toolchain. So we don't have to use pip or virtual environments separately.
If we're familiar with npm or node package manager, pipenv is the equivalent tool in the
python world. So it's a dependency manager for python projects. Now we might be curious why
we didn't start this section with pipenv. Because as we told we, pipenv internally uses pip and virtual
environments, so we need to understand how exactly it works under the hood. Also, as we look at
various websites, we will come across pip or virtual environments, so we wanted to make sure
that these tools are not foreign to us.

- how to use pipenv.
Here on the terminal, first we need to install it.
-------------------code----------------------
$ pip3 install pipenv
-------------------code---------------------- 

- Alright, now, back to VS code, we're going to delete this env directory because we don't need it anymore.
We're going to use pipenv to automatically create a virtual directory. So delete, good.
Now back to the terminal, instead of using pip to install a package, we use pipenv.
-------------------code---------------------- 
$ pipenv install requests
-------------------code----------------------

- This tool created a couple of files, pip file, and pip file.lock,
we'll look at this later. It also created a virtual environment for us, and installed this request
package inside of that virtual environment.

- But that virtual environment is not here. Where is it? Let me show we. So here on the terminal, let's run pipenv, dash dash, venv.
This is the path to our virtual environment directory. As we can tell, this directory is not part of our
project, and this is a deliberate decision. Because as we install various packages, we'll end up with
hundreds or even thousands of files in this virtual environment. And this will increase the size of our
project. So we want to exclude this virtual environment from our project directory.
-------------------code---------------------- 
$ pipenv --venv
# /Users/mahmouddabbbagh/.local/share/virtualenvs/10-Python-Package-Index-Aaz2bPmn
-------------------code----------------------

- Now, we're going to uninstall the request package that we installed globally using pip.
So, pip, uninstall, requests.
-------------------code---------------------- 
$ pip3 uninstall requests
-------------------code---------------------- 

- So we installed a dependency using pipenv, now let's run our application. But for this demo,
we're not going to use code runner, we will see why in a second. So let's run python
app3.py. We got a module not found error. No module named requests. Because we removed the requests package
from the list of global packages. And here, python doesn't know where to locate this package.
It has no knowledge of this new virtual environment.
-------------------code---------------------- 
import requests
ModuleNotFoundError: No module named 'requests'
-------------------code---------------------- 

- So we need to activate it. Once again,
we use the same tool, that is pipenv, and as the first argument, we pass shell.
-------------------code---------------------- 
pipenv shell
-------------------code---------------------- 

- So, as we can see, it's activated the virtual environment for this project. Now let's run our
program one more time. We got a response, beautiful. So python could successfully locate
the requests package.
-------------------code---------------------- 
(10-Python-Package-Index) 10-Python-Package-Index +[main] $ python3 app3.py
<Response [200]>
-------------------code---------------------- 

-  So here, we're currently in the virtual environment for this project.
If we want to deactivate it, simply type exit. Now we're outside of the virtual environment.
-------------------code---------------------- 
exit
-------------------code---------------------- 
