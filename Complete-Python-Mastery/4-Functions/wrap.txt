*** 1- Defining Functions ***
So Far we have learned how to use some of the built-in functions in Python such as print round and so on in this section
we're going to learn how to write our own functions now.

- why do we even need to write our own functions?
when we build a real program that program is going to consist hundreds or thousands of lines of code
we shouldn't write all that code in one file like we have done so far
we should break that code into a smaller more maintainable and potentially more reusable "chunks"
we refer to these "chunks" as "functions". 


- how to create our own custom functions?
We start with the "def" keyword which is short for define
Next we need to give our function a name, So let's call this greet.

PS: all the best practices we learned about naming our variables also apply to naming our functions
So make sure our function names are meaningful
Descriptive use lowercase letters to name our functions and an underscore to separate multiple words

Now after the name we need to add
Parenthesis we will see why shortly and then we'll add a colon now what is going to happen?

we know it we're going to get indentation which means the following statements will belong to this function
we add two statements
Both these lines belong to this function because they're indented
-------------------code----------------------
def greet():
    print("Hi there")
    print("Welcome aboard")
-------------------code----------------------

Now we're done with this function. We need to call it
So we remove the indentation and  adding two line breaks after this function This is what pep 8 recommends
to keep our code clean and maintainable.


we call this function greet with parentheses just like how we call the built-in functions.
-------------------code----------------------
def greet():
    print("Hi there")
    print("Welcome aboard")


greet()

=> Hi there
Welcome aboard
-------------------code----------------------

*** 2- Arguments ***
What is the difference between the greet and Print functions?
the difference is that this print function takes an input
Whereas our greet function doesn't take any inputs.

- how to pass inputs like first name and last name to this function.
When defining a function in between parentheses will list our parameters
So here we add two parameters like first underline name and last underline name
Now when calling this function, we need to supply two values for those parameters. We refer to them as arguments
so "Moody Lili" these are the arguments to the greet function
-------------------code----------------------
def greet(first_name, last_name):
    print("Hi there")
    print("Welcome aboard")


greet("Moody", "Lili")
-------------------code----------------------


difference between parameters and arguments.
- parameter: is The input that you define for our function.
- argument: is the actual value for a given parameter.

now instead of saying hi there
We can greet a person by their full name so we can convert it to a formatted string and
Pass two fields here first name as well as last name
-------------------code----------------------
def greet(first_name, last_name):
    print(f"Hi {first_name} {last_name}")
    print("Welcome aboard")


greet("Moody", "Lili")

=> Hi Moody Lili
Welcome aboard
-------------------code----------------------




This function is more useful. We can reuse it and call it with different arguments. 
So let's greet John Smith as well
-------------------code----------------------
def greet(first_name, last_name):
    print(f"Hi {first_name} {last_name}")
    print("Welcome aboard")


greet("Moody", "Lili")
greet("John", "Smith")

=> Hi Moody Lili
Welcome aboard
Hi John Smith
Welcome aboard
-------------------code----------------------

note: by default all the parameters that you define for a function are required
So here our greet function takes two parameters if I exclude one of these arguments and save the changes
You can see we have this red on the line
Spylent is complaining and saying
-------------------code----------------------
No value for argument 'last_name' in function call
-------------------code----------------------

Also, if we run the program we get this 
-------------------code----------------------
Type error greet missing one required positional argument
-------------------code----------------------


*** 3- Types of Functions ***
so this is the simplified version of this great function we created earlier 
-------------------code----------------------
def greet(name):
    print(f"Hi {name}")
-------------------code----------------------


now in programming
we have two types of functions 
1- functions that perform a task
2- functions that calculate and return a Value

both the print and greet functions are examples of type one "functions that perform a task"
the round function is an example of a function that calculates and returns a value so the functions
-------------------code----------------------
print(round(1.9))
=> 2
-------------------code----------------------

how to rewrite great function to be "functions that calculate and return a Value" 
we use the "return statement" keyword
-------------------code----------------------
def get_greeting(name):
    return f"Hi {name}"


get_greeting("Moody")
-------------------code----------------------


- now we can print the value 
-------------------code----------------------
print(get_greeting("Moody"))
=> Hi Moody
-------------------code----------------------

or even store it in variable
-------------------code----------------------
message = get_greeting("Moody")
-------------------code----------------------

which form of this greeting functions is better? 
- this first implementation (greet function) we are locked 
to printing something in the terminal in the future if you want to write that message in a file or send it in an email we have to create
another function so we cannot reuse this great function in other scenarios.

in contrast this second form is not tied to printing something on the terminal.
-------------------code----------------------
print(message)
=> Hi Moody
-------------------code----------------------

it simply returns a value now we get this value and we can do
whatever we want with it we can print it on the terminal or we can use the built-in open function to write this
message to a file so we can create a file like content dot txt open it for writing this returns a file object.
and then we can call file that write message
-------------------code----------------------
file = open("content.txt", "w")
file.write(message)
-------------------code----------------------

- but what we want to take away here is that we have this message
variable and we can do whatever we want with it we can
print it on the terminal, write it to a file, send it in an email and so on

- what if we call great which already had print function inside print function l
we get hi mosh followed by none what is this
-------------------code----------------------
def greet(name):
    print(f"Hi {name}")


print(greet("Moody"))
=> Hi Moody
None
-------------------code----------------------

- None is the return value of the greet function
so in python all functions by default
return the none value.

- none is an object that represents the absence of a value
means it's return nothing.

- all functions return none by default unless you specifically return a value
so here if we return some string
none will no longer be returned
-------------------code----------------------
def test(name):
    # print(f"Hi {name}")
    return "...."
-------------------code----------------------

PS: even though this function returns none by default
it is still classified as a function that carries out a task
-------------------code----------------------
def greet(name):
    print(f"Hi {name}")
-------------------code----------------------

*** 4- Keyword Arguments ***
Let's create another function
We call it increment. We want to use this function to increment a number by a given value.
and store it in in a variable "result" and then print it on the terminal
-------------------code----------------------
def increment(number, by):
    return number + by


result = increment(2, 1)
print(result)
=> 3
-------------------code----------------------

- We can simplify this code
We have used this result variable only in a single place that is line 6
So we don't really need it. So on line 6 we can replace result with a call to increment function
like this
-------------------code----------------------
def increment(number, by):
    return number + by


print(increment(2, 1))
-------------------code----------------------

- So when Python interpreter executes this code first, it will call the increment function
It will get the result and temporarily store it in a variable for us
We don't see that variable and then it will pass that variable as an argument to the print function


- Now if we run this program we get the exact same result
-------------------code----------------------
def increment(number, by):
    return number + by


print(increment(2, 1))
=> 3
-------------------code----------------------

- Now we can make this code more readable
if someone else looks at line 5 they may not know exactly What these arguments are for we can use a "keyword argument"
to make this code more readable So this one here is the value of this by parameter. 
We can prefix it With the name of the parameter like this
-------------------code----------------------
print(increment(2, by=1))
# 3
-------------------code----------------------

Now we can read this code almost like plain English
increment 2 by 1

So if you're calling a function with multiple arguments and it's not quite clear what these arguments are for
You can make your code more readable by using keyword arguments.

*** 5- Default Arguments ***
- all the parameters that we define for a function are required by default.

- how to make the by parameter optional?
let's say we don't
want to explicitly pass by equals one every time we want to call this increment function


- so we want to give this parameter a default value so we set it to one
now if we call this function and don't supply the second argument this default value will be used otherwise the value that we
specify will be used
-------------------code----------------------
def increment(number, by=1):
    return number + by

print(increment(2))
# 3

print(increment(2, 2))
# 4
-------------------code----------------------
PS: just be aware that all these optional parameters should
come after the required parameters.

in other words. we cannot add another required parameter "another" if we save the changes we can see we get a red underline
so all the optional parameters should come after the required parameters 
-------------------code----------------------
def increment(number, by=1, another):
    return number + by

error: "another" is not accessed
-------------------code----------------------


*** 6- xargs ***
There are times that you may want to create a function that takes a variable number of arguments.

example: let's define this function multiply that takes two parameters x and y and
simply returns x times y now we can call this function 
-------------------code----------------------
def multiply(x, y):
    return x * y


result = multiply(2, 3)
print(result)
=> 6
-------------------code----------------------



- like this so far so good but what if you want to pass one or two more arguments here that doesn't work because our multiply function
takes only two parameters to solve this problem we need to replace these two parameters with a
single parameter we use a plural name here to indicate that this is a collection of arguments.
and then we prefix it with an "asterisk" now we try to print them
-------------------code----------------------
def multiply2(*numbers):
    print(numbers)


multiply2(2, 3, 4, 5)
=> (2, 3, 4, 5)
-------------------code----------------------

- we can see all our arguments and they're packed in parentheses
what is this well earlier you learned about lists when we use square brackets
-------------------code----------------------
[1, 2, 3, 4, 5, 6] => called list
(2, 3, 4, 5) => called tuple
-------------------code----------------------


- the difference is that.
in tuples we cannot modify this collection we cannot add a new object to this tuple.

tuples just like lists are iterable so we can iterate over them which means we can use them in loops.
-------------------code----------------------
def multiply3(*numbers):
    for number in numbers:
        print(number)


multiply3(2, 3, 4, 5)
=> 2
3
4
5
-------------------code----------------------
 
- so now with a simple change we can calculate the product of all
these numbers all we have to do is to define a variable like "total" initially we set it to one.

- and then in each iteration we get total and multiplied by the current number or we can rewrite this statement
using an augmented assignment operator so total times equal number.
-------------------code----------------------
def multiply4(*numbers):
    total = 1
    for number in numbers:
        total *= number
    return total


final_result = multiply4(2, 3, 4, 5)
print(final_result)
=> 120
-------------------code----------------------

PS: one of the issues i see often in beginners code is that they don't
use this indentation properly so they put the return statement here and then they wonder why their
function doesn't work properly if you put the return statement here it will be part of the for loop
so it will be executed in each iteration in this case after the first iteration because of this return
statement will return from this multiply function so the total will not be calculated properly.
-------------------code----------------------
def multiply4(*numbers):
    total = 1
    for number in numbers:
        total *= number
        return total
-------------------code----------------------

- so we need to put this at the same level of indentation as other statements in this function 
-------------------code----------------------
def multiply4(*numbers):
    total = 1
    for number in numbers:
        total *= number
    return total


final_result = multiply4(2, 3, 4, 5)
print(final_result)
=> 120
-------------------code----------------------
