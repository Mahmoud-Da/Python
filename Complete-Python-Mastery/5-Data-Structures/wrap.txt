*** 1- Lists ***
- In this section, we're going to look at the built-in data structures in python,
which are extremely important when building real applications.

First, we're going to look at lists, and then we'll look at tuples, sets, and dictionaries.
So earlier we have seen that we can use square brackets
to define a list or a sequence of objects.
-------------------code----------------------
["a", "b", "c"]
-------------------code----------------------


- In between these brackets we can have objects of any type, so we can have a list
of strings ,and then assign it to a variable like letters.
-------------------code----------------------
letters = ["a", "b", "c"]
-------------------code----------------------


- We can also have a list of numbers, booleans.
-------------------code----------------------
numbers = [1, 2, 3, 4]
-------------------code----------------------

- or even we can have a list of lists.
So here we have a list, each item in this list
will be a list itself. So here's the first item, which is
a list of two items. Now let's add another item
to our main or parent list. This item is also a list
a list with two items. 
So now we have a matrix, which is a two dimensional list.
-------------------code----------------------
matrix = [[1, 2], [3, 4]]
-------------------code----------------------

- we have some cool tricks. Let's
say we want to have a list of a hundred
zeros. we don't want to manually
create that like this, that's very ugly.
-------------------code----------------------
[0, 0, 0, 0, 0, 0 ....]
-------------------code----------------------


- instead we can define a list of one item,
one zero, and then we can multiply it by a hundred.
And the result will be this. 
-------------------code----------------------
zeros = [0] * 100
print(zeros)
=> [0, 0, 0, 0, 0, 0, 0, 0,,,,]
-------------------code----------------------

- So using a star or an asterisk, we can repeat
the items in a list.


- Now similarly, we can use a plus to
concatenate multiple lists.
-------------------code----------------------
letter1 = ["a", "b", "c"]
zeros1 = [0] * 5
combined = zeros1 + letter1
=> [0, 0, 0, 0, 0, 'a', 'b', 'c']
-------------------code----------------------

PS: in python, every object in a list can be of a different type.
So they don't have to be exactly the same type.
We can combine a list of numbers with strings and booleans or even
lists.

- Now let's say we want to have a list of numbers
like 0, 1, 2, 3, all the way up to 20. we don't want to type all of these by hand.
There is a better way. So we have this list function. As we can see, this function
takes an iterable. So we can pass any iterable as argument and convert it to a list.
Earlier we learned about the range function. This function returns
a range object which is iterable. Which means we can iterate or loop over it. So here we can
call this function and pass 20 and with this we can create a list of numbers from 0 to 20.
-------------------code----------------------
numbers = list(range(20))
print(numbers)
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
-------------------code----------------------

- As another example, let's call the list function and pass a string.
Earlier we said that strings are also iterable.
so, We can loop over them. So we can pass them to the list function.
-------------------code----------------------
char = list("Hello World")
print(char)
=> ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']
-------------------code----------------------

- we can get the number of items in that list using the len function.
So here we can print the len or length of chars.

-------------------code----------------------
print(len(char))
=> 11
-------------------code----------------------

*** 2- Accessing Items ***
- here we have a list of four items, we can use square brackets to access individual items
in this list.
-------------------code----------------------
letters = ["a", "b", "c", "d"]
-------------------code----------------------


- print letters of 0, this will return the first item in this list.
-------------------code----------------------
letters = ["a", "b", "c", "d"]
print(letters[0])
=> "a"
-------------------code----------------------

Now similar to strings, if we pass a negative index,it will return the first item from the end of the list. 
-------------------code----------------------
letters = ["a", "b", "c", "d"]
print(letters[-1])
=> "d"
-------------------code----------------------


- we can also modify items in the list, so let's change the first item to a capital "A".
-------------------code----------------------
letters2 = ["a", "b", "c", "d"]
letters2[0] = "A"
print(letters2)
=> ["A", "b", "c", "d"]
-------------------code----------------------

- Now earlier in the course, we learned that we can use two indexes to slice a string. 
we have the exact same concept in the list.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[0:3])
=> ['A', 'b', 'c']
-------------------code----------------------


- PS: using slice operator will return a new list with the first three items
in our original list. So if we print our original list, we can see that it's not changed. 
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[0:3])
=> ['A', 'b', 'c']

print(letters3)
=> ["A", "b", "c", "d"]
-------------------code----------------------

- just like strings, if we don't specify the first argument, zero will be assumed by default.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[:3])
=> ['A', 'b', 'c']
-------------------code----------------------

- So as we can see, these two expressions produce the exact same result.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[0:3])
=> ['A', 'b', 'c']

print(letters3[:3])
=> ['A', 'b', 'c']
-------------------code----------------------

- Similarly, if we don't include the end index, by default, the length of the list
will be used.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[0:])
=> ["A", "b", "c", "d"]
-------------------code----------------------


- And similarly, we can also exclude the start index here. And with this syntax, we can get a copy of our original list.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]

print(letters3[:])
=> ["A", "b", "c", "d"]
-------------------code----------------------

- Now when slicing a string, we can also pass a "step", and this is useful in situations
where we want to return every second or every third element in the original list.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[::2])
=> ['A', 'c']
-------------------code----------------------

- another example, Create a new list called numbers, and call the range function.
-------------------code----------------------
numbers = list(range(10))
print(numbers)
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
-------------------code----------------------

- using "step" to get all the even numbers
-------------------code----------------------
numbers = list(range(10))
print(numbers[::2])
# [0, 2, 4, 6, 8]
-------------------code----------------------

- to reverse a list we can use step with  -1.
-------------------code----------------------
numbers = list(range(10))
print(numbers[::-1])
=> [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
-------------------code----------------------

*** 3- List Unpacking ***
There are times that we may want to get individual items in a list and assign them
to different variables.
-------------------code----------------------
numbers = [1, 2, 3]
first = numbers[0]
second = numbers[1]
third = numbers[2]
-------------------code----------------------

- Now there is a cleaner and more elegant way to achieve the same result, 
and that is what we call list "unpacking".
So we can unpack this list into multiple variables.
-------------------code----------------------
first, second, third = numbers
-------------------code----------------------

- What we have on now  is exactly identical to what we have when assign the variable manually.
This is what we call list unpacking.

- Now what is important here is that the number of variables that we have on the left side
of the assignment operator should be equal to the number of items we have in the list.
So if we exclude third here, and run this program, we will get an error.
So there are too many items in this list, and we cannot unpack it into enough variables.
-------------------code----------------------
first, second = numbers
# ValueError: too many values to unpack (expected 2)
-------------------code----------------------

- Now what if in this list we have so many items, but we only care about the first two.
We don't want to define so many variables on the left side of the assignment operator.
-------------------code----------------------
numbers2 = [1, 2, 3, 4, 4, 2, 1]
first, second, *other = numbers2
-------------------code----------------------


- With this syntax, we'll get the first and second items and everything else will be stored in
a separate list called other.
-------------------code----------------------
numbers2 = [1, 2, 3, 4, 4, 2, 1]
first, second, *other = numbers2
print(first, second)
# 1 2
print(other)
# [3, 4, 4, 2, 1]
-------------------code----------------------


- So in this example, we have both unpacking and packing.
First we try to unpack first and second list into the variables on the left side of the
assignment operator, and then because we have used an asterisk here, we're basically packing
all the other items into a separate list.
-------------------code----------------------
first, second, *other = numbers2
-------------------code----------------------

Now to refresh our memory, earlier we used this syntax when
defining a function with a variable number of arguments. We had a function like this, where 
we set the parameter with an asterisk, with that python would get all these arbitrary arguments, and pack them
into a tuple.
-------------------code----------------------
def multiple(*args):
    return args


print(multiple(1, 2, 3, 4, 5))
# (1, 2, 3, 4, 5)
-------------------code----------------------

- What if we care only about the first and the last item?
Well, we can put other in between, so we get the first, other,
and then the last item.
-------------------code----------------------
numbers3 = [1, 2, 3, 4, 4, 2, 9]
first, *other, last = numbers3
print(first, last)
# 1 9
print(other)
# [2, 3, 4, 4, 2]
-------------------code----------------------

*** 4- Looping over Lists *** 
-  how to loop over lists. So here we have a list of three items, we can use our for loops to loop over
this list.
-------------------code----------------------
letters = ["a", "b", "c"]
for letter in letters:
    print(letter)
# a
# b
# c
-------------------code----------------------

- what if we want to get the index of each item as well?
Well, we have a built in function called enumerate,
we call it here, and this will return an enumerate object, which is iterable.
In each iteration this enumerate object will give us a tuple.
-------------------code----------------------
letters = ["a", "b", "c"]
for letter in enumerate(letters):
    print(letter)
# (0, 'a')
# (1, 'b')
# (2, 'c')
-------------------code----------------------

- a tuple as we told before is like a list but it's read only, we cannot add new items to it.
So in each iteration we're getting a tuple of two items the first item in this tuple is the index, and the second
item is the item at that index. So now to get the index, we can use square brackets.
-------------------code----------------------
letters = ["a", "b", "c"]
for letter in enumerate(letters):
    print(letter[0], letter[1])
# 0 a
# 1 b
# 2 c
-------------------code----------------------

- But this syntax is a little bit ugly. In the last lecture we learned about list unpacking.
So if we have a list with two items we can unpack it into two variables index and letter equals items.
-------------------code----------------------
items = [0, "a"]
index, letter = items
-------------------code----------------------

- So here we are unpacking the items list. Now what if we change square brackets
to parentheses?
Now we have a tuple and we can still unpack this tuple.
-------------------code----------------------
items = (0, "a")
index, letter = items
-------------------code----------------------


- So we saw that this enumerate function returns an enumerate
object which is iterable. In each iteration, this
enumerate object will return a tuple So we can unpack it immediately.
-------------------code----------------------
for index, letter in enumerate(letters):
    print(index, letter)
# 0 a
# 1 b
# 2 c
-------------------code----------------------

- So to recap we can use for loops to iterate over lists. If we also need the index
we should call the enumerate function this will return an enumerate
object which is iterable in each iteration it will return a tuple and we can unpack that tuple.

*** 5- Adding or Removing Items ***
- how to add new items to a list or remove existing items. So for adding items we have two options
depending on where we want to add this new item.

- If we want to add an item at the end of the list, we should use the append method.
-------------------code----------------------
letters = ["a", "b", "c"]

letters.append("d")
print(letters)
# ['a', 'b', 'c', 'd']
-------------------code----------------------

PS: So, earlier we learned that everything in python is an object, so we can use the dot notation to access individual
functions or more accurately methods in that object. So when a function is part of an object, we refer to that function as a method.
So here are all the methods available on list objects.

-  Now if we want to add an item at a specific position, we should use the insert method. So letters that insert, we can add
something at the beginning of the list.
-------------------code----------------------
letters.insert(0, "-")
print(letters)
# ['-', 'a', 'b', 'c', 'd']
-------------------code----------------------

- Now for removing objects, again we have a few different options, if we want to remove
the item at the end of the list, we should use the pop method.
-------------------code----------------------
letters = ["a", "b", "c"]
letters.pop()
print(letters)
# ['-', 'a', 'b', 'c', 'd']
-------------------code----------------------

- we can also pass an index here, to remove the item at the given index. So,
if we pass 0, instead of D, this hyphen will be removed.
-------------------code----------------------
letters = ['-', 'a', 'b', 'c', 'd']
letters.pop(0)
print(letters)
# ['a', 'b', 'c', 'd']
-------------------code----------------------

- there are times that we want to remove an object, but we don't know its index.
If that's the case, we can use the remove method, so letters that remove, here we can remove "b",
and this will remove the first occurrence of the letter "b".
-------------------code----------------------
letters = ['-', 'a', 'b', 'c', 'd']
letters.remove("b")
print(letters)
# ['-', 'a', 'c', 'd']
-------------------code----------------------

PS: So if we have multiple "b"'s, only the first one will be removed. If we want to remove
all "b"'s in this list, we will have to loop over this list, and remove each "b" individually.

- We have another way to remove an item from a list, and that is using the del or delete statement.
So here we can delete an item by its index,
-------------------code----------------------
letters = ['-', 'a', 'b', 'c', 'd']
del letters[0]
print(letters)
# ['a', 'b', 'c', 'd']
-------------------code----------------------

- we can also delete a range of items. So this is the difference between the delete statement
and the pop method. 
The pop method will remove only one item by index, whereas with the delete statement, we can remove a range
of items.
-------------------code----------------------
letters = ['-', 'a', 'b', 'c', 'd']
del letters[0:3]
print(letters)
# ['c', 'd']
-------------------code----------------------

- finally if we want to remove all the objects in the list, we should use the clear method.
-------------------code----------------------
letters = ['-', 'a', 'b', 'c', 'd']
letters.clear()
print(letters)
# []
-------------------code----------------------

*** 6- Finding Items ***
- There are times that we want to find the index of a given object in a list.
So, let's say we want to find the index of letter "a" in our letters list.
 
-  What if we try to get the index of an object that doesn't exist here, like "d".
We get a value error, "d" is not in the list. This behavior is different from a lot of programming
languages out there, C based languages return negative 1, if we try to get the index of an object that doesn't exist in the list.
But in python, we get an error.
-------------------code----------------------
letters = ["a", "b", "c"]
print(letters.index("d"))
# ValueError: 'd' is not in list
-------------------code----------------------

- So, to prevent this error from happening, first we should check to see if the given object exists
in the list. And for that we use the in operator, so if D is in letters, then we will
print its index.now we run the program and we don't get any errors.
-------------------code----------------------
letters = ["a", "b", "c"]
if "d" in letters:
    print(letters.index("d"))
# 
-------------------code----------------------
 
- another method that we might find useful in certain situations, and that is
count. So letters dot count, this will return the number of occurrences of the given item in this list.
-------------------code----------------------
letters = ["a", "b", "c"]
print(letters.count("d"))
# 0
-------------------code----------------------

*** 7- Sorting Lists ***
Here we have this list with a bunch of numbers that are not in any particular order.
To sort this list we call sort method.
-------------------code----------------------
numbers = [3, 51, 2, 8, 6]
numbers.sort()
print(numbers)
# [2, 3, 6, 8, 51]
-------------------code----------------------

-  What if we want to sort these items in descending order?
Well, this sort method takes two parameters
key which we'll look at later, and reverse which we can use
to change the sort order.
-------------------code----------------------
numbers = [3, 51, 2, 8, 6]
numbers.sort(reverse=True)
print(numbers)
# [51, 8, 6, 3, 2]
-------------------code----------------------

- However, in addition to the sort method, we have a built-in function called sorted.
as we can see this function takes an iterable, so we can pass any
iterables here and it will sort it for us.
-------------------code----------------------
numbers = [3, 51, 2, 8, 6]
print(sorted(numbers))
# [2, 3, 6, 8, 51]
-------------------code----------------------

- PS: unlike the sort method, this will not modify the original list, it will return a
new sorted list. 



- Also similar to the sort method, if we want to change the sort
order, we can simply set the reverse argument to true.
-------------------code----------------------
numbers = [3, 51, 2, 8, 6]
print(sorted(numbers, reverse=True))
# [51, 8, 6, 3, 2]
-------------------code----------------------

- sorting numbers and strings is pretty easy, but what if we're dealing with a list of complex
objects? For example, what if we have a list of tuples?

-  Let's imagine we are building an application
for processing orders, and we have this list of order items. Every item in this list
is a tuple with two items. The product name, followed by the price.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]
-------------------code----------------------

- What happens if we try to sort this list? Let's take a look, so items.sort, 
and then we print the items, so nothing is changed here, because python doesn't know how
to sort this list.

-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]

items. sort()
print(items)
# [('Product1', 10), ('Product2', 9), ('Product3', 12)]
-------------------code----------------------

- In situations like this, we need to define a function that python will use for sorting lists.
So, here we're going to define a function, let's call it sort underline item,
this function should take an item like this tuple, and it should return a value that will be used for sorting.
In this example, let's imagine we want to sort these items based on their price.
So, if each item is a tuple, we can get the price using square brackets of 1. 
So all this function does is that it takes an item
and it returns its price.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]


def sort_item(item):
    return item[1]
-------------------code----------------------


- Now python is dealing with a list of numbers, and it can easily sort that list. Now finally
we need to pass this function when sorting our list of items.

- So once again, we look at this sort method, the first parameter is key, and this is where we need to pass our sorting function.
So we pass sort underline item.

PS: we're not calling this function, we're simply passing a reference to this function.
When python attempts to sort this list, the list of items, it gets each item, and it will pass each item
to our sort function.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]


def sort_item(item):
    return item[1]


items. sort(sort_item)
print(items)
# TypeError: sort() takes no positional arguments
-------------------code----------------------


- So, let's run this program and see what happens. We get a type error.
Sort takes no positional arguments, which basically means
here we can only use keyword arguments. So we need to specify our argument that is key, we set it to
sort item.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]


def sort_item(item):
    return item[1]


items. sort(key=sort_item)
print(items)
# [('Product2', 9), ('Product1', 10), ('Product3', 12)]
-------------------code----------------------

*** 8- Lambda Functions ***
- If we have any experience with other programming languages, we've probably heard of the term lambda expression or
lambda function.

- It's basically a simple one line anonymous function that we can pass to other functions.
So here on in our code, we're passing a reference to our sort underline item function,
we can improve this code and make it cleaner by using a lambda expression or an anonymous function.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]


def sort_item(item):
    return item[1]


items. sort(key=sort_item)
print(items)
# [('Product2', 9), ('Product1', 10), ('Product3', 12)]
-------------------code----------------------

- So we don't have to define this function first and then pass it here. So, we remove this
and add lambda, with this we're telling python that we're defining a lambda or anonymous function.

- The syntax for writing a lambda function is like this. We add parameters
-------------------code----------------------
lambda parameters: expression
-------------------code----------------------

- So using this syntax, we can rewrite this function. by replace the parameters keyword with item 
and pass instead of the expression what we return in the sort_item function which is item[1].
-------------------code----------------------
# lambda parameters: expression
items. sort(key=lambda item: item[1])
-------------------code----------------------

- Now we can see with this syntax, we don't need to use
def for defining a function, we don't need to give our function a name, we don't need this parenthesis here,
and we don't need the return statement.
So this is a shorter and cleaner way to define a function that we're going to use only once
as an argument to another function.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]


items. sort(key=lambda item: item[1])
print(items)
# [('Product2', 9), ('Product1', 10), ('Product3', 12)]
-------------------code----------------------

*** 9- Map Function ***
- So here we have this list of items, let's imagine we want to transform this list
into a different shape, so currently each item in this list is a we're of two items, let's say we're only interested in the
price of these items, so we want to transform this list into a list of numbers, that is the list of prices.
Here is a basic way
- We can define an empty list
- then iterate over our list of items
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]

prices = []

for item in items:
    prices.append(item[1])

print(prices)
# [10, 9, 12]
-------------------code----------------------



- Now there is a better and more elegant way to achieve the same result.
Instead of this loop, we can use the map function. So
we call the built in map function, as we can see this function takes
two parameters, a function and one or more iterables.
So as the first argument we can pass a lambda function and as the second argument we can
pass our list of items.
-------------------code----------------------
x = map(lambda item: item[1], items)
print(x)

# <map object at 0x104f8b160>
-------------------code----------------------

- This map function will apply our lambda function on each item in this list.
and this map function returns a map object which is another iterable.
-------------------code----------------------
x = map(lambda item: item[1], items)
for item in x:
    print(item)

# 10
# 9
# 12
-------------------code----------------------

-  Alternatively, we can convert this map object into a list object.
So, we can use our list function earlier we learned that we can pass any iterables
to this list function to create a new list.
-------------------code----------------------
x = list(map(lambda item: item[1], items))
print(x)
# [10, 9, 12]
-------------------code----------------------


- now we can rename x to prices and simply print prices.
-------------------code----------------------
prices = list(map(lambda item: item[1], items))
print(prices)
# [10, 9, 12]
-------------------code----------------------


- how the map function works?
It takes a lambda function and applies it on every item of this iterable.


*** 10- Filter Function ***
- Here's another scenario for using a lambda function. So we have our list
of items, let's say we want to filter this list and only get
the items with price greater than or equal to $10.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]
-------------------code----------------------

- Again, one basic way is to define an empty list, like filtered,
then we iterate over our list of items for each item we get the price, if it matches our criteria
we'll add it to this list.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]


filtered = []
for item in items:
    if item[1] >= 10:
        filtered.append(item)

print(filtered)
# [('Product1', 10), ('Product3', 12)]
-------------------code----------------------


- but that's pretty basic, a better approach is to use the built in filter function.
we Look at the parameters, this function just like the map function takes
two parameters, a function and an iterable.

- we're going to pass a lambda function, this function takes an item
and returns a boolean value that determines if this item
matches a criteria or not.

- In this case, we want to get the price of each item and see if it's greater than
or equal to $10. So the result of this expression is a boolean value, if it's
true, this item will be returned. and as a second argument to the filter function, we pass
our items list.

- 
-------------------code----------------------
x = filter(lambda item: item[1] >= 10, items)
print(x)
# <filter object at 0x10317b1c0>
-------------------code----------------------

- we get a filter object. A filter object just like a map object is iterable, so we can
loop over it, and we can also convert it to a list right away.
-------------------code----------------------
x = list(filter(lambda item: item[1] >= 10, items))
print(x)
# [('Product1', 10), ('Product3', 12)]
-------------------code----------------------

*** 11- List Comprehensions ***
- So here's the usage of map and filter functions that we just learned about.
These two functions are pretty useful in python, and they're often used by
developers who come from a functional programming background. So the
concept of mapping and filtering lists is very natural to them.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]

prices = list(map(lambda item: item[1], items))
print(prices)
# [10, 9, 12]

filtered = list(filter(lambda item: item[1] >= 10, items))
print(filtered)
# [('Product1', 10), ('Product3', 12)]
-------------------code----------------------

- But in python we have another feature for achieving the same result
and as far as we know, we don't have this feature in other programming languages.
That is called "comprehension". Here's the basic syntax.

We add our square brackets for defining a list, and here we'll write a comprehension
expression like this. 
-------------------code----------------------
[expression for item in items]
-------------------code----------------------

- now if we want to get the price of each item, we can write an expression like this,
item of one. So this is what we call a list comprehension, and it produces the exact same
result as what we have on line7.  As we can see, this code is shorter
and cleaner, we don't have all these parentheses and colon, what we have on line 7
is a little bit ugly and noisy.
-------------------code----------------------
prices = list(map(lambda item: item[1], items))
print(prices)
# [10, 9, 12]

prices = [item[1] for item in items]
print(prices)
# [10, 9, 12]
-------------------code----------------------

- Now, some developers might disagree, but generally speaking, in the Python
community, the preferred way to map and filter lists
is to use list comprehensions.

- But we included the map and filter functions in this course because as we look at the code
written by others, we'll probably come across instances of using the map and filter functions.
So we wanted to make sure that we really understand how they work. But as a best
practice, my recommendation to we is to use list comprehensions because they're cleaner and also more performant.

- we can also filter items. So, if we want to rewrite
what we have on line 10, using a list comprehension, that will look like this.
-------------------code----------------------
[expression for item in items if statement]
-------------------code----------------------

- we set it to square brackets, so we're defining a new list,
no need to call the list function. In between the brackets, we'll write an expression.
-------------------code----------------------
filtered = list(filter(lambda item: item[1] >= 10, items))
print(filtered)
# [('Product1', 10), ('Product3', 12)]


filtered = [item for item in items if item[1] >= 10]
print(filtered)
# [('Product1', 10), ('Product3', 12)]
-------------------code----------------------

*** 12- Zip Function ***

- Here we have two lists, let's say we want to combine these two lists into a single list of we'res like this.
So we have a list where each item is a tuples.
-------------------code----------------------
list1 = [1, 2, 3]
list2 = [10, 20, 30]
[('a', 1, 10), ('b', 2, 20), ('c', 3, 30)]
-------------------code----------------------

- So how can we combine these two lists into a single list like this?
Well in this case we can't use the map function or a list comprehension,
because both these work with a single list.

- But here we're combining multiple lists.
To achieve this we use the built in zip function.
So zip function takes multiple iterables, and it will combine them.
-------------------code----------------------
list1 = [1, 2, 3]
list2 = [10, 20, 30]

print(zip(list1, list2))
# <zip object at 0x10063fc40>
-------------------code----------------------

- it returns a zip object which is also iterable.
So we can iterate over it or simply pass it to the built in list function
to convert it to a list.
-------------------code----------------------
list1 = [1, 2, 3]
list2 = [10, 20, 30]

print(list(zip(list1, list2)))
# [(1, 10), (2, 20), (3, 30)]
-------------------code----------------------


- As we saw, this zip function takes one or more iterables.
So we don't have to pass a list here. we can also pass a string like "abc",
we can see our string "abc" is spread across multiple tuples in this list.

-------------------code----------------------
list1 = [1, 2, 3]
list2 = [10, 20, 30]

print(list(zip("abc", list1, list2)))
# [('a', 1, 10), ('b', 2, 20), ('c', 3, 30)]
-------------------code----------------------

- That's pretty powerful. If we want to achieve the same thing in other programming languages,
we have to write several lines of code.
But in python we can do it in a single line.

*** 13- Stacks ***
- In programming, we have a common data structure called "stack", which resembles a
stack of items in the real world. Imagine we have a stack of books,
the last book that we put on top of the stack is the first
book that we can remove. We refer to this behavior as 
"LIFO": which is short for last in, first out.
So this is a stack data structure, and it's very common in real world applications.
A good example of that is our browser. Whenever we navigate to a new website, our browser keeps our
browsing session in a stack, so when we click the back button, it takes we to the previous website.

- how it works. So we start with an empty stack, now let's say
we navigate to website number 1, here for simplicity we're using a number, if we're building a browser, instead of a number we'll use
a string which is the address of the current website.
-------------------code----------------------
[1, 2, 3]
-------------------code----------------------

- now let's say we navigate to a couple more websites, and then click the
back button. At this point the browser removes the item
on top of the stack, and then it will redirect us to the
previous website.
-------------------code----------------------
[1, 2]
-------------------code----------------------
 
- Now let's say we press the back button a couple more times, so we'll end up with an empty stack, at this
point the browser will disable the back button. This is how a stack
works. Last in, first out.
-------------------code----------------------
[1]
-------------------code----------------------

- how to use a stack in python. Basically we can use a list object as a stack.
So here we're going to define a variable like browsing session, and set it to an empty list.
Now let's say the user navigates to website number 1, so
we call browsing session dot append method, and add the address of the current website.
-------------------code----------------------
browsing_session = []
browsing_session.append(1)
-------------------code----------------------

Now let's say the user navigates to website
number 2, and then 3, let's have a look at what we have in our stack.
So we print it, and as we see we have a list of three items.
-------------------code----------------------
browsing_session = []
browsing_session.append(1)
browsing_session.append(2)
browsing_session.append(3)
print(browsing_session)
# [1, 2, 3]
-------------------code----------------------
 
- Now when the user presses the back button, we should remove
the last item in this list.
How do we do it?
we use the pop method. it will remove the last item from the stack and return it.
-------------------code----------------------
last = browsing_session.pop()
print(last)
# 3
-------------------code----------------------

- we can see that, so three is removed from the stack.
Now if we print our stack one more time,
print browsing session, we can see three is removed and we have only two
items in our stack. 
-------------------code----------------------
print(browsing_session)
# [1, 2]
-------------------code----------------------

So we need to take the user to the previous website,
which is the item on top of the stack. And we can get that using
a negative one index.
-------------------code----------------------
print("redirect", browsing_session[-1])
# redirect 2
-------------------code----------------------

- So when the user presses the back button, we redirect
them to the previous website, which is website number two.

Now here we need to check if the stack is empty or not. If it becomes
empty, we need to disable the back button. Earlier in the course,
we talked about the falsy values, so number zero, an empty string, an empty list, these
are all falsy values.
-------------------code----------------------
# Falsy values
0
""
[]
-------------------code----------------------


- So if we apply the not operator to an empty list, we'll
get the boolean true.
-------------------code----------------------
not []
# True
-------------------code----------------------

- So to see if our stack is empty, we can simply write code
like this. If not browsing session, then at this point we will disable the back button.
-------------------code----------------------
if not browsing_session:
    print("disable the back Button")
-------------------code----------------------

- Recap, we use the append method to add an item on top
of the stack, we use pop to remove the item on top
of the stack, we use index negative one to get the item on
top of the stack, and of course before doing that, we need to check
to see if our stack is empty or not, because if it's empty,
when we run this code, we'll get an error.
So if not browsing session, then we'll get the item
on top of the stack. These are the operations
that we can perform on stacks.
-------------------code----------------------
# Operation on Stacks
browsing_session.append(1)
browsing_session.pop()
if not browsing_session:
    browsing_session[-1]
-------------------code----------------------

*** 14- Queues ***
- In the last lecture we're learned about stacks. we learned that stacks have the
LIFO behavior. Last in, first out. We have another very useful data structure called "queue", which has the
"FIFO" behavior. First in, first out. And it resembles
a queue in the real world. Let's say a queue of people to get into
a restaurant. The first person in the queue is the first person who would get in.


- Now technically we're can use a list to implement a queue in python. 
So let's say we have a queue of three items, if we're want to remove an item from this queue,
we should remove the one at the beginning.


- As opposed to the one at the end. So we remove one
and then two, and then three.
-------------------code----------------------
[1, 2, 3]
[2, 3]
[3]
-------------------code----------------------


- However, if we're're dealing with a large list or a large queue, we're might see some adverse
effect on the performance.
Because let's say we have a large number of items in this list. Every time we remove an item from the beginning
of this list, all the other items need to be shifted to the
left. So if we're have a list with a thousand and one items, when we're remove
one item, a thousand items need to be moved in memory.
-------------------code----------------------
[1, 2, 3, 4, 5, 6, 7, 8, 9]
[2, 2, 3, 4, 5, 6, 7, 8, 9]
-------------------code----------------------


- In situations like that, it's more efficient to use a dequeue object.
so first we need to import dequeue from the collections module.
we're going to talk about modules later in the course. For now, let's imagine
a module is a bucket with a bunch of reusable code.

- So from collections, that's the name of our module, we should
import dequeue, which is a class. Again, we're going to talk about
classes later in the course.
-------------------code----------------------
from collections import deque
-------------------code----------------------

So we import a deque class here. Now, instead of defining
a variable and setting it to an empty list, we should wrap this list
with a dequeue object.
So, we call dequeue and pass our empty list as an argument.
-------------------code----------------------
queue = deque([])
-------------------code----------------------

- This dequeue object has similar methods that we have
in the list object. So we can call queue.append multi times Now to remove an item
from the beginning of the queue, we call queue.popleft(), We don't have this method in list objects.

-------------------code----------------------
queue = deque([])
queue.append(1)
queue.append(2)
queue.append(3)
queue.popleft()

print(queue)
# deque([2, 3])
-------------------code----------------------

-  we can see one is removed and now we only have two and three.
Also, similar to lists, we can easily check to see if a queue
is empty using the not operator. So, if not
queue, that means we have an empty queue, then we can print something like empty.
So this is all about queues.
-------------------code----------------------
if not queue:
    print("'empty")
-------------------code----------------------

*** 15- Tuples ***

- Throughout the course We've mentioned tuples a few times, in this lecture we're going to take a closer look at them.
A tuple is basically a read only list.

- We can use it to contain a sequence of objects,
but we cannot modify this sequence, we cannot add a new object to it,
we cannot remove an existing object, and we cannot modify an existing object.

- So let's start by defining a tuple called point
instead of square brackets, we use parenthesis to define a tuple.
-------------------code----------------------
point = (1, 2)
print(type(point))
# <class 'tuple'>
-------------------code----------------------

- We can also exclude parenthesis, and python will see it as tuple.
-------------------code----------------------
point = 1, 2
print(type(point))
# <class 'tuple'>
-------------------code----------------------

- Now if we have one item, we should add a trailing comma,
otherwise python thinks we're defining an integer.
-------------------code----------------------
point = 1,
print(type(point))
# <class 'tuple'>

point = 1
print(type(point))
# <class 'int' >
-------------------code----------------------

- Also if we want to define an empty tuple, we should use empty parenthesis.
-------------------code----------------------
point = ()
print(type(point))
# <class 'tuple' >
-------------------code----------------------


- Now similar to lists, we can concatenate two tuples, so here we have one tuple,
we can concatenate it with another tuple.
-------------------code----------------------
point = (1, 2) + (3,  4)
print(point)
# (1, 2, 3, 4)
-------------------code----------------------


- We can also use the multiplication operator to repeat a tuple.
-------------------code----------------------
point = (1, 2) * 3
print(point)
# (1, 2, 1, 2, 1, 2)
-------------------code----------------------

- We can also convert a list to a tuple, so let's say we have a list of two numbers,
to convert this list to a tuple, we call the tuple function.
As we can see, tuple function takes an iterable, so we can pass any iterables here,
and this function will return a tuple.
-------------------code----------------------
point = tuple([1, 2])
print(point)
# (1, 2)
-------------------code----------------------

-  or we can pass a string, like hello world, and because strings are iterable,
now we get a tuple of 11 strings.
-------------------code----------------------
point = tuple("Hello World")
print(point)
# ('H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd')
-------------------code----------------------


- Similar to lists, we can access individual items using an index.
-------------------code----------------------
point = (1, 2, 3)
print(point[0])
# 1
-------------------code----------------------

- or we can get a range of items, like items from index 0 to index 2,
this returns another tuple with only those objects.
-------------------code----------------------
point = (1, 2, 3)
print(point[0:2])
# (1, 2)
-------------------code----------------------

- We can also unpack these tuples, so we can define three variables like x, y, and z,
and set it to point.
-------------------code----------------------
point = (1, 2, 3)
x, y, z = point
-------------------code----------------------

- Similar to lists, we can use the in operator to check for the existence of an item.
So if 10 is in point, then we print exists.
-------------------code----------------------
point = (1, 2, 3)
if 10 in point:
    print("exist")
-------------------code----------------------
- But as we said, these tuples are immutable, we cannot mutate them, we cannot change them.
So if we try to modify point of 0, and set it to a new number,
look, we immediately get this red underline,
and if we run the code, we get this type error. Tuple object does not support item assignment.
-------------------code----------------------
point = (1, 2, 3)
# point[0] = 10
# TypeError: 'tuple' object does not support item assignment
-------------------code----------------------

- For this very reason, unlike lists, we don't have methods to add a new object or remove an existing object.
So we might ask, where in the real world we use tuples?
Here's a basic rule of thumb. Let's say we're dealing with a sequence of objects,
and we want to make sure that we don't accidentally modify this sequence, we don't accidentally add a new object to it,
or remove an existing object.
So instead of a list, we can use a tuple to prevent these accidental errors.

*** 16- Swapping Variables ***


- we're going to define two variables, x
and y. A basic exercise we give to people who start in programming
is to write code to swap two variables.
-------------------code----------------------
x = 10
y = 11
-------------------code----------------------

- To swap two variables, we need a third variable. So we're going to define a third variable like z
and set it to x. So basically we're copying the value of x into a separate
variable as a backup.

- Now we can overwrite x with y. So
we set x to y, we copy the value of y to x. Now we have the old value of x stored in z. So we can use
that to overwrite y. We set y to z.
With these three lines, we can swap the
value of these two variables.
-------------------code----------------------
x = 10
y = 11


z = x
x = y
y = z

print("x: ", x)
print("y: ", y)
# x:  11
# y:  10
-------------------code----------------------


- we've got a good news good news for we. In python, we can swap the value
of two variables using only one line of code and without a third variable.
So instead of writing these three lines, we can simply write x, y equals y, x.
Now if we run this code, we get the exact same result.
-------------------code----------------------
x = 10
y = 11

x, y = y, x

print("x: ", x)
print("y: ", y)
# x:  11
# y:  10
-------------------code----------------------

- but let me explain what exactly happens under the hood.
on the right side of the assignment operator, we're defining a we're. Because in the last lecture
we told that when defining a we're, we can use
parenthesis, or we can exclude the parenthesis. So this code is exactly
equivalent to this.
-------------------code----------------------
x, y = y, x
# x, y = (11, 10)
-------------------code----------------------

- We have a we're, what is y? It's 11, what is x? It's 10.
Now what do we have is We have a we're that we're unpacking.
So we're setting x to 11, and y to 10. And that is why
with this line of code, we can easily swap two variables.

- For this very reason, we can define multiple variables on the same line. So we can define a and b
and set them to 1 and 2.
-------------------code----------------------
a, b = 1, 2
# unpacking the tuple = define the tuple
-------------------code----------------------

- Once again, we're defining a we're and then unpacking it on the left side.
So a will be 1 and b will be 2. 1 and b will be 2.

*** 17- Arrays ***
- So we have learned a lot about lists in Python, these lists are very useful, but if we're
dealing with a large sequence of numbers, we have a more efficient data type in Python
called "array".

- These arrays take less memory and perform a little bit faster, but note
that we will see the difference only if we're dealing with a large list of numbers, let's
say 10,000 or more. So for 90% of the cases, we will use lists, but if we run our
program and we see some performance problems, then we can see if we can solve the problem
by replacing a list with an array. If we don't have any performance problems, don't try
to optimize. In other words, don't solve a problem that doesn't exist.

- we how to use arrays in Python. To use an array, we need to import it from the array
module. So we have a module called array, and in this module, we have a class called array.
It has the same name as the module itself.
-------------------code----------------------
from array import array
-------------------code----------------------

- Now, we call array, look at the first parameter, this is called a type code, which is a string
that determines the type of objects in our array.

- So here in google, search for python3 type code.
-------------------code----------------------
python3 type code

# the official document 
https://docs.python.org/3/library/array.html
-------------------code----------------------

- what is python3 type code?
So it's a string of one character that determines the type of objects in our list. So if we're
dealing with signed integers, we should use a lowercase i.
and as a second argument, we pass a list of integers. So we move this list here. Now we get an array,
we can call it numbers.
-------------------code----------------------
from array import array

numbers = array("i", [1, 2, 3])
print(numbers)
# array('i', [1, 2, 3])
-------------------code----------------------

- In this object, similar to lists, we have methods for adding new objects,
or removing existing ones, so we can call numbers.append, to append a number to the end of the list.
-------------------code----------------------
numbers.append(4)
print(numbers)
# array('i', [1, 2, 3, 4])
-------------------code----------------------


- or we can use insert to add a number at a specific index. 
-------------------code----------------------
numbers.insert(1, 9)
print(numbers)
# array('i', [1, 9, 2, 3, 4])
-------------------code----------------------
- We also have pop and remove exactly like lists.
-------------------code----------------------
numbers.remove(9)
print(numbers)
# array('i', [1, 2, 3, 4])

numbers.pop()
print(numbers)
# array('i', [1, 2, 3])
-------------------code----------------------


- And we can also access items by their index. So we can get the first item in this array.
However, unlike lists, the objects in this array are typed. So here every object should be an integer.
If we try to put a floating point number here, or any other kind of objects, we'll get an error.
-------------------code----------------------
numbers[0] = 1.0
# TypeError: 'float' object cannot be interpreted as an integer
-------------------code----------------------

- So every object in this array should be of the same type, which is determined
at the time of creating the array using the type code.

- Recap, use arrays only if we're dealing with a large sequence of numbers,
and we encounter performance problems. For other cases, use lists and tuples by default.

*** 18- Sets ***
In Python we have another very useful data structure called a "set".

- which is basically a collection with no duplicates. So let's say we have a list of numbers, with a bunch of
duplicate items, If we want to remove the duplicates, we can convert this list to a set. So we're going to
define a variable uniques, we call the set function, and pass the numbers list.


PS: Also note that we use curly braces to define sets.
-------------------code----------------------
numbers = [1, 1, 2, 3, 4]
uniques = set(numbers)
print(uniques)
# {1, 2, 3, 4}
-------------------code----------------------

- again we define a second set using curly braces with two items, one to four. 
-------------------code----------------------
second = {1, 2, 3, 4}
-------------------code----------------------

- Now similar to lists, we can add new items to a set, or remove an existing one, so here
we can call add method, we can append a new number.
-------------------code----------------------
second.add(5)
print(second)
# {1, 2, 3, 4, 5}
-------------------code----------------------

- we can also call remove, and we can use the len function to get the number of items in a set.
-------------------code----------------------
second.remove(5)
print(second)
# {1, 2, 3, 4}

print(len(second))
# 4
-------------------code----------------------


- But where sets shine are in the powerful mathematical
operations that are supported by them.

- for example we can get a union of two sets using the vertical bar,
so this expression will return a new set that includes all the items that are either in the first or
in the second set. 
-------------------code----------------------
numbers = [1, 1, 2, 3, 4]
first = set(numbers)
second = {1, 5}

print(first | second)
# {1, 2, 3, 4, 5}
-------------------code----------------------

- we can also get the intersection of two sets, so print, first, and second.
This will return a new set that includes all the items that are in both first
and second sets.
-------------------code----------------------
print(first & second)
# {1}
-------------------code----------------------


- We can also get the difference between two sets, when we run this code,
we get two, three, four. So the first set has this additional numbers that we don't have in the second set.
-------------------code----------------------
print(first - second)
# {2, 3, 4}
-------------------code----------------------

- And finally we have symmetric difference, and This will return the items that are either in the
first or second sets, but not both.
-------------------code----------------------
print(first ^ second)
# {2, 3, 4, 5}
-------------------code----------------------

- Now one thing we need to know about sets is that unlike lists,
there are unordered collection. Which means the items that we have in a set
are not in sequence, so we cannot access them using an index.
In other words, if we try to print first of zero, we will get a runtime error.
-------------------code----------------------
print(first[0])
# TypeError: 'set' object is not subscriptable
-------------------code----------------------

- set object does not support indexing. So if we need to access items by an index,
we need to use a list. With sets, quite often we use one of these operations here.
-------------------code----------------------
numbers = [1, 1, 2, 3, 4]
first = set(numbers)
second = {1, 5}

print(first | second)
# {1, 2, 3, 4, 5}

print(first & second)
# {1}

print(first - second)
# {2, 3, 4}

print(first ^ second)
# {2, 3, 4, 5}
-------------------code----------------------

- or we can check for the existence of an item in a set.
-------------------code----------------------
if 1 in first:
    print("yes")
# yes
-------------------code----------------------

- So to recap, set is an unordered collection of unique items, we cannot have duplicates,
and these objects are unordered, they are not in sequence.
So we cannot access them using an index.

*** 19- Dictionaries ***
- In Python we have a very powerful data structure called "dictionary".

- that is basically a collection of key value pairs. We use it to
map a key to a value. A real world example of this is a phone book.
In a phone book, we map a person's name to their contact details.

- So we use a person's name as the key, and
their contact information as the value. So a phone book is a dictionary,
it's a collection of key value pairs. 


- how to work with dictionaries in python. So we're going to define a variable
point, we can set it to an empty dictionary, or we can add one or more key value pairs here.
-------------------code----------------------
point = {}

point = {"x": 1, "y": 2}
print(point)
# {'x': 1, 'y': 2}
-------------------code----------------------

-  In python we can only use immutable types for the keys, so quite often we use
strings and numbers. But the value can be of any type, there are no limitations.


- So here's one way to define a dictionary,
we can also use the dict function, just like we have the list, tuple, and set functions, we also have
the dict functions that we can use to create a dictionary.
-------------------code----------------------
list()
tuple()
set()
dict()

point = dict(x=1, y=2)
print(point)
# {'x': 1, 'y': 2}
-------------------code----------------------


- Now we personally prefer the second approach, because we don't have
to deal with these quotes. we find this syntax a little bit cleaner and shorter.

- So now we have a dictionary, we can get the value associated
with a key using an index.
-------------------code----------------------
print(point["x"])
# 1
-------------------code----------------------

- Note that our index is the name of a key. So because
dictionaries are collections of key value pairs, we cannot access an item
using a numeric index as we do with lists.
-------------------code----------------------
print(point[0])
# KeyError: 0
-------------------code----------------------

- We can add a new key. So let's set z
to 20. And then print the point. So now we have 3 key value pairs.
-------------------code----------------------
point["z"] = 20
print(point)
# {'x': 1, 'y': 2, 'z': 20}
-------------------code----------------------


- if we use an invalid key, we'll get an error. So let's look up the value of the item with the key a.
-------------------code----------------------
print(point["a"])
# KeyError: 'a'
-------------------code----------------------

- There are two workarounds here. One solution is to check for the existence of a key.
-------------------code----------------------
if "a" in point:
    print(point["a"])
-------------------code----------------------
- The other solution is to use the get method.
So instead of using brackets and the name of the key, we call the get method.
and we pass the name of the key. if the key doesn't exist, by default
it returns none.
-------------------code----------------------
print(point.get("a"))
# None
-------------------code----------------------


- or we can pass a default value as a second argument.
So we say, hey, if we don't have an item with the key a, return 0 by default.
-------------------code----------------------
print(point.get("a", 0))
# 0
-------------------code----------------------

- To delete an item, we use the del or delete statement.
-------------------code----------------------
del point["x"]
print(point)
# {'y': 2, 'z': 20}
-------------------code----------------------

-  how to loop over dictionaries. So if we write a simple
for statement for x in point, let's see what we get.
-------------------code----------------------
for x in point:
    print(x)
# y
# z
-------------------code----------------------

-  So in each iteration, our loop variable will hold the key of an item.
So it's better to rename this to key.
Now, we can print the key, as well as the value associated with the key.
-------------------code----------------------
for key in point:
    print(key, point[key])
# y 2
# z 20
-------------------code----------------------


- There is another way to iterate over a dictionary, so here
we can call point.items Now, let me rename key to x and just print x. 
-------------------code----------------------
for x in point.items():
    print(x)
# ('y', 2)
# ('z', 20)
-------------------code----------------------


- So in each iteration, we get a tuples. In this we're, we have the key and the value. So,
we can unpack it right here.
-------------------code----------------------
for key, value in point.items():
    print(key, value)
# y 2
# z 20
-------------------code----------------------


*** 20- Dictionary Comprehensions ***
we have this piece of code here. On the top we're defining an empty list, then we're iterating over
this range object, in each iteration we get x,
multiply it by 2 and add it to our list.
-------------------code----------------------
values = []
for x in range(5):
    values.append(x * 2)

print(values)
# [0, 2, 4, 6, 8]
-------------------code----------------------

- As we told before, whenever we have this pattern in your code, we can either use the
map function or preferably a list comprehension.
what is our expression?
We're multiplying x by 2.
-------------------code----------------------
[expression for item in items]

[x * 2 for x in range(5)]
-------------------code----------------------

- This line of code is exactly identical to these three lines.
-------------------code----------------------
values = []
for x in range(5):
    values.append(x * 2)

values = [x * 2 for x in range(5)]
-------------------code----------------------

- PS when using list comprehension we use the extend method instead of append method
what is extend method 
The extend method in Python is used to add elements from an iterable 
(like a list, tuple, or set) to the end of a list. Unlike the append method,
which adds its argument as a single element to the end of the list,
extend takes each element from the iterable and adds them individually to the list.
-------------------code----------------------
list1 = [1, 2, 3]
list2 = [4, 5, 6]

list1.extend(list2)
print(list1)
# [1, 2, 3, 4, 5, 6]
-------------------code----------------------

-when using append with list comprehension
-------------------code----------------------
values = []
values = [x * 2 for x in range(5)]
values.append(values)
print(values)
# [0, 2, 4, 6, 8, []]
-------------------code----------------------

- when we use extend 
-------------------code----------------------
values = []
values = [x * 2 for x in range(5)]
values.extend(values)
print(values)
# [0, 2, 4, 6, 8]
-------------------code----------------------

- why when we using append we get a empty list inside our list.
-------------------code----------------------
values = []  # This is an empty list
values = [x * 2 for x in range(5)]  # This creates a list [0, 2, 4, 6, 8]
# This appends the empty list values to original values which is empty array
values.append(values)
print(values)  # The output is [0, 2, 4, 6, 8, []]
-------------------code----------------------

- also use them with sets and dictionaries. So now, if we replace these square brackets
with curly braces, we get a set.
-------------------code----------------------
values = {x * 2 for x in range(5)}
print(values)
# {0, 2, 4, 6, 8}
-------------------code----------------------


- Now, what is the syntactical difference between a set and a dictionary?
Well, for both these data structures, we use curly braces.
curly braces. In sets, we just have values, but in dictionaries, we have key value
pairs that are separated using a colon. So, here we can map one to a character, two
to another character, and so on.
-------------------code----------------------
{1, 2, 3, 4}  # sets
{1: "a", 2: "b"}  # dictionaries
-------------------code----------------------

- So, we can easily use comprehension expressions to create dictionary
objects. such that we have a key value pair.
So, here we can use x as the key and x times two as the value.
-------------------code----------------------
values = {x: x * 2 for x in range(5)}
print(values)
# {0: 0, 1: 2, 2: 4, 3: 6, 4: 8}
-------------------code----------------------

- So, instead of defining an empty dictionary, then looping over
an iterable and then in each iteration adding something to this dictionary like values of x
equals x times two whenever we have this pattern in your code, we can use
a dictionary comprehension.
-------------------code----------------------
values = {}
for x in range(5):
    values[x] = x * 2
print(values)
# {0: 0, 1: 2, 2: 4, 3: 6, 4: 8}
-------------------code----------------------

- to Recap, we can use comprehensions with lists,
sets, and dictionaries. But what about topples?
-------------------code----------------------
values = (x * 2 for x in range(5))
print(values)
# <generator object <genexpr> at 0x10461ea80>
-------------------code----------------------

- we don't get a topple what's going on here?
We get a generator object and that's the topic for the next lecture.
