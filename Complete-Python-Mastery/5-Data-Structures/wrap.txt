*** 1- Lists ***
- In this section, we're going to look at the built-in data structures in python,
which are extremely important when building real applications.

First, we're going to look at lists, and then we'll look at tuples, sets, and dictionaries.
So earlier we have seen that we can use square brackets
to define a list or a sequence of objects.
-------------------code----------------------
["a", "b", "c"]
-------------------code----------------------


- In between these brackets we can have objects of any type, so we can have a list
of strings ,and then assign it to a variable like letters.
-------------------code----------------------
letters = ["a", "b", "c"]
-------------------code----------------------


- We can also have a list of numbers, booleans.
-------------------code----------------------
numbers = [1, 2, 3, 4]
-------------------code----------------------

- or even we can have a list of lists.
So here we have a list, each item in this list
will be a list itself. So here's the first item, which is
a list of two items. Now let's add another item
to our main or parent list. This item is also a list
a list with two items. 
So now we have a matrix, which is a two dimensional list.
-------------------code----------------------
matrix = [[1, 2], [3, 4]]
-------------------code----------------------

- we have some cool tricks. Let's
say we want to have a list of a hundred
zeros. we don't want to manually
create that like this, that's very ugly.
-------------------code----------------------
[0, 0, 0, 0, 0, 0 ....]
-------------------code----------------------


- instead we can define a list of one item,
one zero, and then we can multiply it by a hundred.
And the result will be this. 
-------------------code----------------------
zeros = [0] * 100
print(zeros)
=> [0, 0, 0, 0, 0, 0, 0, 0,,,,]
-------------------code----------------------

- So using a star or an asterisk, we can repeat
the items in a list.


- Now similarly, we can use a plus to
concatenate multiple lists.
-------------------code----------------------
letter1 = ["a", "b", "c"]
zeros1 = [0] * 5
combined = zeros1 + letter1
=> [0, 0, 0, 0, 0, 'a', 'b', 'c']
-------------------code----------------------

PS: in python, every object in a list can be of a different type.
So they don't have to be exactly the same type.
We can combine a list of numbers with strings and booleans or even
lists.

- Now let's say we want to have a list of numbers
like 0, 1, 2, 3, all the way up to 20. we don't want to type all of these by hand.
There is a better way. So we have this list function. As we can see, this function
takes an iterable. So we can pass any iterable as argument and convert it to a list.
Earlier we learned about the range function. This function returns
a range object which is iterable. Which means we can iterate or loop over it. So here we can
call this function and pass 20 and with this we can create a list of numbers from 0 to 20.
-------------------code----------------------
numbers = list(range(20))
print(numbers)
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
-------------------code----------------------

- As another example, let's call the list function and pass a string.
Earlier we said that strings are also iterable.
so, We can loop over them. So we can pass them to the list function.
-------------------code----------------------
char = list("Hello World")
print(char)
=> ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']
-------------------code----------------------

- we can get the number of items in that list using the len function.
So here we can print the len or length of chars.

-------------------code----------------------
print(len(char))
=> 11
-------------------code----------------------

*** 2- Accessing Items ***
- here we have a list of four items, we can use square brackets to access individual items
in this list.
-------------------code----------------------
letters = ["a", "b", "c", "d"]
-------------------code----------------------


- print letters of 0, this will return the first item in this list.
-------------------code----------------------
letters = ["a", "b", "c", "d"]
print(letters[0])
=> "a"
-------------------code----------------------

Now similar to strings, if we pass a negative index,it will return the first item from the end of the list. 
-------------------code----------------------
letters = ["a", "b", "c", "d"]
print(letters[-1])
=> "d"
-------------------code----------------------


- we can also modify items in the list, so let's change the first item to a capital "A".
-------------------code----------------------
letters2 = ["a", "b", "c", "d"]
letters2[0] = "A"
print(letters2)
=> ["A", "b", "c", "d"]
-------------------code----------------------

- Now earlier in the course, we learned that we can use two indexes to slice a string. 
we have the exact same concept in the list.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[0:3])
=> ['A', 'b', 'c']
-------------------code----------------------


- PS: using slice operator will return a new list with the first three items
in our original list. So if we print our original list, we can see that it's not changed. 
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[0:3])
=> ['A', 'b', 'c']

print(letters3)
=> ["A", "b", "c", "d"]
-------------------code----------------------

- just like strings, if we don't specify the first argument, zero will be assumed by default.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[:3])
=> ['A', 'b', 'c']
-------------------code----------------------

- So as we can see, these two expressions produce the exact same result.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[0:3])
=> ['A', 'b', 'c']

print(letters3[:3])
=> ['A', 'b', 'c']
-------------------code----------------------

- Similarly, if we don't include the end index, by default, the length of the list
will be used.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[0:])
=> ["A", "b", "c", "d"]
-------------------code----------------------


- And similarly, we can also exclude the start index here. And with this syntax, we can get a copy of our original list.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]

print(letters3[:])
=> ["A", "b", "c", "d"]
-------------------code----------------------

- Now when slicing a string, we can also pass a "step", and this is useful in situations
where we want to return every second or every third element in the original list.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[::2])
=> ['A', 'c']
-------------------code----------------------

- another example, Create a new list called numbers, and call the range function.
-------------------code----------------------
numbers = list(range(10))
print(numbers)
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
-------------------code----------------------

- using "step" to get all the even numbers
-------------------code----------------------
numbers = list(range(10))
print(numbers[::2])
# [0, 2, 4, 6, 8]
-------------------code----------------------

- to reverse a list we can use step with  -1.
-------------------code----------------------
numbers = list(range(10))
print(numbers[::-1])
=> [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
-------------------code----------------------

*** 3- List Unpacking ***
There are times that we may want to get individual items in a list and assign them
to different variables.
-------------------code----------------------
numbers = [1, 2, 3]
first = numbers[0]
second = numbers[1]
third = numbers[2]
-------------------code----------------------

- Now there is a cleaner and more elegant way to achieve the same result, 
and that is what we call list "unpacking".
So we can unpack this list into multiple variables.
-------------------code----------------------
first, second, third = numbers
-------------------code----------------------

- What we have on now  is exactly identical to what we have when assign the variable manually.
This is what we call list unpacking.

- Now what is important here is that the number of variables that we have on the left side
of the assignment operator should be equal to the number of items we have in the list.
So if we exclude third here, and run this program, we will get an error.
So there are too many items in this list, and we cannot unpack it into enough variables.
-------------------code----------------------
first, second = numbers
# ValueError: too many values to unpack (expected 2)
-------------------code----------------------

- Now what if in this list we have so many items, but we only care about the first two.
We don't want to define so many variables on the left side of the assignment operator.
-------------------code----------------------
numbers2 = [1, 2, 3, 4, 4, 2, 1]
first, second, *other = numbers2
-------------------code----------------------


- With this syntax, we'll get the first and second items and everything else will be stored in
a separate list called other.
-------------------code----------------------
numbers2 = [1, 2, 3, 4, 4, 2, 1]
first, second, *other = numbers2
print(first, second)
# 1 2
print(other)
# [3, 4, 4, 2, 1]
-------------------code----------------------


- So in this example, we have both unpacking and packing.
First we try to unpack first and second list into the variables on the left side of the
assignment operator, and then because we have used an asterisk here, we're basically packing
all the other items into a separate list.
-------------------code----------------------
first, second, *other = numbers2
-------------------code----------------------

Now to refresh our memory, earlier we used this syntax when
defining a function with a variable number of arguments. We had a function like this, where 
we set the parameter with an asterisk, with that python would get all these arbitrary arguments, and pack them
into a tuple.
-------------------code----------------------
def multiple(*args):
    return args


print(multiple(1, 2, 3, 4, 5))
# (1, 2, 3, 4, 5)
-------------------code----------------------

- What if we care only about the first and the last item?
Well, we can put other in between, so we get the first, other,
and then the last item.
-------------------code----------------------
numbers3 = [1, 2, 3, 4, 4, 2, 9]
first, *other, last = numbers3
print(first, last)
# 1 9
print(other)
# [2, 3, 4, 4, 2]
-------------------code----------------------

*** 4- Looping over Lists *** 
-  how to loop over lists. So here we have a list of three items, we can use our for loops to loop over
this list.
-------------------code----------------------
letters = ["a", "b", "c"]
for letter in letters:
    print(letter)
# a
# b
# c
-------------------code----------------------

- what if we want to get the index of each item as well?
Well, we have a built in function called enumerate,
we call it here, and this will return an enumerate object, which is iterable.
In each iteration this enumerate object will give us a tuple.
-------------------code----------------------
letters = ["a", "b", "c"]
for letter in enumerate(letters):
    print(letter)
# (0, 'a')
# (1, 'b')
# (2, 'c')
-------------------code----------------------

- a tuple as we told before is like a list but it's read only, we cannot add new items to it.
So in each iteration we're getting a tuple of two items the first item in this tuple is the index, and the second
item is the item at that index. So now to get the index, we can use square brackets.
-------------------code----------------------
letters = ["a", "b", "c"]
for letter in enumerate(letters):
    print(letter[0], letter[1])
# 0 a
# 1 b
# 2 c
-------------------code----------------------

- But this syntax is a little bit ugly. In the last lecture we learned about list unpacking.
So if we have a list with two items we can unpack it into two variables index and letter equals items.
-------------------code----------------------
items = [0, "a"]
index, letter = items
-------------------code----------------------

- So here we are unpacking the items list. Now what if we change square brackets
to parentheses?
Now we have a tuple and we can still unpack this tuple.
-------------------code----------------------
items = (0, "a")
index, letter = items
-------------------code----------------------


- So we saw that this enumerate function returns an enumerate
object which is iterable. In each iteration, this
enumerate object will return a tuple So we can unpack it immediately.
-------------------code----------------------
for index, letter in enumerate(letters):
    print(index, letter)
# 0 a
# 1 b
# 2 c
-------------------code----------------------

- So to recap we can use for loops to iterate over lists. If we also need the index
we should call the enumerate function this will return an enumerate
object which is iterable in each iteration it will return a tuple and we can unpack that tuple.

*** 5- Adding or Removing Items ***
- how to add new items to a list or remove existing items. So for adding items we have two options
depending on where we want to add this new item.

- If we want to add an item at the end of the list, we should use the append method.
-------------------code----------------------
letters = ["a", "b", "c"]

letters.append("d")
print(letters)
# ['a', 'b', 'c', 'd']
-------------------code----------------------

PS: So, earlier we learned that everything in python is an object, so we can use the dot notation to access individual
functions or more accurately methods in that object. So when a function is part of an object, we refer to that function as a method.
So here are all the methods available on list objects.

-  Now if we want to add an item at a specific position, we should use the insert method. So letters that insert, we can add
something at the beginning of the list.
-------------------code----------------------
letters.insert(0, "-")
print(letters)
# ['-', 'a', 'b', 'c', 'd']
-------------------code----------------------

- Now for removing objects, again we have a few different options, if we want to remove
the item at the end of the list, we should use the pop method.
-------------------code----------------------
letters = ["a", "b", "c"]
letters.pop()
print(letters)
# ['-', 'a', 'b', 'c', 'd']
-------------------code----------------------

- we can also pass an index here, to remove the item at the given index. So,
if we pass 0, instead of D, this hyphen will be removed.
-------------------code----------------------
letters = ['-', 'a', 'b', 'c', 'd']
letters.pop(0)
print(letters)
# ['a', 'b', 'c', 'd']
-------------------code----------------------

- there are times that we want to remove an object, but we don't know its index.
If that's the case, we can use the remove method, so letters that remove, here we can remove "b",
and this will remove the first occurrence of the letter "b".
-------------------code----------------------
letters = ['-', 'a', 'b', 'c', 'd']
letters.remove("b")
print(letters)
# ['-', 'a', 'c', 'd']
-------------------code----------------------

PS: So if we have multiple "b"'s, only the first one will be removed. If we want to remove
all "b"'s in this list, we will have to loop over this list, and remove each "b" individually.

- We have another way to remove an item from a list, and that is using the del or delete statement.
So here we can delete an item by its index,
-------------------code----------------------
letters = ['-', 'a', 'b', 'c', 'd']
del letters[0]
print(letters)
# ['a', 'b', 'c', 'd']
-------------------code----------------------

- we can also delete a range of items. So this is the difference between the delete statement
and the pop method. 
The pop method will remove only one item by index, whereas with the delete statement, we can remove a range
of items.
-------------------code----------------------
letters = ['-', 'a', 'b', 'c', 'd']
del letters[0:3]
print(letters)
# ['c', 'd']
-------------------code----------------------

- finally if we want to remove all the objects in the list, we should use the clear method.
-------------------code----------------------
letters = ['-', 'a', 'b', 'c', 'd']
letters.clear()
print(letters)
# []
-------------------code----------------------

*** 6- Finding Items ***
- There are times that we want to find the index of a given object in a list.
So, let's say we want to find the index of letter "a" in our letters list.
 
-  What if we try to get the index of an object that doesn't exist here, like "d".
We get a value error, "d" is not in the list. This behavior is different from a lot of programming
languages out there, C based languages return negative 1, if we try to get the index of an object that doesn't exist in the list.
But in python, we get an error.
-------------------code----------------------
letters = ["a", "b", "c"]
print(letters.index("d"))
# ValueError: 'd' is not in list
-------------------code----------------------

- So, to prevent this error from happening, first we should check to see if the given object exists
in the list. And for that we use the in operator, so if D is in letters, then we will
print its index.now we run the program and we don't get any errors.
-------------------code----------------------
letters = ["a", "b", "c"]
if "d" in letters:
    print(letters.index("d"))
# 
-------------------code----------------------
 
- another method that we might find useful in certain situations, and that is
count. So letters dot count, this will return the number of occurrences of the given item in this list.
-------------------code----------------------
letters = ["a", "b", "c"]
print(letters.count("d"))
# 0
-------------------code----------------------

*** 7- Sorting Lists ***
Here we have this list with a bunch of numbers that are not in any particular order.
To sort this list we call sort method.
-------------------code----------------------
numbers = [3, 51, 2, 8, 6]
numbers.sort()
print(numbers)
# [2, 3, 6, 8, 51]
-------------------code----------------------

-  What if we want to sort these items in descending order?
Well, this sort method takes two parameters
key which we'll look at later, and reverse which we can use
to change the sort order.
-------------------code----------------------
numbers = [3, 51, 2, 8, 6]
numbers.sort(reverse=True)
print(numbers)
# [51, 8, 6, 3, 2]
-------------------code----------------------

- However, in addition to the sort method, we have a built-in function called sorted.
as we can see this function takes an iterable, so we can pass any
iterables here and it will sort it for us.
-------------------code----------------------
numbers = [3, 51, 2, 8, 6]
print(sorted(numbers))
# [2, 3, 6, 8, 51]
-------------------code----------------------

- PS: unlike the sort method, this will not modify the original list, it will return a
new sorted list. 



- Also similar to the sort method, if we want to change the sort
order, we can simply set the reverse argument to true.
-------------------code----------------------
numbers = [3, 51, 2, 8, 6]
print(sorted(numbers, reverse=True))
# [51, 8, 6, 3, 2]
-------------------code----------------------

- sorting numbers and strings is pretty easy, but what if we're dealing with a list of complex
objects? For example, what if we have a list of tuples?

-  Let's imagine we are building an application
for processing orders, and we have this list of order items. Every item in this list
is a tuple with two items. The product name, followed by the price.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]
-------------------code----------------------

- What happens if we try to sort this list? Let's take a look, so items.sort, 
and then we print the items, so nothing is changed here, because python doesn't know how
to sort this list.

-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]

items. sort()
print(items)
# [('Product1', 10), ('Product2', 9), ('Product3', 12)]
-------------------code----------------------

- In situations like this, we need to define a function that python will use for sorting lists.
So, here we're going to define a function, let's call it sort underline item,
this function should take an item like this tuple, and it should return a value that will be used for sorting.
In this example, let's imagine we want to sort these items based on their price.
So, if each item is a tuple, we can get the price using square brackets of 1. 
So all this function does is that it takes an item
and it returns its price.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]


def sort_item(item):
    return item[1]
-------------------code----------------------


- Now python is dealing with a list of numbers, and it can easily sort that list. Now finally
we need to pass this function when sorting our list of items.

- So once again, we look at this sort method, the first parameter is key, and this is where we need to pass our sorting function.
So we pass sort underline item.

PS: we're not calling this function, I'm simply passing a reference to this function.
When python attempts to sort this list, the list of items, it gets each item, and it will pass each item
to our sort function.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]


def sort_item(item):
    return item[1]


items. sort(sort_item)
print(items)
# TypeError: sort() takes no positional arguments
-------------------code----------------------


- So, let's run this program and see what happens. We get a type error.
Sort takes no positional arguments, which basically means
here we can only use keyword arguments. So we need to specify our argument that is key, we set it to
sort item.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]


def sort_item(item):
    return item[1]


items. sort(key=sort_item)
print(items)
# [('Product2', 9), ('Product1', 10), ('Product3', 12)]
-------------------code----------------------

*** 8- Lambda Functions ***
- If we have any experience with other programming languages, we've probably heard of the term lambda expression or
lambda function.

- It's basically a simple one line anonymous function that we can pass to other functions.
So here on in our code, we're passing a reference to our sort underline item function,
we can improve this code and make it cleaner by using a lambda expression or an anonymous function.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]


def sort_item(item):
    return item[1]


items. sort(key=sort_item)
print(items)
# [('Product2', 9), ('Product1', 10), ('Product3', 12)]
-------------------code----------------------

- So we don't have to define this function first and then pass it here. So, we remove this
and add lambda, with this we're telling python that we're defining a lambda or anonymous function.

- The syntax for writing a lambda function is like this. We add parameters
-------------------code----------------------
lambda parameters: expression
-------------------code----------------------

- So using this syntax, we can rewrite this function. by replace the parameters keyword with item 
and pass instead of the expression what we return in the sort_item function which is item[1].
-------------------code----------------------
# lambda parameters: expression
items. sort(key=lambda item: item[1])
-------------------code----------------------

- Now we can see with this syntax, we don't need to use
def for defining a function, we don't need to give our function a name, we don't need this parenthesis here,
and we don't need the return statement.
So this is a shorter and cleaner way to define a function that we're going to use only once
as an argument to another function.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]


items. sort(key=lambda item: item[1])
print(items)
# [('Product2', 9), ('Product1', 10), ('Product3', 12)]
-------------------code----------------------

*** 9- Map Function ***
- So here we have this list of items, let's imagine we want to transform this list
into a different shape, so currently each item in this list is a topple of two items, let's say we're only interested in the
price of these items, so we want to transform this list into a list of numbers, that is the list of prices.
Here is a basic way
- We can define an empty list
- then iterate over our list of items
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]

prices = []

for item in items:
    prices.append(item[1])

print(prices)
# [10, 9, 12]
-------------------code----------------------



- Now there is a better and more elegant way to achieve the same result.
Instead of this loop, we can use the map function. So
we call the built in map function, as we can see this function takes
two parameters, a function and one or more iterables.
So as the first argument we can pass a lambda function and as the second argument we can
pass our list of items.
-------------------code----------------------
x = map(lambda item: item[1], items)
print(x)

# <map object at 0x104f8b160>
-------------------code----------------------

- This map function will apply our lambda function on each item in this list.
and this map function returns a map object which is another iterable.
-------------------code----------------------
x = map(lambda item: item[1], items)
for item in x:
    print(item)

# 10
# 9
# 12
-------------------code----------------------

-  Alternatively, we can convert this map object into a list object.
So, we can use our list function earlier we learned that we can pass any iterables
to this list function to create a new list.
-------------------code----------------------
x = list(map(lambda item: item[1], items))
print(x)
# [10, 9, 12]
-------------------code----------------------


- now we can rename x to prices and simply print prices.
-------------------code----------------------
prices = list(map(lambda item: item[1], items))
print(prices)
# [10, 9, 12]
-------------------code----------------------


- how the map function works?
It takes a lambda function and applies it on every item of this iterable.


*** 10- Filter Function ***
- Here's another scenario for using a lambda function. So we have our list
of items, let's say we want to filter this list and only get
the items with price greater than or equal to $10.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]
-------------------code----------------------

- Again, one basic way is to define an empty list, like filtered,
then we iterate over our list of items for each item we get the price, if it matches our criteria
we'll add it to this list.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]


filtered = []
for item in items:
    if item[1] >= 10:
        filtered.append(item)

print(filtered)
# [('Product1', 10), ('Product3', 12)]
-------------------code----------------------


- but that's pretty basic, a better approach is to use the built in filter function.
we Look at the parameters, this function just like the map function takes
two parameters, a function and an iterable.

- we're going to pass a lambda function, this function takes an item
and returns a boolean value that determines if this item
matches a criteria or not.

- In this case, we want to get the price of each item and see if it's greater than
or equal to $10. So the result of this expression is a boolean value, if it's
true, this item will be returned. and as a second argument to the filter function, we pass
our items list.

- 
-------------------code----------------------
x = filter(lambda item: item[1] >= 10, items)
print(x)
# <filter object at 0x10317b1c0>
-------------------code----------------------

- we get a filter object. A filter object just like a map object is iterable, so we can
loop over it, and we can also convert it to a list right away.
-------------------code----------------------
x = list(filter(lambda item: item[1] >= 10, items))
print(x)
# [('Product1', 10), ('Product3', 12)]
-------------------code----------------------

*** 11- List Comprehensions ***
- So here's the usage of map and filter functions that we just learned about.
These two functions are pretty useful in python, and they're often used by
developers who come from a functional programming background. So the
concept of mapping and filtering lists is very natural to them.
-------------------code----------------------
items = [
    ("Product1", 10),
    ("Product2", 9),
    ("Product3", 12),
]

prices = list(map(lambda item: item[1], items))
print(prices)
# [10, 9, 12]

filtered = list(filter(lambda item: item[1] >= 10, items))
print(filtered)
# [('Product1', 10), ('Product3', 12)]
-------------------code----------------------

- But in python we have another feature for achieving the same result
and as far as I know, we don't have this feature in other programming languages.
That is called "comprehension". Here's the basic syntax.

We add our square brackets for defining a list, and here we'll write a comprehension
expression like this. 
-------------------code----------------------
[expression for item in items]
-------------------code----------------------

- now if we want to get the price of each item, we can write an expression like this,
item of one. So this is what we call a list comprehension, and it produces the exact same
result as what we have on line7.  As we can see, this code is shorter
and cleaner, we don't have all these parentheses and colon, what we have on line 7
is a little bit ugly and noisy.
-------------------code----------------------
prices = list(map(lambda item: item[1], items))
print(prices)
# [10, 9, 12]

prices = [item[1] for item in items]
print(prices)
# [10, 9, 12]
-------------------code----------------------

- Now, some developers might disagree, but generally speaking, in the Python
community, the preferred way to map and filter lists
is to use list comprehensions.

- But we included the map and filter functions in this course because as we look at the code
written by others, we'll probably come across instances of using the map and filter functions.
So I wanted to make sure that we really understand how they work. But as a best
practice, my recommendation to we is to use list comprehensions because they're cleaner and also more performant.

- we can also filter items. So, if I want to rewrite
what we have on line 10, using a list comprehension, that will look like this.
-------------------code----------------------
[expression for item in items if statement]
-------------------code----------------------

- we set it to square brackets, so we're defining a new list,
no need to call the list function. In between the brackets, we'll write an expression.
-------------------code----------------------
filtered = list(filter(lambda item: item[1] >= 10, items))
print(filtered)
# [('Product1', 10), ('Product3', 12)]


filtered = [item for item in items if item[1] >= 10]
print(filtered)
# [('Product1', 10), ('Product3', 12)]
-------------------code----------------------
