*** 1- Lists ***
- In this section, we're going to look at the built-in data structures in python,
which are extremely important when building real applications.

First, we're going to look at lists, and then we'll look at tuples, sets, and dictionaries.
So earlier you have seen that we can use square brackets
to define a list or a sequence of objects.
-------------------code----------------------
["a", "b", "c"]
-------------------code----------------------


- In between these brackets we can have objects of any type, so we can have a list
of strings ,and then assign it to a variable like letters.
-------------------code----------------------
letters = ["a", "b", "c"]
-------------------code----------------------


- We can also have a list of numbers, booleans.
-------------------code----------------------
numbers = [1, 2, 3, 4]
-------------------code----------------------

- or even we can have a list of lists.
So here we have a list, each item in this list
will be a list itself. So here's the first item, which is
a list of two items. Now let's add another item
to our main or parent list. This item is also a list
a list with two items. 
So now we have a matrix, which is a two dimensional list.
-------------------code----------------------
matrix = [[1, 2], [3, 4]]
-------------------code----------------------

- we have some cool tricks. Let's
say we want to have a list of a hundred
zeros. we don't want to manually
create that like this, that's very ugly.
-------------------code----------------------
[0, 0, 0, 0, 0, 0 ....]
-------------------code----------------------


- instead we can define a list of one item,
one zero, and then we can multiply it by a hundred.
And the result will be this. 
-------------------code----------------------
zeros = [0] * 100
print(zeros)
=> [0, 0, 0, 0, 0, 0, 0, 0,,,,]
-------------------code----------------------

- So using a star or an asterisk, we can repeat
the items in a list.


- Now similarly, we can use a plus to
concatenate multiple lists.
-------------------code----------------------
letter1 = ["a", "b", "c"]
zeros1 = [0] * 5
combined = zeros1 + letter1
=> [0, 0, 0, 0, 0, 'a', 'b', 'c']
-------------------code----------------------

PS: in python, every object in a list can be of a different type.
So they don't have to be exactly the same type.
We can combine a list of numbers with strings and booleans or even
lists.

- Now let's say you want to have a list of numbers
like 0, 1, 2, 3, all the way up to 20. we don't want to type all of these by hand.
There is a better way. So we have this list function. As we can see, this function
takes an iterable. So we can pass any iterable as argument and convert it to a list.
Earlier we learned about the range function. This function returns
a range object which is iterable. Which means we can iterate or loop over it. So here we can
call this function and pass 20 and with this we can create a list of numbers from 0 to 20.
-------------------code----------------------
numbers = list(range(20))
print(numbers)
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
-------------------code----------------------

- As another example, let's call the list function and pass a string.
Earlier we said you that strings are also iterable.
so, We can loop over them. So we can pass them to the list function.
-------------------code----------------------
char = list("Hello World")
print(char)
=> ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']
-------------------code----------------------

- we can get the number of items in that list using the len function.
So here we can print the len or length of chars.

-------------------code----------------------
print(len(char))
=> 11
-------------------code----------------------

*** 2- Accessing Items ***
- here we have a list of four items, we can use square brackets to access individual items
in this list.
-------------------code----------------------
letters = ["a", "b", "c", "d"]
-------------------code----------------------


- print letters of 0, this will return the first item in this list.
-------------------code----------------------
letters = ["a", "b", "c", "d"]
print(letters[0])
=> "a"
-------------------code----------------------

Now similar to strings, if we pass a negative index,it will return the first item from the end of the list. 
-------------------code----------------------
letters = ["a", "b", "c", "d"]
print(letters[-1])
=> "d"
-------------------code----------------------


- we can also modify items in the list, so let's change the first item to a capital "A".
-------------------code----------------------
letters2 = ["a", "b", "c", "d"]
letters2[0] = "A"
print(letters2)
=> ["A", "b", "c", "d"]
-------------------code----------------------

- Now earlier in the course, we learned that we can use two indexes to slice a string. 
we have the exact same concept in the list.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[0:3])
=> ['A', 'b', 'c']
-------------------code----------------------


- PS: using slice operator will return a new list with the first three items
in our original list. So if we print our original list, we can see that it's not changed. 
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[0:3])
=> ['A', 'b', 'c']

print(letters3)
=> ["A", "b", "c", "d"]
-------------------code----------------------

- just like strings, if we don't specify the first argument, zero will be assumed by default.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[:3])
=> ['A', 'b', 'c']
-------------------code----------------------

- So as we can see, these two expressions produce the exact same result.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[0:3])
=> ['A', 'b', 'c']

print(letters3[:3])
=> ['A', 'b', 'c']
-------------------code----------------------

- Similarly, if we don't include the end index, by default, the length of the list
will be used.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[0:])
=> ["A", "b", "c", "d"]
-------------------code----------------------


- And similarly, we can also exclude the start index here. And with this syntax, we can get a copy of our original list.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]

print(letters3[:])
=> ["A", "b", "c", "d"]
-------------------code----------------------

- Now when slicing a string, we can also pass a "step", and this is useful in situations
where we want to return every second or every third element in the original list.
-------------------code----------------------
letters3 = ["A", "b", "c", "d"]
print(letters3[::2])
=> ['A', 'c']
-------------------code----------------------

- another example, Create a new list called numbers, and call the range function.
-------------------code----------------------
numbers = list(range(10))
print(numbers)
=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
-------------------code----------------------

- using "step" to get all the even numbers
-------------------code----------------------
numbers = list(range(10))
print(numbers[::2])
# [0, 2, 4, 6, 8]
-------------------code----------------------

- to reverse a list we can use step with  -1.
-------------------code----------------------
numbers = list(range(10))
print(numbers[::-1])
=> [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
-------------------code----------------------

*** 3- List Unpacking ***
There are times that we may want to get individual items in a list and assign them
to different variables.
-------------------code----------------------
numbers = [1, 2, 3]
first = numbers[0]
second = numbers[1]
third = numbers[2]
-------------------code----------------------

- Now there is a cleaner and more elegant way to achieve the same result, 
and that is what we call list "unpacking".
So we can unpack this list into multiple variables.
-------------------code----------------------
first, second, third = numbers
-------------------code----------------------

- What we have on now  is exactly identical to what we have when assign the variable manually.
This is what we call list unpacking.

- Now what is important here is that the number of variables that we have on the left side
of the assignment operator should be equal to the number of items we have in the list.
So if we exclude third here, and run this program, we will get an error.
So there are too many items in this list, and we cannot unpack it into enough variables.
-------------------code----------------------
first, second = numbers
# ValueError: too many values to unpack (expected 2)
-------------------code----------------------

- Now what if in this list we have so many items, but we only care about the first two.
We don't want to define so many variables on the left side of the assignment operator.
-------------------code----------------------
numbers2 = [1, 2, 3, 4, 4, 2, 1]
first, second, *other = numbers2
-------------------code----------------------


- With this syntax, we'll get the first and second items and everything else will be stored in
a separate list called other.
-------------------code----------------------
numbers2 = [1, 2, 3, 4, 4, 2, 1]
first, second, *other = numbers2
print(first, second)
# 1 2
print(other)
# [3, 4, 4, 2, 1]
-------------------code----------------------


- So in this example, we have both unpacking and packing.
First we try to unpack first and second list into the variables on the left side of the
assignment operator, and then because we have used an asterisk here, we're basically packing
all the other items into a separate list.
-------------------code----------------------
first, second, *other = numbers2
-------------------code----------------------

Now to refresh our memory, earlier we used this syntax when
defining a function with a variable number of arguments. We had a function like this, where 
we set the parameter with an asterisk, with that python would get all these arbitrary arguments, and pack them
into a tuple.
-------------------code----------------------
def multiple(*args):
    return args


print(multiple(1, 2, 3, 4, 5))
# (1, 2, 3, 4, 5)
-------------------code----------------------

- What if we care only about the first and the last item?
Well, we can put other in between, so we get the first, other,
and then the last item.
-------------------code----------------------
numbers3 = [1, 2, 3, 4, 4, 2, 9]
first, *other, last = numbers3
print(first, last)
# 1 9
print(other)
# [2, 3, 4, 4, 2]
-------------------code----------------------

