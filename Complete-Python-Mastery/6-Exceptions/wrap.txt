*** 1- Exceptions ***
- When writing programs, many things can go wrong. Our programs may encounter an error and terminate. 
Usually these errors happen because of programmer's mistakes, or bad data
that we get from the user, or resources not being available. For
example, we might need to open a file, but if that file doesn't exist, our program
is going to crash. It's our job as a programmer to prevent
our application from crashing in this kind of situations. Instead
we want to display a proper error message to the user, like hey, this file doesn't exist.


- other examples. we're going to define a list of numbers with two items, and then print
the third item. 
-------------------code----------------------
numbers = [1, 2]
print(numbers[3])

# Traceback (most recent call last):
#   File "app1.py", line 2, in <module>
#     print(numbers[3])
#           ~~~~~~~^^^
# IndexError: list index out of range
-------------------code----------------------

- When we run this program we get this error, index error, this
happened in this file, app1.py, on line 2
and here's the statement that generated this error. In programming
we refer to this kind of error as an "exception". An exception is a kind of
error that terminates the execution of a program.


- More specifically we say this line, this statement, through an exception.
And this is an example of an exception that was thrown because of the
programmer's mistake.

- another example. Earlier
we learned about the input function to get input from the user. Let's say we ask
for the user's age, we know that this function returns a string
so we need to convert it to an integer and then store it
here.
-------------------code----------------------
age = int(input("Age: "))
-------------------code----------------------


 Now, instead of running this using the coderunner
let's go to the terminal and run python or 
-------------------code----------------------
python3 app.py
-------------------code----------------------

- The reason we didn't run this using code runner
is that by default code runner runs our programs in the output window which is read only, so we cannot enter data.
-------------------code----------------------
Age: a
Traceback (most recent call last):
  File "app1.py", line 10, in <module>
    age = int(input("Age: "))
ValueError: invalid literal for int() with base 10: 'a'
-------------------code----------------------

- if we enter a non-numeric value like "a", our program crashes.
In this example we got an exception of type
value error. So, as  we  told before it's our job as a programmer to handle
these exceptions and prevent our application
from crashing.


*** 2- Handling Exceptions ***
how to handle exceptions in our programs.

- So, continuing with the code from the last lecture, to handle the value error
exception here, we need to put the statement in a try block. So, we add try with colon,
we indent it, and then after try we need to add an
except clause. 
-------------------code----------------------
try:
    age = int(input("Age: "))
except 
-------------------code----------------------

- What is the type of the exception that we get
if the user enters a non-numeric value, that's a value
error exception, we saw that in the last lecture, right? So,
we add the accept clause, and then we'll print
a friendly error message.
-------------------code----------------------
try:
    age = int(input("Age: "))
except ValueError:
    print("You didn't enter a valid age")

# Age: 10
# Age: a
# You didn't enter a valid age
-------------------code----------------------

- When python sees a try block, it will execute every
statement in this block, if any of these statements throws an exception,
the code in the accept clause will be executed.
If we don't have any exceptions, this code will not be executed.
and our application didn't crash.

- This is the important thing about handling exceptions. If we don't handle
exceptions properly, our program
will crash. So, in other words,
if we add another statement here, let's print
execution continues.
In this example, because we are handling this
exception properly, this statement will be executed.
-------------------code----------------------
try:
    age = int(input("Age: "))
except ValueError:
    print("You didn't enter a valid age")
print("Execution continue")

# Age: a
# You didn't enter a valid age
# Execution continue
-------------------code----------------------

- In contrast, in the last lecture where
we didn't have the try block, if we put this print statement
after getting users age, this line would not be executed.


- We also have an optional else clause here, so else
colon, and what we put inside this block will be executed if no exception is thrown
in the code that we add in the try block.
So let's print a message like no exceptions were thrown.
and what we have in the else clause will only be executed
if we don't have any exceptions.
-------------------code----------------------
try:
    age = int(input("Age: "))
except ValueError:
    print("You didn't enter a valid age")
else:
    print("No exception were thrown")
print("Execution continue")

# Age: 10
# No exception were thrown
# Execution continue

# Age: a
# You didn't enter a valid age
# Execution continue
-------------------code----------------------

- This is very similar to our for else loops. Remember for else?
Earlier when we talked about for else loops, we told we that
the else clause is executed if we don't break out of the for loop. 
In other words, if the completes, then the else clause is executed. So here's a
basic structure for handling exceptions.


- when handling the exception, we can optionally
define a variable that will include the details about the exception.
Mostly the error message, and sometimes additional arguments.
we can add "as" keyword, and then define a variable,
like "ex" shortcut for exception. 
and we can print the actual error message that is
included in the exception or even print the type of that error.
-------------------code----------------------
try:
    age = int(input("Age: "))
except ValueError as ex:
    print("You didn't enter a valid age")
    print(ex)
    print(type(ex))
else:
    print("No exception were thrown")
print("Execution continue")

# Age: a
# You didn't enter a valid age
# invalid literal for int() with base 10: 'a'
# <class 'ValueError'>
# Execution continue
-------------------code----------------------

*** 3- Handling Different Exceptions ***
- let's define x_factor that take the input of the age and divide it on 10.
and let's try to input 0.

- What happened? Our program crashed again, we got
a different kind of exception that is a 0 division error.
Because in programming we cannot divide a number by 0.
-------------------code----------------------
try:
    age = int(input("Age: "))
    x_factor = 10 / age
except ValueError:
    print("You didn't enter a valid age")
else:
    print("No exception were thrown")
print("Execution continue")

# Age: 0
# Traceback(most recent call last):
#     File "app3.py", line 3, in <module >
#     x_factor = 10 / age
#     ~~~ ^ ~~~~
# ZeroDivisionError: division by zero
-------------------code----------------------

- So, the statement on line 3 "except ValueError"
threw an exception, but we don't have a matching except clause for that kind of exception. 
In other words, in this code we're only handling value error exceptions.
And that is why our program crashed

- So, to solve this problem,
we can come back here and add a second except clause, and specify a different kind of exception.
In this case, 0 division error. 
-------------------code----------------------
try:
    age = int(input("Age: "))
    x_factor = 10 / age
except ValueError:
    print("You didn't enter a valid age")
except ZeroDivisionError:
    print("Age cannot be 0")
else:
    print("No exception were thrown")
print("Execution continue")

# Age: 0
# Age cannot be 0
# Execution continue
-------------------code----------------------


- Now let's take this to the next level. Let's imagine
if the user enters 0 for the age, we want to print
the exact same error message. 
- So we're going to copy this and paste it like this. Now our code looks a little bit repetitive.
-------------------code----------------------
try:
    age = int(input("Age: "))
    x_factor = 10 / age
except ValueError:
    print("You didn't enter a valid age")
except ZeroDivisionError:
    print("You didn't enter a valid age")
else:
    print("No exception were thrown")
print("Execution continue")
-------------------code----------------------

- We have repeated this message, and that means if in the future
we want to change this message, we have to change it in two places.
There is a better way to handle this situation.

- In front of this except clause, we can specify multiple types of exception.
So if the exception that is thrown matches any of those exceptions, by separated them by comma.
then the code that we have in the except block will be executed.

-------------------code----------------------
try:
    age = int(input("Age: "))
    x_factor = 10 / age
except (ValueError, ZeroDivisionError):
    print("You didn't enter a valid age")
except ZeroDivisionError:
    print("You didn't enter a valid age")
else:
    print("No exception were thrown")
print("Execution continue")
-------------------code----------------------

- Now with this change, technically we don't need these two lines.
We can delete them. But temporarily we'm going to keep them
to show we something interesting. So back in the terminal,
let's run this one more time, and enter 0.
-------------------code----------------------
# Age: 0
# You didn't enter a valid age
# Execution continue
-------------------code----------------------

- Note that we get a single error on the terminal.
In other words, the code that we have
in this except block was not executed. Otherwise we would see this message twice.
So here's the lesson. When python executes
the code that we have in the try block, if any of the statements throws an exception
that matches one of the except clauses, that except clause is executed, and the other except clauses
are ignored.

- So, to clean up our code. 
-------------------code----------------------
try:
    age = int(input("Age: "))
    x_factor = 10 / age
except (ValueError, ZeroDivisionError):
    print("You didn't enter a valid age")
else:
    print("No exception were thrown")
print("Execution continue")

# Age: 0
# You didn't enter a valid age
# Execution continue
-------------------code----------------------

*** 4- Cleaning Up ***
- There are times that we need to work with external resources, like files,
network connections, databases, and so on. Whenever we use these
resources, after we're done, we need to release them.

- For example,
when we open a file, we should always close it after we're done, otherwise
another process or another program may not be able to open that file.

- So, let's take this example to the next level. Here
in our try block, first we'm going to open a file, so we call the open function, and let's open
appa.py. and returns a file object.
-------------------code----------------------
try:
    file = open("app1.py")
    age = int(input("Age: "))
    x_factor = 10 / age
except ValueError:
    print("You didn't enter a valid age")
else:
    print("No exception were thrown")
-------------------code----------------------

- Now when we're done, we should close this file
object. So this file object has a method
called close. 
-------------------code----------------------
try:
    file = open("app1.py")
    age = int(input("Age: "))
    x_factor = 10 / age
    file.close()
except ValueError:
    print("You didn't enter a valid age")
else:
    print("No exception were thrown")
-------------------code----------------------

- Now the problem with this code is that
this statement will not be executed in case of an exception.
In other words, if one of these two lines, throws an exception,
the control will be moved to our except clause, so file.close() code will not 
be executed
-------------------code----------------------
age = int(input("Age: "))
x_factor = 10 / age
-------------------code----------------------


- One solution is to move this down here, but again the problem
is that this will only be executed if we have an exception.
but If we don't have an exception, the control
will be moved to else statement, so our file will not be closed.
-------------------code----------------------
try:
    file = open("app1.py")
    age = int(input("Age: "))
    x_factor = 10 / age

except ValueError:
    print("You didn't enter a valid age")
    file.close()
else:
    print("No exception were thrown")
-------------------code----------------------
 
- So another solution is to duplicate the close file code.
but duplication is a bad
practice in programming. we should not repeat ourself in our code.
-------------------code----------------------
try:
    file = open("app1.py")
    age = int(input("Age: "))
    x_factor = 10 / age

except ValueError:
    print("You didn't enter a valid age")
    file.close()
else:
    print("No exception were thrown")
    file.close()

-------------------code----------------------
 
- So what is the solution? The solution is
to use the finally clause.  This final clause is always
executed, whether we have an exception or not. And we use it to release
external resources. So this is the perfect place to close
files, database connections,
network connections, and so on.
-------------------code----------------------
try:
    file = open("app1.py")
    age = int(input("Age: "))
    x_factor = 10 / age

except ValueError:
    print("You didn't enter a valid age")
else:
    print("No exception were thrown")
finally:
    file.close()
-------------------code----------------------
