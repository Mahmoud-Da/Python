*** 1- Classes ***

- In this section, we're going to look at classes which are extremely important in Python programming,
or in programming in general. 

- So let's start with an example.
we're going to define a list of numbers like this.
-------------------code----------------------
numbers = [1, 2]
-------------------code----------------------

- Now, we have learned that when we use the dot notation,
we get access to all these functions, or more accurately,
methods in list objects. 
- So every list object in Python has these methods.
-------------------code----------------------
numbers = [1, 2]
numbers.
-------------------code----------------------



- Now, wouldn't that be nice if we could create an object like shopping cart,
and this object would have methods like add, remove, get total, like this. 
-------------------code----------------------
shopping_cart.add()
shopping_cart.remove()
shopping_cart.get_total()
-------------------code----------------------

- Or as another example,
wouldn't that be nice if we could have a point object with methods like draw,
move, or get distance,
to get the distance between this point and another point.
-------------------code----------------------
point.draw()
point.move()
point.get_distance(1, 2)
-------------------code----------------------

- That's when classes come to the rescue.
So a class is a blueprint for creating new objects. Throughout the course, 
we have heard the term class.

- For example, let's define a variable and set it to an integer,
and then print its type.
When we run this program, what do we see here?
A class of int. So in Python,
we have a class called int for creating integers.
-------------------code----------------------
x = 1
print(type(x))

# <class 'int'>
-------------------code----------------------


- Similarly, we have classes for creating booleans, lists, dictionaries, and so on.
So every object that we have in Python is created using a class
which is a blueprint for creating objects of that type.

- In this section, we're going to learn how to create custom classes,
like customer, shopping cart, point, and so on.


- Now, before we get started, let's define a few terms.
Once again, a class is a blueprint for creating new objects.
An object is an instance of a class. As an example, we could have a class called human,
and this class would define all the attributes of humans.
Then we could create objects, like John, Mary, Jack, and so on.
-------------------code----------------------
# Class: blueprint for creating new objects
# Object: instance of a class

# Class: Human
# Objects: John, Mary, Jack, and ....
-------------------code----------------------

- So this is the difference between classes and objects.
Now a lot of people use these terms interchangeably,
but technically, a class and an object are different. 

*** 2- Creating Classes ***
- Alright, now let's see how we can create a point class in python.
So we start with the class keyword, then we give our class
a name, like point.
-------------------code----------------------
class Point
-------------------code----------------------

- Note that here we're using Pascal naming convention, which is different from the
naming convention that we use for naming our variables and functions.

- To name our variables and functions, we use all lowercase letters
and we separate multiple words using an underscore. But to name
our classes we use a different convention, which is called Pascal
naming convention. And basically it says that the first letter
of every word should be uppercase and we shouldn't use
an underscore to separate multiple words. Here's an example
we can call this class my point, we can see that the first letter
of every word is uppercase and there is no underscore here.
-------------------code----------------------
class MyPoint
-------------------code----------------------


- after this we add a colon to indicate a block
in this block we'll define all the functions related to points
for example we can define functions for drawing a point for moving this point to a new location
or getting the distance from this point and another point
we define a function called draw parenthesis
now all functions in our classes should have at least one parameter and by convention
we call that parameter "self"  Now we add our colon
and let's just print the word draw on the terminal
-------------------code----------------------
class Point:
    def draw(self):
        print("draw")
-------------------code----------------------

- so now we have a class or a blueprint for creating
point objects every point object that we create will have this draw method

- to create a point object we call this class like a function
there we go now this returns a point object
that we can assign to a variable like point so
if we use the dot operator we can see we have the draw method
as well as a bunch of other methods that we didn't define
but our point object got these methods from another object in python
through a mechanism called "inheritance" we'll look at that later in this section
-------------------code----------------------
point = Point()
point.  => to see the draw method
print(type(point))
# <class '__main__.Point'>
-------------------code----------------------


- we get a class of main dot point this main we see here
is the name of our "module" and we're going to look at that later in this section
so this is the type function that we have seen before we have another useful function
called "isinstance" sometimes we have an object and we want to know if this object
is an instance of a given class.
-------------------code----------------------
print(isinstance(point, Point))
# True
-------------------code----------------------

- however if we change this to int
obviously our point object is not an instance of the int class
so when we run this program we get false.
-------------------code----------------------
print(isinstance(point, int))
# False
-------------------code----------------------



- but our point objects need some initial values like x and y
to set these values we need a constructor.

*** 3- Constructors ***
So here when we create a point object, we want to supply initial
values for x and y coordinates, like this.
-------------------code----------------------
 class Point:
     def draw(self):
         print("draw")

point = Point(1, 2)
-------------------code----------------------

- To achieve this we need a constructor which is a special method that is called 
when we create a new point object.

- how to create a constructor.
So, in our point class, we define a new function the name of this function should be 
double underline init double underline "__init__".

- This is a special method that we call
a magic method. In python classes we have several
magic methods, and we're going to learn more about them throughout this section.


- So, this magic method is called a constructor, and it's executed
when we create a new point object. Now earlier we told  that
all the methods that we define in a class should have at least one parameter
which we call self by convention. So, we add self, and then
optionally we add any additional parameters for initializing a point object, like x
and y.
-------------------code----------------------
def __init__(self, x, y):
-------------------code----------------------

- Now, what is this self?
Self is a reference to the current point object.
For example, when we call the point class, python will internally create
a point object in memory and set self
to reference that point object.

Now, this point object has a bunch of methods that we have seen before
for example, when we use the dot operator we can see all the methods
in this point object.
-------------------code----------------------
point = Point(1, 2)
point.

=> __annotations__
=> __str__
-------------------code----------------------

- But an object can also have attributes
which are basically variables that include data about that object.
For example, we can have attributes like x and y that we can easily print
on the terminal.

- In other words, a class run object bundles data
and functions related to that data into one unit.
think of a human. A human can have attributes like eye color, height,
weight, and so on. As well as functions like walk, talk, and so on.

- So, back to our constructor.
we learned that self is a reference to the current object.
So we can use that to set the x and y attributes
like this.
-------------------code----------------------
def __init__(self, x, y):
  self.x
-------------------code----------------------

- We can set it to some default value like 0.
-------------------code----------------------
self.x = 0
-------------------code----------------------

- or this x argument that we receive in this method.
-------------------code----------------------
self.x = x
-------------------code----------------------

- Similarly, let's set self dot y to y.
-------------------code----------------------
def __init__(self, x, y):
        self.x = x
        self.y = y
-------------------code----------------------

- Now with this code, when we use the dot operator
look we have the draw method
as well as the two new attributes x and y.

- So, we can simply print
point dot x on terminal.
-------------------code----------------------
point = Point(1, 2)
print(point.x)
# 1
-------------------code----------------------


- Now, back to our draw method.
Here again we have this self parameter,
so using this we have a reference to the current point object, and with that we can
read the x and y values and print them on the terminal.

- So here we're going to change this
implementation, and pass a formatted string.
-------------------code----------------------
def draw(self):
    print(f"Point ({self.x}, {self.y})")
-------------------code----------------------

- So using self, we can read attributes of the current object,
or we can also call other methods in this object.

- Now, let's simply call point dot draw.
-------------------code----------------------
point = Point(1, 2)
point.draw()
# Point (1, 2)
-------------------code----------------------


- Now what is interesting here is that when calling the draw method
we didn't have to supply a value for the self parameter,
because python does that by default.
-------------------code----------------------
point.draw(point) 

point.draw()
-------------------code----------------------

- Now technically, we cana pass this point object as a reference
to the current object, but this is really unnecessary,
and it makes our code busy or noisy.


- So, here's what we need to take away.

1- The methods that we define in a class should have at least, one parameter
which by convention is called "self", and this references
the current point object that we're working with.

2- When calling methods of an object, we never have to supply a value
for this parameter, python interpreter does that for us.


*** 4- Class vs Instance Attributes ***

So in the last lecture we defined two attributes for our point
objects in the constructor of the point class.
-------------------code----------------------
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def draw(self):
        print(f"Point ({self.x}, {self.y})")


point = Point(1, 2)
-------------------code----------------------


- So now, whenever we create a new point object, this point object
will have these attributes by default. 

- We can also define an attribute after we create a point object, so here we can set
point.z to 10, because objects in python are dynamic, similar to java script.
-------------------code----------------------
point.z = 10
-------------------code----------------------
- So we don't have to define all the attributes in a constructor. We can define them later whenever we need them.

- Now here's what is important for we to understand. All these
attributes we have defined so far, x, y, and z,
these are instance attributes.

- In other words, these are attributes that belong to point instances or
point objects. So every point object can have different values
for these attributes. 

- Here's an example. We have one point object with these
values, we can create another point object
with different set of values.
-------------------code----------------------
another = Point(3, 4)
another.draw()
# Point (3, 4)
-------------------code----------------------

- When we run this, we can see we have two point objects
and these are completely independent independent of each other.
Each point has its own attributes, just like John
and Mary can have different eye colors.
-------------------code----------------------
point = Point(1, 2)
point.draw()
# Point (1, 2)

another = Point(3, 4)
another.draw()
# Point (3, 4)
-------------------code----------------------

- So these are instance attributes. But we can also
define class attributes, and these are attributes that we define
at the class level, and they are the same across
all instances of a class.


-  we can say all humans have two eyes and two ears,
so these are the attributes that we define at the class level,
and they are shared by all instances.

- So, back to our point example, we can define a class level attribute
in the body of this class.
-------------------code----------------------
class Point:
    default_color = "red"

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def draw(self):
        print(f"Point ({self.x}, {self.y})")
-------------------code----------------------


- So now we have a class level attribute, and we can
read this via a class reference or an object reference.


- We can use this object reference to get access to
the default color attribute, and then print it.
-------------------code----------------------
print(point.default_color)
# red
-------------------code----------------------

- But we can also use the point class to get access
to this attribute. 
-------------------code----------------------
print(Point.default_color)
# red
-------------------code----------------------


- Now as we told before, class attributes are shared across all
instances of a class.
-------------------code----------------------
print(point.default_color)
# red
print(another.default_color)
# red
print(Point.default_color)
# red
-------------------code----------------------

now if we change default_color  color to, let's say,
yellow. Note that we using a class reference "Point", so we not working with any point
objects, we working with the point class. Now,
when we run this program, we can see that the default color of
this point object is changed to yellow. 
-------------------code----------------------
Point.default_color = "Yellow"
print(point.default_color)
# Yellow
print(another.default_color)
# Yellow
print(Point.default_color)
# Yellow
-------------------code----------------------


- So, class level attributes are shared
across all instances of a class. If we change their value,
the change is visible to all objects of that type.

- Now, in practical terms, we will be using
instance attributes most of the time, but there are times
that we may want to define a class variable attribute that is shared
across all objects of a given type.

*** 5- Class vs Instance Methods ***
- In the last lecture we learned about instance versus class attributes. 
We have the same concept around the methods that we define
in a class. 

- So we have instance method as well as class methods.
In this example, both these methods that we have defined in the point class
are instance methods, so we can call them using an instance of the point class,
using an object.
-------------------code----------------------
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def draw(self):
        print(f"Point ({self.x}, {self.y})")
-------------------code----------------------

- Generally speaking, we use these instance methods whenever we need an object reference.
For example, when drawing a point, we really need to work with a specific point object.
That is why this draw method is defined as an instance method.

- But there are times that we don't really need an existing object, and that's when we use a class
method. For example, let's say in our program, there
are a lot of cases where we want to create a point with these initial
values. 0 and 0. This is one way to create a point object and that's perfectly fine, but we can
come up with a different way to create a point object with these values.
Like this.

- so note that we're using a class reference. In this
case, zero() is a method that is defined at the class level,
and when we call it, it will return a point object initialized with (0, 0).
-------------------code----------------------
point = Point(0, 0)
Point.zero()
-------------------code----------------------

-  So we can get this point object and assign it to this point variable.
-------------------code----------------------
point = Point.zero()
-------------------code----------------------

- Now in this example, we refer to this zero method as a factory
method. Because it's like a factory, it creates a new object.

- Now this example is pretty basic, creating a zero point
with these initial values is not a big deal.

- But there are times that initializing an object can be pretty complex.
So every time we want to create an object of a given type, we might
have to pass some magical values here, and we might have to repeat these in several places in our
program.
-------------------code----------------------
Point(0, 0, 1, "a")
-------------------code----------------------
 
- In that case, instead of passing all these magical
values to create an object, we can define a factory method that will return
an object with these values, and this way we can move this complexity
of creating this object into that factory method.



- how we can define a method at the class level.
So, back to our point class, we define
a method, call it zero, and call its first parameter
CLS, which is short for class. Again, this is
purely convention, we can call this anything, but by convention,
whenever we define a class method, we call its first parameter
CLS. And as we can guess, this is a reference to the class
itself, so here we are not working with a point object or a point
instance.
-------------------code----------------------
def zero(cls):
-------------------code----------------------

- Now, to make this method a class method, we need to decorate
it with something like "@classmethod" method. This is what we call a "decorator",
and it's a way to extend the behavior of a method or a function.

- We'll look at decorators and how they work internally later in this section.
So, this is all we have to do to create a class
method in python. Now, in this class method we have a reference to our class,
so with that we can create a point object with initial
values.
-------------------code----------------------
@classmethod
def zero(cls):
    return cls(0, 0)
-------------------code----------------------

- So we call CLS and give it these
initial values. This is exactly like calling Point.zero
and zero. The difference is that if we use CLS, at runtime when we call the zero method,
python interpreter will automatically pass a reference to the
point class to the zero method.
-------------------code----------------------
@classmethod
    def zero(cls):
        # same as Point(0, 0)
        return cls(0, 0)
-------------------code----------------------

- So, we create a zero_point object and then
return it. now we get a point with these initial values.
-------------------code----------------------
zero_point = Point.zero()
zero_point.draw()
# Point (0, 0)
-------------------code----------------------

*** 6- Magic Methods ***

- Throughout this course we've mentioned magic methods a few times. These are the
methods that have two underscores at the beginning and end of their name
and they're called automatically by python interpreter
depending on how we use our objects and classes.


- For example, here we
have this init magic method, we don't directly call it, it's called
automatically by python interpreter when we create
a new point object. 
-------------------code----------------------
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def draw(self):
        print(f"Point ({self.x}, {self.y})")


point = Point(1, 2)
-------------------code----------------------


- Now we have quite a few magic methods in python
over the next few lectures we're going to learn about the key ones. But if we want
to see the complete list, simply search for python 3 magic methods. 
-------------------code----------------------
python3 magic methods
-------------------code----------------------

- we a guide to python's magic methods. On this page we can see various magic methods in different categories with examples.
For example, look at the category of representing our classes.
-------------------code----------------------
https://rszalski.github.io/magicmethods/
-------------------code----------------------

- These are the magic methods that we have in this
category. The first one, "___str__", is a really useful one,
and this is called when we try to convert an object to a string.
-------------------code----------------------
__str__(self)
Defines behavior for when str() is called on an instance of our class.
-------------------code----------------------

- how it works. So back to our code, we have this point
object. If we print this on the terminal,
see what we get?
We get the name of our module, followed by the class name,
and the address of this point object in memory.
-------------------code----------------------
print(point)
# <__main__.Point object at 0x100656900>
-------------------code----------------------

- This is the default implementation of the stir magic method
in our point object.
So, if we type point. , we can see all magic methods that are available in our
point object, we didn't explicitly create these methods, our point object
inherited them from another object.
-------------------code----------------------
point.
-------------------code----------------------

- This is what we call "inheritance," and we're going to learn about that soon.

- Now in this list, we can see we have this __str__ method.
So by default, this returns the name of the class of this object
followed by its memory address. Now let's re-implement this method
to get a better result.

- let's define this str method,
underscore, str to underscore. Now just like before,
the first parameter should be self. Now here we should simply return a string representation
of this point object.
-------------------code----------------------
def __str__(self):
        return f"({self.x}, {self.y})"
-------------------code----------------------

- Now, this point object, this is what we get. This is very useful.
-------------------code----------------------
point = Point(1, 2)
print(point)
# (1, 2)
-------------------code----------------------

- We get the same result, if we also try to convert a point object to a string
using the stir function.
-------------------code----------------------
print(str(point))
# (1, 2)
-------------------code----------------------

- init and stir are examples of two useful magic methods
in python, over the next few lectures we're going to learn about
other useful magic methods.


*** 7- Comparing Objects ***
- There are times that we need to compare two objects.
For example, here we have this point object. If we define
another point object with the exact same values.
-------------------code----------------------
point = Point(1, 2)
other = Point(1, 2)

print(point == other)
# False
-------------------code----------------------

- We get false. What's going on here?
The reason we get false is that by default this equality
operator compares the references or addresses of these two objects in memory.

- In this case, these two variables are referencing
two different objects in memory and that's why they're not equal.

- To solve this problem, we need a magic
method. That magic method is called when we compare two objects. So back to this page.
Here we have comparison magic methods.

- in the previous lesson we check this site . we can look to methods we have for comparing two objects.

-------------------code----------------------
https://rszalski.github.io/magicmethods/
-------------------code----------------------

- For example, we have eq for testing equality
we also have ne which is short for not equal we have lt which is short for less than
greater than and so on.
-------------------code----------------------
__eq__(self, other)
Defines behavior for the equality operator, ==.
__ne__(self, other)
Defines behavior for the inequality operator, !=.
__lt__(self, other)
Defines behavior for the less-than operator, <.
__gt__(self, other)
Defines behavior for the greater-than operator, >.
__le__(self, other)
Defines behavior for the less-than-or-equal-to operator, <=.
__ge__(self, other)
Defines behavior for the greater-than-or-equal-to operator, >=.
-------------------code----------------------

- back to our point class, we need to define
eq magic method. on that page we can see that this method requires two parameters
self and other.
-------------------code----------------------
def __eq__(self, other):
-------------------code----------------------

- Now in this method we need to return true
if these two objects are equal, otherwise false.
So we can write an expression like this.
self.x equals other.x
and self.y equals other.y
so if this expression is evaluated to true
these two objects are considered equal.
-------------------code----------------------
def __gt__(self, other):
    return self.x > other.x and self.y > other.y
-------------------code----------------------        


- now we retest our comparison
-------------------code----------------------
point = Point(1, 2)
other = Point(1, 2)

print(point == other)
# True
-------------------code----------------------

- Now what if we want to compare these two point objects like this?
If point is greater than other.
-------------------code----------------------
print(point > other)
# TypeError: '>' not supported between instances of 'Point' and 'Point'
-------------------code----------------------

- we get a type error because the greater than operator is not supported
between instances of the point class.
So, to solve this problem we need to define another magic method
so define gt which is short for greater than once again we add two parameters
self and other
-------------------code----------------------
def __gt__(self, other):
    return self.x > other.x and self.y > other.y
-------------------code----------------------

- and we test our comparison.
-------------------code----------------------
point = Point(10, 20)
other = Point(1, 2)

print(point > other)
# True
-------------------code----------------------

-  what if we change this to less than
run the program we get false.
-------------------code----------------------
print(point < other)
# False
-------------------code----------------------
so as we see we don't have to explicitly implement each of these operators
when we implement the greater than magic method Python would automatically figure out
what to do if we use the less than operator

*** 8- Performing Arithmetic Operations ***
- We also have magic methods for performing arithmetic operations between two objects.
For example, what if we want to add these two points together?
When we run this program, obviously we're going to get an error.
-------------------code----------------------
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y




point = Point(1, 2)
other = Point(1, 2)

print(point + other)
# TypeError: unsupported operand type(s) for +: 'Point' and 'Point'
-------------------code----------------------

- So back in the list of magic methods (site), we have
numeric magic methods. In this category, if we scroll down
we can see normal arithmetic operators.

- So we have
add, subtract, multiply, and so on. So in order
to add two points together, we need to implement the add
method.
-------------------code----------------------
__add__(self, other)
Implements addition.

__sub__(self, other)
Implements subtraction.

__mul__(self, other)
Implements multiplication.

and so
-------------------code----------------------



- So define add
with two parameters, self and other, we simply return a new point object with these values.
-------------------code----------------------
def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
-------------------code----------------------


- we get this new point object
at this address, so we don't see the actual
x and y values of this point object, because in this example
we removed the stir magic method.
-------------------code----------------------
print(point + other)
# <__main__.Point object at 0x100bea520>
-------------------code----------------------

- However,
if we store the result of this arithmetic operation in another object,
like combine, and then print combine.x
we can see we get 11, which proves that we successfully added two points together.
-------------------code----------------------
point = Point(1, 2)
other = Point(1, 2)

combined = point + other
print(combined.x)
# 2
-------------------code----------------------

*** 9- Making Custom Containers ***
- Earlier in the course, we learned about the common data structures in python.
we learned about lists, sets, dictionaries, and so on.

- These data structures, or container types, are pretty useful
and sufficient for most cases.

- But there are times that we want to create our own
custom container types. For example, here we have this class
tag cloud, we're going to implement this from scratch.
-------------------code----------------------
class TagCloud:
-------------------code----------------------
- With this class, we can keep track of the number of various tags on
a blog. For example, how many articles do we have that are tagged with python
or javascript and so on. So, because this class represents
a container, it supports various operations around
containers.

- Here are a few examples. Let me create an
object, okay. Now, because this is a container,
we can get the number of items in this container, we can also
get an item by its key, for example, we can get
the number of articles tagged with python,
we can also set that, and finally we can iterate over this container, so
for tag in cloud, we can print each tag
and its count. These are the operations that are supported by this
custom container type.
-------------------code----------------------
cloud = TagCloud()
len(cloud)
cloud["python"] = 10
for tag in cloud:
    print(tag)
-------------------code----------------------


- how to implement a class like this. We create a class, call it tag cloud,
now internally we're going to use one or more
of the built-in data structures like lists, dictionaries, and so on.
In this case, we're going to use a dictionary because it allows us to quickly
get the number of given tag.

- So, first we define a constructor
self and in this constructor we initialize tags attribute to
an empty dictionary.
-------------------code----------------------
class TagCloud:
    def __init__(self):
        self.tags = {}
-------------------code----------------------

- Now we can optionally add a method like add
that takes a tag now here we should check to see
if we have this tag in our dictionary if we don't have it, we're going to set its
value to one, otherwise we're going to increment it by one.

- we use the get method to get an item
by this key, and supply a default value if we don't have that. Now we get the
count, increment it by one and finally we set the value
for this key. So, self the tags of
tag, we set it to this new value. 
-------------------code----------------------
def add(self, tag):
    self.tags[tag] = self.tags.get(tag, 0) + 1
-------------------code----------------------

*******************************************************************************
- The get method in Python dictionaries:
The get method in Python dictionaries is used to retrieve the value associated with a specified key.
It allows we to provide a default value that will be returned if the key does not exist in the dictionary. This is useful for avoiding errors that occur when trying to access a key that isn't present.

Syntax
-------------------code----------------------
value = dictionary.get(key, default_value)
-------------------code----------------------

Parameters
key: The key we want to look up in the dictionary.
default_value (optional): The value to return if the key is not found.
If not provided, it defaults to None.
-------------------code----------------------
my_dict = {'a': 1, 'b': 2}

value_a = my_dict.get('a')  
# Returns 1

value_b = my_dict.get('b')  
# Returns 2

value_c = my_dict.get('c', 0)
# Returns 0, since 'c' is not in the dictionary

value_d = my_dict.get('d')  
# Returns None, since 'd' is not in the dictionary
-------------------code----------------------
*******************************************************************************



- Let's test our program up to this
point. So, we're going to create a cloud
object and then call the add method a few times. 
-------------------code----------------------
cloud = TagCloud()

cloud.add("python")
cloud.add("python")
cloud.add("python")

print(cloud.tags)
# {'python': 3}
-------------------code----------------------


- Now we might be wondering why we created
a custom class instead of using a plain old dictionary.
The reason for this is because we want to make this a little bit smarter than a
typical dictionary. What if we add a python tag
with a capital P. Technically this is the same tag
as the lower case python. We get two separate items. This is how a typical
dictionary behaves.
-------------------code----------------------
cloud = TagCloud()

cloud.add("Python")
cloud.add("python")
cloud.add("python")

print(cloud.tags)
# {'Python': 1, 'python': 2}
-------------------code----------------------

- in this class we're going to take care of case sensitivity.
Whatever tag we receive here, we're going to convert it to
lower case when setting it as well as when reading it.
-------------------code----------------------
def add(self, tag):
    self.tags[tag.lower()] = self.tags.get(tag.lower(), 0) + 1
-------------------code----------------------

- Now save the changes, run the program one more time,
the problem is gone.

- So with this class, we're encapsulating the
complexity around the case sensitivity of tags.

- When using this class we no longer have to worry about
lower case or upper case characters.
-------------------code----------------------
cloud.add("Python")
cloud.add("python")
cloud.add("python")

print(cloud.tags)
# {'python': 3}
-------------------code----------------------

- Now let's take this to the next level.
we want to be able to read the count of a tag like this.
Using square brackets.
-------------------code----------------------
cloud["python"]
-------------------code----------------------

- To do this we need to implement a magic method called
get item.

- So, define get item it should take self as well as a key.
In this method we're going to return self.tags.get this tag, and if we don't
have it we want to return 0 by default, and once again we should
convert this to lower case.
-------------------code----------------------
def __getitem__(self, tag):
    return self.tags.get(tag.lower(), 0)
-------------------code----------------------

- As we can see with this implementation
we can easily get the number of a given tag. We can't do this
with a typical dictionary. If we don't have the python tag, our dictionary
would throw an error.
-------------------code----------------------
print(cloud["python"])
# 3
-------------------code----------------------
 
- Now let's take this to the next level. With the current implementation
we can only read the number of a given tag. We cannot
set it like this.
-------------------code----------------------
cloud["python"] = 10
-------------------code----------------------

- To do that we need to implement another magic method called set item.
It's pretty straightforward so, define
set item it takes three parameters self, key and value. In this case our
key is tag and our value is just count.
-------------------code----------------------
def __setitem__(self, tag, count):
    self.tags[tag.lower()] = count
-------------------code----------------------

-  with this implementation we can set the number of a given tag.
-------------------code----------------------
cloud["python"] = 10
print(cloud.tags)
# {'python': 10}
-------------------code----------------------

- Now in order to be able to get
the number of items in this tag cloud we should implement the len
magic method.
-------------------code----------------------
def __len__(self):
    return len(self.tags)
-------------------code----------------------        

- and finally to make this iterable so we can iterate over it using a for loop
we need to implement another magic method that is iter.
So define iter it takes self, now all we have to do is to use one of the built
in functions to get an iterator
object.


- An iterator object is an object that walks
a container and gets one item at a time. So we call
iter, which is one of the built in functions
what do we want to iterate over? In this case, self the tags.
-------------------code----------------------  
def __iter__(self):
    return iter(self.tags)
-------------------code----------------------  


- So this function returns an iterator
object which gives us one
item at a time in a for loop.
So we simply return it.
-------------------code----------------------  
for tag in cloud:
    print(tag)

# python
-------------------code----------------------  

*** 10- Private Members ***
- This class that we built in the last lecture has a tiny problem,
So here we have a cloud object, we're going to call cloud.add
pass python, repeat this a couple times, and then
change this to an uppercase p. Now if we print
cloud of python all in uppercase,
we get three, so our program is working,
-------------------code----------------------  
cloud = TagCloud()
cloud.add("python")
cloud.add("python")
cloud.add("Python")
print(cloud["PYTHON"])
# 3
-------------------code----------------------  

- however, if we access the underlined dictionary
in this class, our program is going to crash, let's take a look. So we got an
exception of type key error, because we don't have this key in our
dictionary, everything is stored as lowercase. So the problem
with this class is that it gives us access to the underlined dictionary
that is used to keep track of the count of tags.
-------------------code----------------------  
print(cloud.tags["PYTHON"])
# KeyError: 'PYTHON'
-------------------code----------------------  

- To fix this problem, we need to hide this attribute from the outside, so we cannot access
it. How do we do this?
So, back to our class. Put the cursor on this attribute, Now to
make this private, or inaccessible from the outside, we need to
prefix it with two underlines.
-------------------code----------------------  
class TagCloud:
    def __init__(self):
        self.__tags = {}

    def add(self, tag):
        self.__tags[tag.lower()] = self.__tags.get(tag.lower(), 0) + 1

    def __getitem__(self, tag):
        return self.__tags.get(tag.lower(), 0)

    def __setitem__(self, tag, count):
        self.__tags[tag.lower()] = count

    def __len__(self):
        return len(self.__tags)

    def __iter__(self):
        return iter(self.__tags)
-------------------code----------------------  

-  Now, back to where we use a tag cloud object.
If we use the dot operator, so cloud dot,
we no longer have tags here, we also don't have double underscore tags,
so if we print this, we get an exception of type attribute error,
tag cloud object doesn't have this attribute.
-------------------code----------------------  
print(cloud.__tags)
# AttributeError: 'TagCloud' object has no attribute 'tags'
-------------------code----------------------  

- So this is how we can make certain attributes, or certain
methods in the class private. If we prefix them with double underscores,
they're considered private.

- Having said that, technically, these members are still accessible from
the outside, it's just a little bit harder to access them. So the point of this
practice is not security, it's more of a warning or alert
to someone who is using this class.

- It's telling the consumer of this class,
don't touch this, this is private. 

- But how we can still access this.
Every class, or every object, has this property called "__dict__".
This is a dictionary that holds all the attributes in this class.
-------------------code----------------------  
print(cloud.__dict__)
# {'_TagCloud__tags': {'python': 3}}
-------------------code----------------------  


- So, in this class we have this attribute called "_TagCloud__tags".
So when python interpreter runs this code, it automatically renames
this attribute and prefixes it with the name of its class.

So technically we can still access it.
we're going to copy this name, and then show it in terminal
-------------------code----------------------  
print(cloud._TagCloud__tags)
# {'python': 3}
-------------------code----------------------  

- We get the values.
So, in python, unlike languages like C sharp or java, we don't really have the concept of private members.
These private members are still accessible from the outside.

- Using double underscores is more of a convention
to prevent accidental access to prevent accidental access of these private members.

*** 11- Properties ***

- There are times that we want to have control over an attribute in a class.
For example, here we have this product class, in the constructor
we set the price attribute.
-------------------code---------------------- 
class Product:

    def __init__(self, price):
        self.price = price
-------------------code---------------------- 


- With this implementation, we can create a product object, and give it a
negative price. And python interpreter will execute this
without any problems. 
-------------------code---------------------- 
class Product:

    def __init__(self, price):
        self.price = price

    def __str__(self):
        return f"{self.price}"


product = Product(-50)
print(product)
# -50
-------------------code---------------------- 


- This is not good. So how can we prevent
this? How can we ensure that our products don't have a negative price?
Here's one simple solution. We can make this field private, and then define two methods for getting and
setting the value of this attribute.
-------------------code---------------------- 
class Product1:

    def __init__(self, price):
        # self.__price = price

    def __str__(self):
        return f"{self.__price}"
-------------------code---------------------- 

- So, we define a method called get underline price,
here we simply return self.price.
-------------------code---------------------- 
def get_price(self):
    return self.__price
-------------------code---------------------- 

 and similarly we define
set underline price, that takes a value, now here first we check
if value is less than zero, we can raise
an exception of type value error, saying price
cannot be negative.Otherwise, we set self that price to this new value.
-------------------code---------------------- 
def set_price(self, value):
    if value < 0:
        raise ValueError("Price can't be negative")
    self.__price = value
-------------------code---------------------- 

- Now in another implementation, instead of raising this exception,
we could just ignore setting the value
if it's negative.
-------------------code---------------------- 
def set_price(self, value):
    if value < 0:
        value = -(value)
    self.__price = value
-------------------code---------------------- 

- but for this demo we will use the raise. Now with these two methods in place,
we go back to our constructor, instead of directly setting the price
attribute, we call self.setPrice and give it this
initial value. When we run this program, our data validation
logic is going to kick in, and it will throw an exception.
-------------------code---------------------- 
class Product1:
    def __init__(self, price):
        self.set_price(price)
-------------------code---------------------- 
 

-  we test our implementation until this point.
-------------------code---------------------- 
class Product1:

    def __init__(self, price):
        self.set_price(price)

    def __str__(self):
        return f"{self.__price}"

    def get_price(self):
        return self.__price

    def set_price(self, value):
        if value < 0:
            value = -(value)
        self.__price = value


product = Product1(-50)
print(product)

# raise ValueError("Price can't be negative")
# ValueError: Price can't be negative
-------------------code---------------------- 

- So this was a simple solution, but it's kind of ugly. It's what we
consider unpythonic.

- Pythonic is one of those expressions that
we hear a lot in the python community. When we say this code or this
implementation is not pythonic, that means it's not using python's
best practices. It's not using the python language features to the fullest potential. 
This implementation is the kind of code that a java programmer learning python writes.


- But in python, we have a better way to achieve the same result.
That's when we use a property. A property is an object that sits in front of an attribute, and
allows us to get or set the value
of that attribute.

- how to define a property here. So, in our product class,
after we define these two methods,
we define a class attribute
with the ideal name. In that case, we want to call that
price. Here we call the built-in property function. This function takes four parameters
and all these parameters are optional.


- The first parameter is a function for getting the value of an
attribute. The second parameter is a function for setting the value of that attribute. The third parameter
is a function for deleting that attribute.
And the last parameter is for documentation.

- In this case, we need to supply two arguments. The first one is going to be
get price, and the second is going to be set price.
-------------------code---------------------- 
class Product2:

    def __init__(self, price):
        self.set_price(price)

    def __str__(self):
        return f"{self.__price}"

    def get_price(self):
        return self.__price

    def set_price(self, value):
        if value < 0:
            raise ValueError("Price can't be negative")
        self.__price = value

    price = property(get_price, set_price)
-------------------code---------------------- 

- Note that we're not calling these methods, we're simply passing a
reference to them. So when we call the built-in property function,
with these arguments, this function will return a property object,
that property object will use this function for reading
the value of the price attribute.

- Now, by adding this line,
we can come back to our product. Let's set the initial price to
10. Here, when we use the dot operator, we can see we have
this price property and we can use it like a regular field. 
-------------------code---------------------- 
product = Product2(10)
print(product.price)
# 10
-------------------code---------------------- 

- and also we can set it but if we set it to a negative
value, this will throw an exception. Let's run our program, value error.
-------------------code---------------------- 
product = Product2(10)
product.price = -1
print(product.price)
# raise ValueError("Price can't be negative")
# ValueError: Price can't be negative
-------------------code---------------------- 

- So a property looks like a regular attribute from the outside,
but internally it has two methods that we call a getter and a setter.

- Now, while this price property solved our problem,
the two methods that we wrote are still accessible, so, if we type product dot,
we can see we have get price and set price methods.
-------------------code---------------------- 
product.get_price
product.set_price
-------------------code---------------------- 

-  These methods are polluting the interface of our object.
As a metaphor, think of a remote control with 50 buttons.
Nobody likes that kind of remote control, it's so confusing. It's much better to have
a remote control with few buttons that can do a lot. We want our
objects or our classes to be the same.
We want them to have minimal number of functions or methods exposed to the outside.


- So, to hide these, one solution, is to come
back, and make them private, but again
this adds extra noise in our code.
-------------------code---------------------- 
def __get_price(self):
-------------------code---------------------- 

- There is a better, shorter, and cleaner way to achieve the same result.
We can use a decorator.
PS: Earlier we used a decorator, called class method, to convert an
instance method to a class method.

- We have another decorator for creating a property.
So, instead of explicitly calling the property function
to create a property object, we can apply the property
decorator to this method, then, we rename this method to the ideal name.

- In this case we want to call it price.
When python interpreter sees this code, it will automatically create
a property object called price.
-------------------code---------------------- 
@property
    def price(self):
        return self.__price
-------------------code---------------------- 
 
- Now similarly, we need to apply another decorator
to this method. The name of that decorator starts with the name of our property, in this case
price, and then dot setter.
-------------------code---------------------- 
@price.setter
    def price(self, value):
        if value < 0:
            raise ValueError("Price can't be negative")
        self.__price = value
-------------------code---------------------- 

- Also, similarly we need to rename this method to price.
So our implementation is cleaner, it's less noisy, we don't have that get
underline and set underline, this is much better.
Now, how this works internally is a little bit complicated,
and we're going to look at that later in the future.

- For now, all we need to take away is that with these two decorators,
we can easily create a property.

- Now there is one more place that we need to
modify here, and that is our constructor, because we
no longer have set price, but the good thing is that we can use
our price property like a regular attribute. So we set
self.price to price.
-------------------code---------------------- 
def __init__(self, price):
    self.price = price
-------------------code---------------------- 

- With this new implementation, if we try to create a
product with a negative price, our code will throw an exception.
-------------------code---------------------- 
class Product3:

    def __init__(self, price):
        self.price = price

    def __str__(self):
        return f"{self.__price}"

    @property
    def price(self):
        return self.__price

    @price.setter
    def price(self, value):
        if value < 0:
            raise ValueError("Price can't be negative")
        self.__price = value


product = Product3(-10)
print(product.price)
# raise ValueError("Price can't be negative")
# ValueError: Price can't be negative
-------------------code---------------------- 

-  When defining properties, we don't always have to define a getter
and a setter.

-  In this case, if we comment out these few lines, we'll have a read
only property, so we can only read the value of this price.
-------------------code---------------------- 
class Product3:

    def __init__(self, price):
        self.price = price

    def __str__(self):
        return f"{self.__price}"

    # def __get_price(self):
    @property
    def price(self):
        return self.__price

    # @price.setter
    # def price(self, value):
    #     if value < 0:
    #         raise ValueError("Price can't be negative")
    #     self.__price = value

-------------------code---------------------- 



-  Once we set it, we cannot change it. So we can initially set it to, let's
say 10.
-------------------code---------------------- 
product = Product3(10)
print(product.price)
# 10
-------------------code---------------------- 


- but if we try to update it later, we'll get an exception.
So if we set product.price to 2, and run this program, we get an attribute error,
because we can't set that attribute. So this is all about
properties.
-------------------code---------------------- 
product = Product3(-10)
product.price = 2
print(product.price)
# AttributeError: property 'price' of 'Product3' object has no setter
-------------------code---------------------- 

*** 12- Inheritance  ***
- As we build various classes, we may notice that some of these classes might have
one or more features or functions in common.

- Here's an example. we're going to create a class called mammal.
All mammals should be able to eat, right? So let's define a function
called eat, and in this function we simply print eat. Now all mammals, as far as we know,
should be able to walk. So, let's define another method walk, and in this method we print walk.
-------------------code---------------------- 
class Mammal1:
    def eat(self):
        print("eat")

    def walk(self):
        print("walk")
-------------------code---------------------- 

- Now, we're going to duplicate this class.
Now, let's rename this second class fish. As we know, all fish should be
able to eat, but fish don't walk, they swim. So, let's change the second method to swim
as well as this message that we print.
-------------------code---------------------- 
class Fish1:
    def eat(self):
        print("eat")

    def swim(self):
        print("swim")
-------------------code---------------------- 

- Now, what is going on here?
As we can see, we have repeated or duplicated the eat method
in both these classes.

- Now in this implementation, our eat method is only a single line of code,
but in a real world program, we might have a method that is 5 or
10 lines of code, and we might have repeated that in multiple classes.
This is bad, because if there is a bug in one of these methods, we have to fix it
in multiple places.

- Or similarly, if we need to change the behavior of this
method, then again we have to do it in multiple places. In programming
we have this concept called "DRY", which stands for "don't repeat yourself".
 
- So, we don't want to repeat ourselves. To solve this problem,
we have two solutions. We can use inheritance or composition.

- In this lecture, we're going to look at inheritance, and we're going to
talk about composition later in this section.

- Inheritance is a mechanism that allows us to define the common behavior or common functions
in one class, and then inherit them in other classes.

- Here's how it works. So, we're going to define a separate class called animal,
and then move the eat method in this class.
-------------------code---------------------- 
class Animal2:
    def eat(self):
        print("eat")
-------------------code---------------------- 

- Now we can see our mammal class is simpler. So, to have it inherit
the eat method from the animal class, we simply add
parentheses, and then specify the animal class.
-------------------code---------------------- 
class Animal2:
    def eat(self):
        print("eat")


class Mammal2(Animal2):
    def walk(self):
        print("walk")


class Fish2(Animal2):
    def swim(self):
        print("swim")
-------------------code---------------------- 

- This is inheritance in action. We say the mammal class
is an animal, so it inherits all the features or all the methods
of the animal class.

- In this situation, we refer to the animal class, as the parent or base class,
and mammal as the child or sub class.

- We get rid of the eat method, and add animal as the base class.
Now, when we create a mammal object like m, we can see this
mammal has both the eat and walk methods.
-------------------code---------------------- 
m = Mammal2()
m.eat()
m.walk()
# eat
# walk
-------------------code---------------------- 

-  Now this inheritance is not limited to
methods, we can also inherit the attributes of a base class.
For example, back to our animal class, we're going to define a
constructor, and in this constructor, let's
set age to 1.
-------------------code---------------------- 
class Animal:
    def __init__(self):
        self.age = 1

    def eat(self):
        print("eat")
-------------------code---------------------- 

- Now, when we create a mammal object, our mammal object will automatically
have the age attribute initialized to 1.
-------------------code---------------------- 
m = Mammal()
print(m.age)
# 1
-------------------code---------------------- 


- Now, in real programs, we don't build animals or mammals or
fish, unless we're building a game. But we use this as an example,
because it's easier to understand the relationship between a mammal and
an animal. Later in this section, we're going to give we a real world example
of inheritance in our programs.


*** 13- The Object Class  ***
- So in the last lecture we defined this mammal object, we see
a couple of useful built in functions.

- We have this function is instance, and it tells us if an object is
an instance of a given class.

- So if we pass m and mammal here, obviously this m object is
an instance of mammal, so when we print the result we should see true.
-------------------code---------------------- 
class Animal:
    def __init__(self):
        self.age = 1

    def eat(self):
        print("eat")


class Mammal(Animal):
    def walk(self):
        print("walk")


class Fish(Animal):
    def swim(self):
        print("swim")


m = Mammal()
print(isinstance(m, Mammal))
# True
-------------------code---------------------- 

- What if we pass animal here? Let's run the program, we still get true.
Because mammal inherits from animal, so an instance
of the mammal class is also an animal.
-------------------code---------------------- 
print(isinstance(m, Animal))
# True
-------------------code---------------------- 

- Now This animal class that we defined here inherits from another class called object.
Even though we didn't add that here.
-------------------code---------------------- 
class Animal(object):
-------------------code---------------------- 

- So we have a class called object, and that is the base class for all
classes in python. So every class that we have, directly or indirectly derives from the object class.

- Let's see if m is an instance of object.
So mammal inherits from animal, which inherits from object.
-------------------code---------------------- 
print(isinstance(m, object))
# True
-------------------code---------------------- 

- We also have this built-in function for creating an empty object.
Now, if we inspect this object, we can see all these magic methods.
-------------------code---------------------- 
o = object()
o.
-------------------code---------------------- 

- These are the magic methods that every class in python has.
So if we type m dot, we can see our mammal class or our mammal object also has these methods.
Because it inherited them from the base object class.
-------------------code---------------------- 
m.
-------------------code---------------------- 

- We have another built-in function that we might find useful in certain situations.
And that is, is subclass. And with this we can see if a class derives from another class.
So let's see if mammal is a subclass of animal.
-------------------code---------------------- 
print(issubclass(Mammal, Animal))
# True
-------------------code---------------------- 

- Now if we change animal to object, we still get true,
because mammal indirectly derives or inherits from the object class.
-------------------code---------------------- 
print(issubclass(Animal, object))
# True
-------------------code---------------------- 

*** 14- Method Overriding ***
- In this example our animal class has this constructor where we initialize
the age attribute to 1.
-------------------code---------------------- 
class Animal1:
    def __init__(self):
        self.age = 1

    def eat(self):
        print("eat")

class Mammal1(Animal1):

    def walk(self):
        print("walk")
-------------------code---------------------- 

- What if we want to add a
constructor to the mammal class and initialize its weight.
-------------------code---------------------- 
class Animal1:
    def __init__(self):
        self.age = 1

    def eat(self):
        print("eat")


class Mammal1(Animal1):
    def __init__(self):
        self.wight = 2

    def walk(self):
        print("walk")
-------------------code---------------------- 

- now let's see the age and wight of the object of Mammal.
-------------------code---------------------- 
m = Mammal1()
# print(m.age)
AttributeError: 'Mammal' object has no attribute 'age'
print(m.wight)
# 2
-------------------code---------------------- 

- we got an attribute error, because mammal object has no attribute age.
The reason this happened was because this constructor in the animal class was not
executed. In other words, this constructor that we defined in the mammal class replaced
the constructor in the base class. This is what we call method
overriding.

- So we are overriding or replacing a
method in the base class. Now, what if we still want to execute
this constructor and initialize
the age of an animal? Here in the constructor of the mammal class, we can use the
built-in super function. to get access to the super or base class, which is in this case
animal.

- So we have an access to the animal class, dot now we can call any of the
methods in this class. So let's go ahead and call the
init method.
-------------------code---------------------- 
class Animal2:
    def __init__(self):
        self.age = 1

    def eat(self):
        print("eat")


class Mammal2(Animal2):
    def __init__(self):
        super().__init__()
        self.wight = 2

    def walk(self):
        print("walk")
-------------------code---------------------- 



-  Now to see the execution flow, we
are going to add a print statement here and print mammal constructor
Similarly, here in the constructor of the animal, we going to print
animal constructor.
-------------------code---------------------- 
class Animal2:
    def __init__(self):
        print("Animal Constructor")
        self.age = 1

    def eat(self):
        print("eat")


class Mammal2(Animal2):
    def __init__(self):
        super().__init__()
        print("Mammal Constructor")
        self.wight = 2

    def walk(self):
        print("walk")
-------------------code---------------------- 


- now we test our code first the constructor of the animal
was called, so here we set the age to 1, then
the constructor of the mammal was called, where we set the weight to 2, and finally we print
1 and 2, which are the results of these two statements.
-------------------code---------------------- 
m = Mammal2()
print(m.age)
print(m.wight)
# Animal Constructor
# Mammal Constructor
# 1
# 2
-------------------code---------------------- 

- Now we can also change the order of these method calls.
So we can call the constructor of the animal after we initialize a mammal object. 

- So here in the mammal class, instead of calling super.init first we're going to do it after
we do all the basic work in the mammal constructor. Let's
save the changes and run the program.

- as we can see, the constructor of mammal was called first, and then
we have the constructor of the animal.
-------------------code---------------------- 
class Animal:
    def __init__(self):
        print("Animal Constructor")
        self.age = 1

    def eat(self):
        print("eat")


class Mammal(Animal):
    def __init__(self):
        print("Mammal Constructor")
        self.wight = 2
        super().__init__()

    def walk(self):
        print("walk")


m = Mammal()
print(m.age)
print(m.wight)
# Mammal Constructor
# Animal Constructor
# 1
# 2
-------------------code---------------------- 

- So to recap, method overriding means replacing or extending
a method defined in the base class. In this implementation
we're extending the init method that we have defined in the animal class
because here, we do some work in the constructor of the
mammal and then we call the constructor of the animal. If we
didn't have this line here this implementation would completely
replace the init method in the animal class.


*** 15- Multi-level Inheritance ***
- So we have seen that inheritance is a good thing, it prevents code duplication
and allows us to reuse code.

- For example, here we have this bird class that inherits from the animal, so it inherits all the
features of this animal class.
-------------------code---------------------- 
class Animal:
    def eat(self):
        print("'eat")


class Bird(Animal):
    def fly(self):
        print("fly")
-------------------code---------------------- 

-  In this case, we are reusing the eat method here. That's pretty good. However, too much of a good
thing is a bad thing, and that's very true about inheritance.

- Because too much inheritance between classes can increase complexity
and introduce various kinds of issues.

- an example. Here we're going to define a class called chicken,
well, a chicken is a bird, so we can inherit it from the bird class,
and here we're going to use the pass statement to define an empty class.
-------------------code---------------------- 
class Animal:
    def eat(self):
        print("'eat")


class Bird(Animal):
    def fly(self):
        print("fly")


class Chicken(Bird):
    pass
-------------------code---------------------- 

-PS: So as we've told before, pass is a statement that doesn't do anything.
 We just use it to make python interpreter happy, because we cannot have a class without anything in it.
We need to have at least one statement. So here we have the pass class.


- But, there is a problem in this code. What is the problem? Well,
the chicken class inherits all the features of the bird class,
but a chicken cannot fly. So with this implementation,
we can create a chicken object, and call the fly method on it.
So this is an example of inheritance abuse.

- Another example of inheritance abuse is around
the concept of employees. So, some people say, well,
an employee is a person, and a person is a
living creature, which is a thing, blah blah blah.
-------------------code---------------------- 
# Employee - Person - LivingCreature - Thing
-------------------code---------------------- 

- This is what we call multi-level inheritance, which can significantly
increase the complexity of our software. To tell we a little story,
in one of my previous jobs, we had this consultant, and he was charging like
$150 an hour or more.

- And he came up with a huge inheritance hierarchy like this,
in fact, three times bigger than this. There were so many levels, and he essentially
tried to model the entire universe.
This is really, really bad. Just because an employee
is a person, and a person is a living creature in the real world, doesn't mean we should have
classes like this in our software.

- The methods we add in our classes are there to solve a business problem.
That is the focus of our software.

- So just because an animal can eat in the real world, doesn't mean our animal
class should also have the eat method.

- we got the point, right?
So this is multi-level inheritance, and we should avoid it at all times. If we want
to use inheritance, limit it to one or two levels. Going beyond that,
trust me, we're going to shoot ourself in the foot.


*** 16- Multiple Inheritance ***
- In Python a class can have multiple base classes, so here we have this
manager class that has two base classes, employee, and
person. This is what we call multiple inheritance, and similar
to multi-level inheritance, it's a source of issues.
-------------------code----------------------
class EmployeeA:
    pass


class PersonA:
    pass


class ManagerA(EmployeeA, PersonA):
    pass
-------------------code---------------------- 

- If we don't use it properly, we're going to introduce all sorts of bugs in our programs.

- Let's take a look at an example. So, in this employee
class, we have a greet method, and in this method we simply print
employee greet. Our person class also has the exact same method, 
but here we print a different message.
-------------------code---------------------- 
class Employee:
    def greet(self):
        print("Employee Greet")


class Person:
    def greet(self):
        print("Person Greet")


class Manager(Employee, Person):
    pass
-------------------code---------------------- 

- Now, our manager class currently has no implementation,
it simply inherits all the features of the person and employee classes.
Now, let's see what happens when we create a manager object
and call the greet method. Which greet method do we think is going to get called?
-------------------code---------------------- 
manger = Manager()
manger.greet()
# Employee Greet
-------------------code---------------------- 


- We get employee greet, because we added the employee class first.
So when Python interpreter tries to execute this line,
-------------------code---------------------- 
class Manager(Employee, Person):
-------------------code---------------------- 

- first, it looks at the manager class to see if it has a method called
greet. If it doesn't, it will look at its first base class.
Does the employee have a greet
method?  If the employee class doesn't have the greet method, then
it will look at the person class.

- So why is this an issue? Because if tomorrow another programmer joins our team,
and for whatever reason they decide to change the order of these
base classes, our program will have a different behavior. So if
they move this person class over here, and run the program,
now, we get a different output.
-------------------code---------------------- 
class Manager(Person, Employee):
    pass
-------------------code---------------------- 

- So similar to multi level inheritance, multiple inheritance
can create all sorts of issues in our programs, we will end up with
classes that inherit features that they shouldn't, like a chicken that flies.

- So if multiple inheritance is a bad thing, why does python
support it? Well, multiple inheritance is not always a bad thing.
It's bad if we don't use it properly. 

- If these classes that we have, they're small classes,
and they have absolutely nothing in common, and we want to inherit their
features in a separate class, that's perfectly fine to use multiple inheritance.
Things start to get complicated when these classes have things in
common, like the greet method.

- a good example of multiple inheritance.
Here we could have a class called flyer,
it's any object that knows how to fly. So let's
add fly here.
-------------------code---------------------- 
class Flyer:
    def fly(self):
        pass
-------------------code---------------------- 

- So it's a very simple abstract concept.
Similarly, we could have another class called swimmer.
It's an object that knows how to swim.
-------------------code---------------------- 
class Swimmer:
    def swim(self):
        pass
-------------------code---------------------- 

-  Now, as we see, these two classes
are very small and abstract, they have nothing in common.
Now we can combine the features of these two classes, so we can create
a flying fish, that knows how to fly and how to swim.
So it's a flyer, and also a swimmer.
This is a good example of multiple inheritance.

-------------------code---------------------- 
class Flyer:
    def fly(self):
        pass


class Swimmer:
    def swim(self):
        pass


class FlyingFish(Flyer, Swimmer):
    pass
-------------------code---------------------- 


*** 17- A Good Example of Inheritance ***
- Now, let's look at a good example of inheritance.
Let's imagine we want to model the concept of a stream of data.

*********************************************************************************
what is stream of data?
A stream of data is a continuous flow of information that can be processed in 
real-time. Think of it like a water stream: just as water flows from one place to another,
data flows from one source to a destination.

In computing, a stream can represent various types of data, such as audio, video, or text, 
and it allows programs to read or write this data in a sequential manner.

This means we can start processing the data as soon as we receive the first part, 
rather than waiting for the entire dataset to be available.

For example, when we watch a video online, the video is streamed to our device, 
allowing we to start watching it while the rest of the video is still being downloaded.
*********************************************************************************

- We can read a stream of data from a file, from a network, or from the memory. All these streams
have a few things in common. We can open them, we can close them, we can read data
from them, but how we read data from a stream is dependent
upon the type of the stream.

- Because reading data from a file is different from reading it from a network. 

- So let's start by defining a base class called stream in this class we're going to define methods like open
and close.
-------------------code---------------------- 
class Stream:

-------------------code---------------------- 


- So define open now here let's say we need a flag to know if the stream is
open or not. So we can define a constructor
and in this constructor, we can set the opened flag initially to false. 
-------------------code---------------------- 
class Stream:

    def __init__(self):
        self.opened = False
-------------------code---------------------- 

- When we call the open method we can set opened to true.
-------------------code---------------------- 
def open(self):
        self.opened = True
-------------------code---------------------- 

- Now what if we try to open a stream that is already open?
That is an invalid operation. So perhaps we want to raise an exception.
So we can check if self that opened, we want to raise an exception.
-------------------code---------------------- 
def open(self):
        if self.opened:
            raise 
        self.opened = True
-------------------code---------------------- 

- What kind of exception? Well, we don't want to do a value error because here we're not dealing with a value.
In this example, we can create a custom exception called invalid operation error. We don't have this in Python.
In this case, we can create a custom exception called invalid operation error.
Because we don't have a built-in exception in Python that represents this concept. So on the top, let's create another class, invalid operation error. So by convention, all custom exceptions should end with error. Now we want to derive this from the base exception class in Python. So every time we want to create a custom exception, we want to create a custom exception.
So every time we want to create a custom exception, we should derive our class from the exception class.
Now here we don't need any code, so we simply add a pass statement.
-------------------code---------------------- 
class InvalidOperationError(Exception):
    pass
-------------------code---------------------- 

- Back to our open method, if the stream is already open, we want to raise an invalid operation error, 
and here we can give a friendly message like stream. is already open.
-------------------code---------------------- 
def open(self):
    if self.opened:
        raise InvalidOperationError("Stream is already opened")
    self.opened = True
-------------------code---------------------- 

- So this is our open method. Now let's define the close method.
That's going to be very similar, so to save time, we're going to copy
these few lines, and rename this method to close.
Now here we want to check, if the stream is already closed, we want to raise an invalid operation error.
So, if not self.opened, we should raise this exception, 
and change the error message to stream is already closed. Finally, here we set open to false.
-------------------code---------------------- 
def close(self):
    if not self.opened:
        raise InvalidOperationError("Stream is already closed")
    self.opened = False
-------------------code---------------------- 

- So these are the common features that we need in every stream.
Now let's go ahead and implement a file stream.

- So we define another class, file stream, which inherits from our stream class.
Now as we told we before, how we read data from a file is different from how we read it from a network.
So we're going to define a method called read, and for simplicity let's just print reading data from a file.
-------------------code---------------------- 
class FileStream(Stream):
    def read(self):
        print("Reading data from a file")
-------------------code---------------------- 

- Now create a network stream class. Network stream,
and we should also change the message to reading data from a network.
-------------------code---------------------- 
class NetworkStream(Stream):
    def read(self):
        print("Reading data from a Network")
-------------------code---------------------- 

- This is a good example of inheritance. Because first of all, we don't have multi-level inheritance,
we only have one or two levels depending on how we want to calculate it.
So we have the stream class on top of our hierarchy, and below that we have two subclasses,
file and network stream.
Now it's okay if we add another level of inheritance here, but we shouldn't go beyond that.
Also as we can see, we don't have multiple inheritance, so our subclasses don't have multiple parents.
-------------------code---------------------- 
class Stream:

    def __init__(self):
        self.opened = False

    def open(self):
        if self.opened:
            raise InvalidOperationError("Stream is already opened")
        self.opened = True

    def close(self):
        if not self.opened:
            raise InvalidOperationError("Stream is already closed")
        self.opened = False


class FileStream(Stream):
    def read(self):
        print("Reading data from a file")


class NetworkStream(Stream):
    def read(self):
        print("Reading data from a Network")
-------------------code----------------------


*** 18- Abstract Base Classes ***

- We're going to continue with the example from the last lecture. There are a couple of
issues with this implementation. The first issue is that we can create 
a stream object and call the open method.
-------------------code----------------------
class InvalidOperationError(Exception):
    pass


class Stream:

    def __init__(self):
        self.opened = False

    def open(self):
        if self.opened:
            raise InvalidOperationError("Stream is already opened")
        self.opened = True

    def close(self):
        if not self.opened:
            raise InvalidOperationError("Stream is already closed")
        self.opened = False


class FileStream(Stream):
    def read(self):
        print("Reading data from a file")


class NetworkStream(Stream):
    def read(self):
        print("Reading data from a Network")


stream = Stream()
stream.open()
-------------------code----------------------

- Why is this an issue? Because this stream class is an abstract
concept. What does it mean to open a stream? Are we working with
a file stream here? A network stream? What kind of stream? So we shouldn't be able
to directly create an instance of the stream class.
We should always subclass it and then create an instance
of the subclass. 

- That is the first issue. So we only created
this stream class as a base class to provide some
code that we're going to reuse across different kinds of streams.
This is the first issue. 

- Now the second issue. If we look at the implementation of file stream and
network stream classes, we can see both these classes
have a read method. If tomorrow we decide to create a different kind of stream,
we should remember to implement this read method and call it exactly read. If we call it read
line or read str or read whatever, it's not going to be
consistent with the other kinds of streams that we have here. In other
words, currently there is no way to enforce a common interface across different kinds
of streams.

- This is more of a convention we have used here. It would be nice
to have a common contract or a common interface across these different types of streams.

- So how can we solve these problems?
That's when we use an abstract base class. An abstract
base class is like a half-baked cookie. It's not ready to be eaten,
it's half-baked, it's half-cooked. It's purpose is to provide some
common code to its derivatives.

- So here we want to make this stream class an abstract base class.
To do that we go on the top and from abc module, which
stands for abstract base class, we import the abc class and
abstract method function, which we are going to
use as a decorator.

- So make sure to type this exactly like what we see here, so the name of the module
is all lowercase and the name of the class is all
uppercase. 
-------------------code----------------------
from abc import ABC, abstractmethod
-------------------code----------------------

- Now, to make this stream class abstract, we should derive it from the abc
class. Abstract base class.
-------------------code----------------------
class Stream(ABC):
-------------------code----------------------

- The second step is to define the common interface
for all streams. We want all streams to have a read method and potentially
a write method in the future.

- So, here we define a read method.
This method has no implementation. So we simply pass.
Now, we need to decorate this method with abstract method decorator.
-------------------code----------------------
@abstractmethod
    def read(self):
        pass
-------------------code----------------------

- With these two simple steps, we fix both the problems we talked about
in this lecture. So now, if we save the changes, and
try to run the program, we can see we immediately have this
red underline, with abstract methods instantiated.
-------------------code----------------------
stream = Stream()
stream.open()

# Abstract class 'Stream' with abstract methods instantiated
-------------------code----------------------

- Basically, when a class has an abstract method, it's considered
an abstract class, and we cannot instantiate them. Which means we cannot
create an instance of them.


- Now let's look at the second problem. So, let's say tomorrow we're going to create
a new kind of stream, we call it memory stream, and 
we derive it from the stream class. For now, let's just pass,
and create a memory stream object.
-------------------code----------------------
class MemoryStream(Stream):
    pass
-------------------code----------------------

- Once again, we can see we have a red
underline, abstract class with abstract methods
instantiated.
-------------------code----------------------
memory_stream = MemoryStream()
memory_stream.open()
# TypeError: Can't instantiate abstract class MemoryStream without an implementation for abstract method 'read'
-------------------code----------------------

- What's going on here? In our stream class, we
defined an abstract method called read. Let's take a
look. Here's our abstract method. If a class
derives from the stream class, it
has to implement this method, otherwise, that class will also be considered abstract.
 
- -So, in this example, our new class, memory stream is also
abstract. If we want to make this a concrete class, so we can instantiate
it, we'll have to implement the read method. So,
define, read, and here we print reading data from
a memory stream.
-------------------code----------------------
class MemoryStream(Stream):
    def read(self):
        print("Reading data from a memory stream.")
-------------------code----------------------

- Now, this memory stream is a concrete class,
we can instantiate it here, and it also follows the contract or the interface
of the stream class. So, all our streams now have a read method. method.
-------------------code----------------------
class FileStream(Stream):
    def read(self):
        print("Reading data from a file")


class NetworkStream(Stream):
    def read(self):
        print("Reading data from a Network")


class MemoryStream(Stream):
    def read(self):
        print("Reading data from a memory stream.")
-------------------code----------------------


*** 19- Polymorphism ***
So in the last lecture we learned about abstract based classes.
As another example here we have defined an abstract based class called
UI control.
-------------------code----------------------
from abc import ABC, abstractmethod


class UIControl(ABC):
    @abstractmethod
    def draw(self):
        pass


class TextBox(UIControl):
    def draw(self):
        print("TextBox")


class DropDownList(UIControl):
    def draw(self):
        print("DropDownList")
-------------------code----------------------
 
- This class has an abstract method called draw and as we can see this method has no
implementation. So this class only defines the contract or the
interface that all its derivatives should follow.

 
- Now, here we have two classes that derive from
UI control, one is text box and the other is drop down list.
Both these classes implement the draw method. Here
we simply print text box and in the drop down list class
we print drop down list.
-------------------code----------------------
class TextBox(UIControl):
    def draw(self):
        print("TextBox")


class DropDownList(UIControl):
    def draw(self):
        print("DropDownList")
-------------------code----------------------

- So nothing new so far.
Now, here we also have a function called draw that takes a UI control object and calls the
draw method on it.
-------------------code----------------------
def draw(control):
    control.draw()
-------------------code----------------------

- So with this we can create a drop down list object
drop down list and pass it to this draw function like this.
-------------------code----------------------
ddl = DropDownList()
draw(ddl)
-------------------code----------------------

- This should be perfectly fine because the drop down list is an instance of
the UI control class. To verify this, let's call is instance
function and pass and pass this DDL object as well as the UI control class.
-------------------code----------------------
print(isinstance(ddl, UIControl))
# True
-------------------code----------------------

- a drop down list object is an instance of UI control
and that means wherever we expect a UI control object, we can pass any
of its derivatives like a text box
or a drop down list.

- we call the draw function with this DDL object.
We see a drop down list.
-------------------code----------------------
draw(ddl)
DropDownList
-------------------code----------------------

- Now what if we pass a text box to this function? 
So we going to create a text box like this and then pass it
to this draw function.
we get text box.
-------------------code----------------------
text_box = TextBox()
draw(text_box)
# TextBox
-------------------code----------------------


- Now we might ask, what is the point of this?
Well, let's take this to the next level and make it more interesting.
we want to change this draw function so instead of getting a control
object, we wanted to get a list or a tuple of controls.

- So, let's rename the parameter to controls, and 
we'll use a for loop to iterate over this controls object.
-------------------code----------------------
def draw(controls):
    for control in controls:
        control.draw()
-------------------code----------------------

- Now, we're going to pass a list of two objects,
a drop down list, and a text box. 
-------------------code----------------------
draw([ddl, text_box])
# DropDownList
# TextBox
-------------------code----------------------

- we get two messages drop down list and text box.
So using this approach, we can render the user interface
of an application. 

- Imagine we have a form with a bunch of text boxes,
drop down lists, radio buttons, and so on. We could have a list of all
these objects, and pass that list to a function like draw,
and that function would take care of rendering
the entire form. 

- What is interesting here, is that our draw function
doesn't know what kind of control it's working with. This is determined
at runtime. It simply iterates over the list of controls, and
calls the draw method of each control object.

- This is what we call "polymorphism".
Poly means many, morph means form. So polymorphism
means many forms. In this example, our draw method
is taking many different forms, and this
is determined at runtime. We could be calling the draw method on a text box,
or a drop down list, or a radio button,
and so on. So this is the classic example of polymorphism.


*** 20- Duck Typing ***
- What we saw in the last lecture was the classic example of polymorphism.
So to achieve polymorphic behavior, we start by defining a base
class, and in this class we define the common behavior
or the common methods that we need in its derivatives or children.
-------------------code----------------------
from abc import ABC, abstractmethod


class UIControl(ABC):
    @abstractmethod
    def draw(self):
        pass


class TextBox1(UIControl):
    def draw(self):
        print("TextBox")


class DropDownList1(UIControl):
    def draw(self):
        print("DropDownList")


def draw1(controls):
    for control in controls:
        control.draw()
-------------------code----------------------

- With this, we achieve polymorphic
behavior in our draw function. So depending on the type of control object that we're working with at runtime,
this draw method takes a different form. It might be the draw method in a text
box, or a drop down list, or radio button, and so on.

- So this is how polymorphism works in pretty much all languages that support classes.
But because python is a dynamically typed language, we don't necessarily need this UI control 
as the base class. In other words, if we get rid of this class. We should also delete it where we inherit it.
With this change, we can still achieve polymorphic behavior.
-------------------code----------------------
class TextBox():
    def draw(self):
        print("TextBox")


class DropDownList():
    def draw(self):
        print("DropDownList")


def draw(controls):
    for control in controls:
        control.draw()
-------------------code----------------------

- Why? Here is the reason. Looking controls parameter.
Nowhere here, we have specified the type of this parameter.
Right? This is purely a label, a name. We can pass any kind of
objects to this draw function. As long as that object is
iterable, python will be happy. 
-------------------code----------------------
def draw(controls):
-------------------code----------------------

- Because here here, we are looping over that object. So that object has to be iterable.
So technically, we can pass a string, a list, a
tuple, a dictionary, anything that is iterable here.
By the same token, that iterable object,
its individual parts, should have a draw method.
-------------------code----------------------
for control in controls:
-------------------code----------------------

- So python doesn't care if these objects derive from the UI control class.
As long as these objects have a draw method, python will be happy.
This is what we call "duck typing".

- So if it walks like a duck, and quacks like a duck, it is a duck.
That is how python works. 

- Because python is a dynamically typed language, and it doesn't check the type of objects.
It only looks for the existence of certain methods in our objects.
In other words, in this case, on line 16, it only looks for the existence of the draw method.
So if this object has a draw method, python assumes it's a UI control.
It's exactly like saying, if it walks like a duck, and quacks like a duck, it is a duck.

- So, to achieve polymorphic behavior, we don't necessarily need a base class like UI control,
because python supports duck typing.
Having said that, having that UI control as an abstract base class is a good practice,
because it enforces a common interface,
or a common contract across all its derivatives. With this, we'll make sure
that every kind of UI control will have a draw method.

*** 21- Extending Built-in Types ***
- In Python, we can also use inheritance with the built-in types.
For example, we can create a class called text, and have it inherit
from the built-in string class.
-------------------code----------------------
class Text(str)
-------------------code----------------------

- With this, our text class will inherit all the features of Python strings, but
we can also add additional features to it. For example, we can add
the ability to summarize it, or duplicate it, and so on.

- So, let's define a method called duplicate, that takes
self, and in this method we simply return self plus self. 
-------------------code----------------------
class Text(str):
    def duplicate(self):
        return self + self
-------------------code----------------------

- what's going on here. As we told we before, self represents the current object
which is in this case an instance of a string class.
So here we're concatenating a string with itself.

- Now we can easily use our text class, so let's add Python
store the result in this variable. Look, our text object
has all the methods of Python strings. So we can convert
it to lowercase, and print it, and here's the result. 
-------------------code----------------------
text = Text("Python")
print(text.lower())
# python
-------------------code----------------------
- But we can also duplicate it. So,
when we duplicate it, we get a new string, which is Python Python.
-------------------code----------------------
print(text.duplicate())
# PythonPython
-------------------code----------------------

- As another example, we can also extend Python lists.
So, let's define a new class, call it trackable list. That inherits from
the built-in list class.
-------------------code----------------------
class TrackableList(list)
-------------------code----------------------

- Now here we want to override the append method.
So every time, we want to append an object to this list,
we want to print a message on the terminal. Perhaps for logging.
So, let's print append called Now we want to call the append method of the super class,
the base class. So here technically we're extending the append
method of the list class.
-------------------code----------------------
class TrackableList(list):
    def append(self, object):
        print("Append Called")
        super().append(object)
-------------------code----------------------

- We are not replacing it. Okay? Now, we can create
a list object using trackable list. Call the append method.
And when we run this program, we can see this message on the terminal.
So, as we see, extending built-in types in Python is really easy.
-------------------code----------------------
custom_list = TrackableList()
custom_list.append("1")
# Append Called
-------------------code----------------------
