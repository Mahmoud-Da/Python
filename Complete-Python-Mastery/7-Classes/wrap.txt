*** 1- Classes ***

- In this section, we're going to look at classes which are extremely important in Python programming,
or in programming in general. 

- So let's start with an example.
we're going to define a list of numbers like this.
-------------------code----------------------
numbers = [1, 2]
-------------------code----------------------

- Now, we have learned that when we use the dot notation,
we get access to all these functions, or more accurately,
methods in list objects. 
- So every list object in Python has these methods.
-------------------code----------------------
numbers = [1, 2]
numbers.
-------------------code----------------------



- Now, wouldn't that be nice if we could create an object like shopping cart,
and this object would have methods like add, remove, get total, like this. 
-------------------code----------------------
shopping_cart.add()
shopping_cart.remove()
shopping_cart.get_total()
-------------------code----------------------

- Or as another example,
wouldn't that be nice if we could have a point object with methods like draw,
move, or get distance,
to get the distance between this point and another point.
-------------------code----------------------
point.draw()
point.move()
point.get_distance(1, 2)
-------------------code----------------------

- That's when classes come to the rescue.
So a class is a blueprint for creating new objects. Throughout the course, 
we have heard the term class.

- For example, let's define a variable and set it to an integer,
and then print its type.
When we run this program, what do we see here?
A class of int. So in Python,
we have a class called int for creating integers.
-------------------code----------------------
x = 1
print(type(x))

# <class 'int'>
-------------------code----------------------


- Similarly, we have classes for creating booleans, lists, dictionaries, and so on.
So every object that we have in Python is created using a class
which is a blueprint for creating objects of that type.

- In this section, we're going to learn how to create custom classes,
like customer, shopping cart, point, and so on.


- Now, before we get started, let's define a few terms.
Once again, a class is a blueprint for creating new objects.
An object is an instance of a class. As an example, we could have a class called human,
and this class would define all the attributes of humans.
Then we could create objects, like John, Mary, Jack, and so on.
-------------------code----------------------
# Class: blueprint for creating new objects
# Object: instance of a class

# Class: Human
# Objects: John, Mary, Jack, and ....
-------------------code----------------------

- So this is the difference between classes and objects.
Now a lot of people use these terms interchangeably,
but technically, a class and an object are different. 

*** 2- Creating Classes ***
- Alright, now let's see how we can create a point class in python.
So we start with the class keyword, then we give our class
a name, like point.
-------------------code----------------------
class Point
-------------------code----------------------

- Note that here we're using Pascal naming convention, which is different from the
naming convention that we use for naming our variables and functions.

- To name our variables and functions, we use all lowercase letters
and we separate multiple words using an underscore. But to name
our classes we use a different convention, which is called Pascal
naming convention. And basically it says that the first letter
of every word should be uppercase and we shouldn't use
an underscore to separate multiple words. Here's an example
we can call this class my point, we can see that the first letter
of every word is uppercase and there is no underscore here.
-------------------code----------------------
class MyPoint
-------------------code----------------------


- after this we add a colon to indicate a block
in this block we'll define all the functions related to points
for example we can define functions for drawing a point for moving this point to a new location
or getting the distance from this point and another point
we define a function called draw parenthesis
now all functions in our classes should have at least one parameter and by convention
we call that parameter "self"  Now we add our colon
and let's just print the word draw on the terminal
-------------------code----------------------
class Point:
    def draw(self):
        print("draw")
-------------------code----------------------

- so now we have a class or a blueprint for creating
point objects every point object that we create will have this draw method

- to create a point object we call this class like a function
there we go now this returns a point object
that we can assign to a variable like point so
if we use the dot operator we can see we have the draw method
as well as a bunch of other methods that we didn't define
but our point object got these methods from another object in python
through a mechanism called "inheritance" we'll look at that later in this section
-------------------code----------------------
point = Point()
point.  => to see the draw method
print(type(point))
# <class '__main__.Point'>
-------------------code----------------------


- we get a class of main dot point this main we see here
is the name of our "module" and we're going to look at that later in this section
so this is the type function that we have seen before we have another useful function
called "isinstance" sometimes we have an object and we want to know if this object
is an instance of a given class.
-------------------code----------------------
print(isinstance(point, Point))
# True
-------------------code----------------------

- however if we change this to int
obviously our point object is not an instance of the int class
so when we run this program we get false.
-------------------code----------------------
print(isinstance(point, int))
# False
-------------------code----------------------



- but our point objects need some initial values like x and y
to set these values we need a constructor.

*** 3- Constructors ***
So here when we create a point object, we want to supply initial
values for x and y coordinates, like this.
-------------------code----------------------
 class Point:
     def draw(self):
         print("draw")

point = Point(1, 2)
-------------------code----------------------

- To achieve this we need a constructor which is a special method that is called 
when we create a new point object.

- how to create a constructor.
So, in our point class, we define a new function the name of this function should be 
double underline init double underline "__init__".

- This is a special method that we call
a magic method. In python classes we have several
magic methods, and we're going to learn more about them throughout this section.


- So, this magic method is called a constructor, and it's executed
when we create a new point object. Now earlier we told  that
all the methods that we define in a class should have at least one parameter
which we call self by convention. So, we add self, and then
optionally we add any additional parameters for initializing a point object, like x
and y.
-------------------code----------------------
def __init__(self, x, y):
-------------------code----------------------

- Now, what is this self?
Self is a reference to the current point object.
For example, when we call the point class, python will internally create
a point object in memory and set self
to reference that point object.

Now, this point object has a bunch of methods that we have seen before
for example, when we use the dot operator we can see all the methods
in this point object.
-------------------code----------------------
point = Point(1, 2)
point.

=> __annotations__
=> __str__
-------------------code----------------------

- But an object can also have attributes
which are basically variables that include data about that object.
For example, we can have attributes like x and y that we can easily print
on the terminal.

- In other words, a class run object bundles data
and functions related to that data into one unit.
think of a human. A human can have attributes like eye color, height,
weight, and so on. As well as functions like walk, talk, and so on.

- So, back to our constructor.
we learned that self is a reference to the current object.
So we can use that to set the x and y attributes
like this.
-------------------code----------------------
def __init__(self, x, y):
  self.x
-------------------code----------------------

- We can set it to some default value like 0.
-------------------code----------------------
self.x = 0
-------------------code----------------------

- or this x argument that we receive in this method.
-------------------code----------------------
self.x = x
-------------------code----------------------

- Similarly, let's set self dot y to y.
-------------------code----------------------
def __init__(self, x, y):
        self.x = x
        self.y = y
-------------------code----------------------

- Now with this code, when we use the dot operator
look we have the draw method
as well as the two new attributes x and y.

- So, we can simply print
point dot x on terminal.
-------------------code----------------------
point = Point(1, 2)
print(point.x)
# 1
-------------------code----------------------


- Now, back to our draw method.
Here again we have this self parameter,
so using this we have a reference to the current point object, and with that we can
read the x and y values and print them on the terminal.

- So here we're going to change this
implementation, and pass a formatted string.
-------------------code----------------------
def draw(self):
    print(f"Point ({self.x}, {self.y})")
-------------------code----------------------

- So using self, we can read attributes of the current object,
or we can also call other methods in this object.

- Now, let's simply call point dot draw.
-------------------code----------------------
point = Point(1, 2)
point.draw()
# Point (1, 2)
-------------------code----------------------


- Now what is interesting here is that when calling the draw method
we didn't have to supply a value for the self parameter,
because python does that by default.
-------------------code----------------------
point.draw(point) 

point.draw()
-------------------code----------------------

- Now technically, we cana pass this point object as a reference
to the current object, but this is really unnecessary,
and it makes our code busy or noisy.


- So, here's what we need to take away.

1- The methods that we define in a class should have at least, one parameter
which by convention is called "self", and this references
the current point object that we're working with.

2- When calling methods of an object, we never have to supply a value
for this parameter, python interpreter does that for us.


*** 4- Class vs Instance Attributes ***

So in the last lecture we defined two attributes for our point
objects in the constructor of the point class.
-------------------code----------------------
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def draw(self):
        print(f"Point ({self.x}, {self.y})")


point = Point(1, 2)
-------------------code----------------------


- So now, whenever we create a new point object, this point object
will have these attributes by default. 

- We can also define an attribute after we create a point object, so here we can set
point.z to 10, because objects in python are dynamic, similar to java script.
-------------------code----------------------
point.z = 10
-------------------code----------------------
- So we don't have to define all the attributes in a constructor. We can define them later whenever we need them.

- Now here's what is important for we to understand. All these
attributes we have defined so far, x, y, and z,
these are instance attributes.

- In other words, these are attributes that belong to point instances or
point objects. So every point object can have different values
for these attributes. 

- Here's an example. We have one point object with these
values, we can create another point object
with different set of values.
-------------------code----------------------
another = Point(3, 4)
another.draw()
# Point (3, 4)
-------------------code----------------------

- When we run this, we can see we have two point objects
and these are completely independent independent of each other.
Each point has its own attributes, just like John
and Mary can have different eye colors.
-------------------code----------------------
point = Point(1, 2)
point.draw()
# Point (1, 2)

another = Point(3, 4)
another.draw()
# Point (3, 4)
-------------------code----------------------

- So these are instance attributes. But we can also
define class attributes, and these are attributes that we define
at the class level, and they are the same across
all instances of a class.


-  we can say all humans have two eyes and two ears,
so these are the attributes that we define at the class level,
and they are shared by all instances.

- So, back to our point example, we can define a class level attribute
in the body of this class.
-------------------code----------------------
class Point:
    default_color = "red"

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def draw(self):
        print(f"Point ({self.x}, {self.y})")
-------------------code----------------------


- So now we have a class level attribute, and we can
read this via a class reference or an object reference.


- We can use this object reference to get access to
the default color attribute, and then print it.
-------------------code----------------------
print(point.default_color)
# red
-------------------code----------------------

- But we can also use the point class to get access
to this attribute. 
-------------------code----------------------
print(Point.default_color)
# red
-------------------code----------------------


- Now as we told before, class attributes are shared across all
instances of a class.
-------------------code----------------------
print(point.default_color)
# red
print(another.default_color)
# red
print(Point.default_color)
# red
-------------------code----------------------

now if we change default_color  color to, let's say,
yellow. Note that we using a class reference "Point", so we not working with any point
objects, we working with the point class. Now,
when we run this program, we can see that the default color of
this point object is changed to yellow. 
-------------------code----------------------
Point.default_color = "Yellow"
print(point.default_color)
# Yellow
print(another.default_color)
# Yellow
print(Point.default_color)
# Yellow
-------------------code----------------------


- So, class level attributes are shared
across all instances of a class. If we change their value,
the change is visible to all objects of that type.

- Now, in practical terms, we will be using
instance attributes most of the time, but there are times
that we may want to define a class variable attribute that is shared
across all objects of a given type.

*** 5- Class vs Instance Methods ***
- In the last lecture we learned about instance versus class attributes. 
We have the same concept around the methods that we define
in a class. 

- So we have instance method as well as class methods.
In this example, both these methods that we have defined in the point class
are instance methods, so we can call them using an instance of the point class,
using an object.
-------------------code----------------------
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def draw(self):
        print(f"Point ({self.x}, {self.y})")
-------------------code----------------------

- Generally speaking, we use these instance methods whenever we need an object reference.
For example, when drawing a point, we really need to work with a specific point object.
That is why this draw method is defined as an instance method.

- But there are times that we don't really need an existing object, and that's when we use a class
method. For example, let's say in our program, there
are a lot of cases where we want to create a point with these initial
values. 0 and 0. This is one way to create a point object and that's perfectly fine, but we can
come up with a different way to create a point object with these values.
Like this.

- so note that we're using a class reference. In this
case, zero() is a method that is defined at the class level,
and when we call it, it will return a point object initialized with (0, 0).
-------------------code----------------------
point = Point(0, 0)
Point.zero()
-------------------code----------------------

-  So we can get this point object and assign it to this point variable.
-------------------code----------------------
point = Point.zero()
-------------------code----------------------

- Now in this example, we refer to this zero method as a factory
method. Because it's like a factory, it creates a new object.

- Now this example is pretty basic, creating a zero point
with these initial values is not a big deal.

- But there are times that initializing an object can be pretty complex.
So every time we want to create an object of a given type, we might
have to pass some magical values here, and we might have to repeat these in several places in our
program.
-------------------code----------------------
Point(0, 0, 1, "a")
-------------------code----------------------
 
- In that case, instead of passing all these magical
values to create an object, we can define a factory method that will return
an object with these values, and this way we can move this complexity
of creating this object into that factory method.



- how we can define a method at the class level.
So, back to our point class, we define
a method, call it zero, and call its first parameter
CLS, which is short for class. Again, this is
purely convention, we can call this anything, but by convention,
whenever we define a class method, we call its first parameter
CLS. And as we can guess, this is a reference to the class
itself, so here we are not working with a point object or a point
instance.
-------------------code----------------------
def zero(cls):
-------------------code----------------------

- Now, to make this method a class method, we need to decorate
it with something like "@classmethod" method. This is what we call a "decorator",
and it's a way to extend the behavior of a method or a function.

- We'll look at decorators and how they work internally later in this section.
So, this is all we have to do to create a class
method in python. Now, in this class method we have a reference to our class,
so with that we can create a point object with initial
values.
-------------------code----------------------
@classmethod
def zero(cls):
    return cls(0, 0)
-------------------code----------------------

- So we call CLS and give it these
initial values. This is exactly like calling Point.zero
and zero. The difference is that if we use CLS, at runtime when we call the zero method,
python interpreter will automatically pass a reference to the
point class to the zero method.
-------------------code----------------------
@classmethod
    def zero(cls):
        # same as Point(0, 0)
        return cls(0, 0)
-------------------code----------------------

- So, we create a zero_point object and then
return it. now we get a point with these initial values.
-------------------code----------------------
zero_point = Point.zero()
zero_point.draw()
# Point (0, 0)
-------------------code----------------------

*** 6- Magic Methods ***

- Throughout this course we've mentioned magic methods a few times. These are the
methods that have two underscores at the beginning and end of their name
and they're called automatically by python interpreter
depending on how we use our objects and classes.


- For example, here we
have this init magic method, we don't directly call it, it's called
automatically by python interpreter when we create
a new point object. 
-------------------code----------------------
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def draw(self):
        print(f"Point ({self.x}, {self.y})")


point = Point(1, 2)
-------------------code----------------------


- Now we have quite a few magic methods in python
over the next few lectures we're going to learn about the key ones. But if we want
to see the complete list, simply search for python 3 magic methods. 
-------------------code----------------------
python3 magic methods
-------------------code----------------------

- we a guide to python's magic methods. On this page we can see various magic methods in different categories with examples.
For example, look at the category of representing our classes.
-------------------code----------------------
https://rszalski.github.io/magicmethods/
-------------------code----------------------

- These are the magic methods that we have in this
category. The first one, "___str__", is a really useful one,
and this is called when we try to convert an object to a string.
-------------------code----------------------
__str__(self)
Defines behavior for when str() is called on an instance of our class.
-------------------code----------------------

- how it works. So back to our code, we have this point
object. If we print this on the terminal,
see what we get?
We get the name of our module, followed by the class name,
and the address of this point object in memory.
-------------------code----------------------
print(point)
# <__main__.Point object at 0x100656900>
-------------------code----------------------

- This is the default implementation of the stir magic method
in our point object.
So, if we type point. , we can see all magic methods that are available in our
point object, we didn't explicitly create these methods, our point object
inherited them from another object.
-------------------code----------------------
point.
-------------------code----------------------

- This is what we call "inheritance," and we're going to learn about that soon.

- Now in this list, we can see we have this __str__ method.
So by default, this returns the name of the class of this object
followed by its memory address. Now let's re-implement this method
to get a better result.

- let's define this str method,
underscore, str to underscore. Now just like before,
the first parameter should be self. Now here we should simply return a string representation
of this point object.
-------------------code----------------------
def __str__(self):
        return f"({self.x}, {self.y})"
-------------------code----------------------

- Now, this point object, this is what we get. This is very useful.
-------------------code----------------------
point = Point(1, 2)
print(point)
# (1, 2)
-------------------code----------------------

- We get the same result, if we also try to convert a point object to a string
using the stir function.
-------------------code----------------------
print(str(point))
# (1, 2)
-------------------code----------------------

- init and stir are examples of two useful magic methods
in python, over the next few lectures we're going to learn about
other useful magic methods.


*** 7- Comparing Objects ***
- There are times that we need to compare two objects.
For example, here we have this point object. If we define
another point object with the exact same values.
-------------------code----------------------
point = Point(1, 2)
other = Point(1, 2)

print(point == other)
# False
-------------------code----------------------

- We get false. What's going on here?
The reason we get false is that by default this equality
operator compares the references or addresses of these two objects in memory.

- In this case, these two variables are referencing
two different objects in memory and that's why they're not equal.

- To solve this problem, we need a magic
method. That magic method is called when we compare two objects. So back to this page.
Here we have comparison magic methods.

- in the previous lesson we check this site . we can look to methods we have for comparing two objects.

-------------------code----------------------
https://rszalski.github.io/magicmethods/
-------------------code----------------------

- For example, we have eq for testing equality
we also have ne which is short for not equal we have lt which is short for less than
greater than and so on.
-------------------code----------------------
__eq__(self, other)
Defines behavior for the equality operator, ==.
__ne__(self, other)
Defines behavior for the inequality operator, !=.
__lt__(self, other)
Defines behavior for the less-than operator, <.
__gt__(self, other)
Defines behavior for the greater-than operator, >.
__le__(self, other)
Defines behavior for the less-than-or-equal-to operator, <=.
__ge__(self, other)
Defines behavior for the greater-than-or-equal-to operator, >=.
-------------------code----------------------

- back to our point class, we need to define
eq magic method. on that page we can see that this method requires two parameters
self and other.
-------------------code----------------------
def __eq__(self, other):
-------------------code----------------------

- Now in this method we need to return true
if these two objects are equal, otherwise false.
So we can write an expression like this.
self.x equals other.x
and self.y equals other.y
so if this expression is evaluated to true
these two objects are considered equal.
-------------------code----------------------
def __gt__(self, other):
    return self.x > other.x and self.y > other.y
-------------------code----------------------        


- now we retest our comparison
-------------------code----------------------
point = Point(1, 2)
other = Point(1, 2)

print(point == other)
# True
-------------------code----------------------

- Now what if we want to compare these two point objects like this?
If point is greater than other.
-------------------code----------------------
print(point > other)
# TypeError: '>' not supported between instances of 'Point' and 'Point'
-------------------code----------------------

- we get a type error because the greater than operator is not supported
between instances of the point class.
So, to solve this problem we need to define another magic method
so define gt which is short for greater than once again we add two parameters
self and other
-------------------code----------------------
def __gt__(self, other):
    return self.x > other.x and self.y > other.y
-------------------code----------------------

- and we test our comparison.
-------------------code----------------------
point = Point(10, 20)
other = Point(1, 2)

print(point > other)
# True
-------------------code----------------------

-  what if we change this to less than
run the program we get false.
-------------------code----------------------
print(point < other)
# False
-------------------code----------------------
so as we see we don't have to explicitly implement each of these operators
when we implement the greater than magic method Python would automatically figure out
what to do if we use the less than operator

*** 8- Performing Arithmetic Operations ***
- We also have magic methods for performing arithmetic operations between two objects.
For example, what if we want to add these two points together?
When we run this program, obviously we're going to get an error.
-------------------code----------------------
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y




point = Point(1, 2)
other = Point(1, 2)

print(point + other)
# TypeError: unsupported operand type(s) for +: 'Point' and 'Point'
-------------------code----------------------

- So back in the list of magic methods (site), we have
numeric magic methods. In this category, if we scroll down
we can see normal arithmetic operators.

- So we have
add, subtract, multiply, and so on. So in order
to add two points together, we need to implement the add
method.
-------------------code----------------------
__add__(self, other)
Implements addition.

__sub__(self, other)
Implements subtraction.

__mul__(self, other)
Implements multiplication.

and so
-------------------code----------------------



- So define add
with two parameters, self and other, we simply return a new point object with these values.
-------------------code----------------------
def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)
-------------------code----------------------


- we get this new point object
at this address, so we don't see the actual
x and y values of this point object, because in this example
we removed the stir magic method.
-------------------code----------------------
print(point + other)
# <__main__.Point object at 0x100bea520>
-------------------code----------------------

- However,
if we store the result of this arithmetic operation in another object,
like combine, and then print combine.x
we can see we get 11, which proves that we successfully added two points together.
-------------------code----------------------
point = Point(1, 2)
other = Point(1, 2)

combined = point + other
print(combined.x)
# 2
-------------------code----------------------

*** 9- Making Custom Containers ***
- Earlier in the course, we learned about the common data structures in python.
You learned about lists, sets, dictionaries, and so on.

- These data structures, or container types, are pretty useful
and sufficient for most cases.

- But there are times that we want to create our own
custom container types. For example, here we have this class
tag cloud, we're going to implement this from scratch.
-------------------code----------------------
class TagCloud:
-------------------code----------------------
- With this class, we can keep track of the number of various tags on
a blog. For example, how many articles do we have that are tagged with python
or javascript and so on. So, because this class represents
a container, it supports various operations around
containers.

- Here are a few examples. Let me create an
object, okay. Now, because this is a container,
we can get the number of items in this container, we can also
get an item by its key, for example, we can get
the number of articles tagged with python,
we can also set that, and finally we can iterate over this container, so
for tag in cloud, we can print each tag
and its count. These are the operations that are supported by this
custom container type.
-------------------code----------------------
cloud = TagCloud()
len(cloud)
cloud["python"] = 10
for tag in cloud:
    print(tag)
-------------------code----------------------


- how to implement a class like this. We create a class, call it tag cloud,
now internally we're going to use one or more
of the built-in data structures like lists, dictionaries, and so on.
In this case, we're going to use a dictionary because it allows us to quickly
get the number of given tag.

- So, first we define a constructor
self and in this constructor we initialize tags attribute to
an empty dictionary.
-------------------code----------------------
class TagCloud:
    def __init__(self):
        self.tags = {}
-------------------code----------------------

- Now we can optionally add a method like add
that takes a tag now here we should check to see
if we have this tag in our dictionary if we don't have it, we're going to set its
value to one, otherwise we're going to increment it by one.

- we use the get method to get an item
by this key, and supply a default value if we don't have that. Now we get the
count, increment it by one and finally we set the value
for this key. So, self the tags of
tag, we set it to this new value. 
-------------------code----------------------
def add(self, tag):
    self.tags[tag] = self.tags.get(tag, 0) + 1
-------------------code----------------------

*******************************************************************************
- The get method in Python dictionaries:
The get method in Python dictionaries is used to retrieve the value associated with a specified key.
It allows we to provide a default value that will be returned if the key does not exist in the dictionary. This is useful for avoiding errors that occur when trying to access a key that isn't present.

Syntax
-------------------code----------------------
value = dictionary.get(key, default_value)
-------------------code----------------------

Parameters
key: The key we want to look up in the dictionary.
default_value (optional): The value to return if the key is not found.
If not provided, it defaults to None.
-------------------code----------------------
my_dict = {'a': 1, 'b': 2}

value_a = my_dict.get('a')  
# Returns 1

value_b = my_dict.get('b')  
# Returns 2

value_c = my_dict.get('c', 0)
# Returns 0, since 'c' is not in the dictionary

value_d = my_dict.get('d')  
# Returns None, since 'd' is not in the dictionary
-------------------code----------------------
*******************************************************************************



- Let's test our program up to this
point. So, we're going to create a cloud
object and then call the add method a few times. 
-------------------code----------------------
cloud = TagCloud()

cloud.add("python")
cloud.add("python")
cloud.add("python")

print(cloud.tags)
# {'python': 3}
-------------------code----------------------


- Now we might be wondering why we created
a custom class instead of using a plain old dictionary.
The reason for this is because we want to make this a little bit smarter than a
typical dictionary. What if we add a python tag
with a capital P. Technically this is the same tag
as the lower case python. We get two separate items. This is how a typical
dictionary behaves.
-------------------code----------------------
cloud = TagCloud()

cloud.add("Python")
cloud.add("python")
cloud.add("python")

print(cloud.tags)
# {'Python': 1, 'python': 2}
-------------------code----------------------

- in this class we're going to take care of case sensitivity.
Whatever tag we receive here, we're going to convert it to
lower case when setting it as well as when reading it.
-------------------code----------------------
def add(self, tag):
    self.tags[tag.lower()] = self.tags.get(tag.lower(), 0) + 1
-------------------code----------------------

- Now save the changes, run the program one more time,
the problem is gone.

- So with this class, we're encapsulating the
complexity around the case sensitivity of tags.

- When using this class we no longer have to worry about
lower case or upper case characters.
-------------------code----------------------
cloud.add("Python")
cloud.add("python")
cloud.add("python")

print(cloud.tags)
# {'python': 3}
-------------------code----------------------

- Now let's take this to the next level.
we want to be able to read the count of a tag like this.
Using square brackets.
-------------------code----------------------
cloud["python"]
-------------------code----------------------

- To do this we need to implement a magic method called
get item.

- So, define get item it should take self as well as a key.
In this method we're going to return self.tags.get this tag, and if we don't
have it we want to return 0 by default, and once again we should
convert this to lower case.
-------------------code----------------------
def __getitem__(self, tag):
    return self.tags.get(tag.lower(), 0)
-------------------code----------------------

- As we can see with this implementation
we can easily get the number of a given tag. We can't do this
with a typical dictionary. If we don't have the python tag, our dictionary
would throw an error.
-------------------code----------------------
print(cloud["python"])
# 3
-------------------code----------------------
 
- Now let's take this to the next level. With the current implementation
we can only read the number of a given tag. We cannot
set it like this.
-------------------code----------------------
cloud["python"] = 10
-------------------code----------------------

- To do that we need to implement another magic method called set item.
It's pretty straightforward so, define
set item it takes three parameters self, key and value. In this case our
key is tag and our value is just count.
-------------------code----------------------
def __setitem__(self, tag, count):
    self.tags[tag.lower()] = count
-------------------code----------------------

-  with this implementation we can set the number of a given tag.
-------------------code----------------------
cloud["python"] = 10
print(cloud.tags)
# {'python': 10}
-------------------code----------------------

- Now in order to be able to get
the number of items in this tag cloud we should implement the len
magic method.
-------------------code----------------------
def __len__(self):
    return len(self.tags)
-------------------code----------------------        

- and finally to make this iterable so we can iterate over it using a for loop
we need to implement another magic method that is iter.
So define iter it takes self, now all we have to do is to use one of the built
in functions to get an iterator
object.


- An iterator object is an object that walks
a container and gets one item at a time. So we call
iter, which is one of the built in functions
what do we want to iterate over? In this case, self the tags.
-------------------code----------------------  
def __iter__(self):
    return iter(self.tags)
-------------------code----------------------  


- So this function returns an iterator
object which gives us one
item at a time in a for loop.
So we simply return it.
-------------------code----------------------  
for tag in cloud:
    print(tag)

# python
-------------------code----------------------  
