*** 1- Python Standard Library ***

- Python has a batteries included philosophy, which means it comes with a comprehensive library of
packages and modules that provide common features that we need when building real applications.

- So in this section, we're going to explore Python standard library. More specifically,
we're going to learn how to work with files and directories, SQLite databases,
date and time objects, generate random values, send emails, and so on.

- As we go through this section, don't worry about memorizing anything. Just try to get an idea what is where and what we
can do. we can always come back to this section and treat it as a reference. 

- For example, if in the future we want to generate random values, we can come back and watch the corresponding lecture.


*** 2- Working With Paths ***

- Over the next few lectures, we're going to learn how to work with files and directories in Python.
In this lecture we're going to look at the path class, because that's the
foundation to work with files and directories. 


- So,
let's import the path class, now we can create a path object in a few different ways.
-------------------code----------------------
from pathlib import Path
-------------------code----------------------

- We can create an absolute path, for example, if we're on windows
we can create a path object like this. C drive,
backslash, program files, backslash, Microsoft
or whatever.
-------------------code----------------------
Path("C:\\Program Files\\Microsoft")
-------------------code----------------------
 
- Now when working with a long path, these double backslash
get a little bit ugly, so we can simplify this by using a raw
string. In a raw string, backslash is not an escape character,
it's taken literally as is. So, we prefix
this with an R, now we have a raw string, so we can get rid of
the second backslash, like this.

-------------------code----------------------
Path(r"C:\Program Files\Microsoft")
-------------------code----------------------

- Now if we're on mac or linux, we can create
an absolute path like this slash user, slash local,
slash bin.
-------------------code----------------------
Path("/usr/local/bin")
-------------------code----------------------

- we can also create a path object that
represents the current folder.
-------------------code----------------------
Path()
-------------------code----------------------

- or we can use a relative path here,
so current folder, let's go to the ecommerce
subfolder, and then pick init.py.
-------------------code----------------------
Path("ecommerce/__init__.py")
-------------------code----------------------

- we can also combine path objects
together, for example we can have one path object, and then using
a slash, combine it
with another path.
-------------------code----------------------
Path() / Path("ecommerce")
-------------------code----------------------

- or we can also combine a path object
with a string, so here we can
have a string.
-------------------code----------------------
Path() / "ecommerce"
-------------------code----------------------

- and then again we can combine
this with another string. 
-------------------code----------------------
Path() / "ecommerce" / "__init__.py"
-------------------code----------------------

- We can also get the home directory of the current user,
so this path class
has a class method called home, that returns the home directory
of the current user. 
-------------------code----------------------
Path.home()
-------------------code----------------------

- So these
are various ways to create the path object, in this demo, we're going to use
what we have here, and store the result in variable we called path.
-------------------code----------------------
path = Path("ecommerce/__init__.py")
-------------------code----------------------

- Now this path object has quite a few useful members,
and in this lecture we're going to show we the most
important ones, but if we want to see the
comprehensive list, simply search for 
-------------------code----------------------
python3 pathlib
-------------------code----------------------


- So with this path object we can call the exist method
to see if this file or directory exists or not
-------------------code----------------------
path.exists()
-------------------code----------------------

- to see if this path represents a file we call is file,
-------------------code----------------------
path.is_file()
-------------------code----------------------

- we also have is directory.
-------------------code----------------------
path.is_dir()
-------------------code----------------------


- we can also extract individual
components in this path which is extremely useful, for example, let's
print path.name so this returns only the file name in this path.
-------------------code----------------------
print(path.name)
# __init__.py
-------------------code----------------------

- We also have path.stem which returns the file name without the extension.
-------------------code----------------------
print(path.stem)
# __init__
-------------------code----------------------

- If we want to get the extension, we can access the suffix attribute,
so this returns .py.
-------------------code----------------------
print(path.suffix)
# .py
-------------------code----------------------


- we can
also get the parent of this path, so path.parent and this returns
the parent folder, ecommerce.
-------------------code----------------------
print(path.parent)
# ecommerce
-------------------code----------------------

- Now here we have a couple other useful methods, one of them is with name, so
path.with name. And we can use this to create a new path object based on this existing path
but only change the name and the extension of the file.
So if we pass, let's say file.txt we get a new path object here. 
-------------------code----------------------
path = path.with_name("file.txt")
print(path)
# ecommerce/file.txt
-------------------code----------------------


- we can also get the absolute value of this path, so
path.absolute let's run the program so here's the absolute value
of this file.
-------------------code----------------------
print(path.absolute())
# /Python/ecommerce/file.txt
-------------------code----------------------

- Obviously this file doesn't exist yet, they're only
representing its path. 

- Now similar to this with name
we have another method with suffix
and we use that to change the extension
of a file. So with suffix
-------------------code----------------------
path = path.with_suffix(".py")
print(path)
# ecommerce/file.py
-------------------code----------------------

- note that here we have not renamed the file
we're only representing a path object. Over the next couple
lectures we will show we how to rename files
and directories. So these are the important members
of the path class that we should know
in the next lecture we'll look at working with directories.

*** 3- Working with Directories ***
- So here we have a path object that represents a directory.
A few useful methods that we need to be aware of are
exists, that returns a boolean, mkdir
to create this directory, rmdir to remove it,
and rename to rename it to a new name.
-------------------code----------------------
from pathlib import Path

path = Path("ecommerce")
path.exists()
path.mkdir()
path.rmdir()
path.rename("ecommerce2")
-------------------code----------------------

- so in this lecture we're not going to look at these, instead
we're going to look at another method that is iter, dir.
-------------------code----------------------
print(path.iterdir())
# <map object at 0x102d8fcd0>
-------------------code----------------------

- With this method we can get the list of files and directories in this path.
So let's print the result and see what we get.
We get a generator object. Remember generator objects?
A generator object, as the name implies, returns a new value
every time we iterate it. So when we're working with a large list of items,
instead of storing all those items in the memory, we use a generator object.
we iterate it and get a new value every time. This is more efficient.
So that's the reason this method returns
a generator object, because when working with files
and directories, it is possible that we can have
a directory with a million files in it.

- So, now we can iterate over this, let's say for p,
and then print p. Let's run the program. So on our machine, we have one file
and three directories at this path. As we can see, this method returns
both the files and directories.
-------------------code----------------------
for p in path.iterdir():
    print(p)

# ecommerce/shopping
# ecommerce/sales.py
# ecommerce/__init__.py
# ecommerce/__pycache__
# ecommerce/customer
-------------------code----------------------

- Now, if we're working with a directory that doesn't have
a million files in it, we can convert this generator
to a list using a list comprehension expression.
So, instead of iterating over this generator, we can use
a list comprehension, which is pretty similar to what we have here.
We add the square brackets.
-------------------code----------------------
paths = [p for p in path.iterdir()]
print(paths)
# [PosixPath('ecommerce/shopping'),
#  PosixPath('ecommerce/sales.py'),
#  PosixPath('ecommerce/__init__.py'),
#  PosixPath('ecommerce/__pycache__'),
#  PosixPath('ecommerce/customer')]
-------------------code----------------------

- Now, we get all these paths and we can print them.
Let's see what we get. We get an array of POSIX path objects.
What is this? Well, this path class that we imported on the top,
this is the base class for two different classes. POSIX path and windows path.
POSIX is the standard use in Unix-like operating systems, so because
we're using a Mac, here we have a list of POSIX path objects.

- If we're on windows, we see a list of windows path objects. Okay?
Now here we can take this comprehension expression to the next level and apply filtering.
Let's say we only want to get the directories. So here are the three directories
that we have inside of the e-commerce directory.
-------------------code----------------------
paths = [p for p in path.iterdir() if p.is_dir()]
print(paths)
# [PosixPath('ecommerce/shopping'),
#  PosixPath('ecommerce/__pycache__'),
#  PosixPath('ecommerce/customer')]
-------------------code----------------------

- So, this method is pretty useful to get the list of files and directories
in a path, but it has two limitations. One is that
we cannot search by a pattern, and second is that it doesn't search
recursively.

- So, for those scenarios we need to use a different method.
That is glob. this method takes a pattern so we can search for all files
or let's say all py files, similar to the other method
this returns a generator. So, we can use it an expression
like this.
-------------------code----------------------
py_files = [p for p in path.glob("*.py")]
print(py_files)
# [PosixPath('ecommerce/sales.py'),
#  PosixPath('ecommerce/__init__.py')]
-------------------code----------------------

- Now, to search recursively we need to change this pattern
to something like this. 
-------------------code----------------------
py_files = [p for p in path.glob("**/*.py")]
print(py_files)
# [PosixPath('ecommerce/sales.py'),
#  PosixPath('ecommerce/__init__.py'),
#  PosixPath('ecommerce/shopping/sales.py'),
#  PosixPath('ecommerce/shopping/__init__.py'),
#  PosixPath('ecommerce/customer/__init__.py'),
#  PosixPath('ecommerce/customer/contact.py')]
-------------------code----------------------

The other option is to use the r glob
method. So, we remove the pattern and use r glob short for recursive glob
now when we run this program we get all the pi files
in the e-commerce directory and all its children.
-------------------code----------------------
py_files = [p for p in path.rglob("*.py")]
print(py_files)
# [PosixPath('ecommerce/sales.py'),
#  PosixPath('ecommerce/__init__.py'),
#  PosixPath('ecommerce/shopping/sales.py'),
#  PosixPath('ecommerce/shopping/__init__.py'),
#  PosixPath('ecommerce/customer/__init__.py'),
#  PosixPath('ecommerce/customer/contact.py')]
-------------------code----------------------

*** 4- Working with Files ***
- In this lecture we're going to learn about the useful
methods to work with files. 

- So here we have a pass object that references
a file, we can check to see if this file exists.
-------------------code----------------------
from pathlib import Path

path = Path("ecommerce/__init__.py")
path.exists()
-------------------code----------------------

- we can rename it to let's say init.txt.
-------------------code----------------------
path.rename("init.txt")
-------------------code----------------------

- we can delete it by calling the unlink method.
-------------------code----------------------
path.unlink()
-------------------code----------------------

- we also have the stat method that returns information about this file.
-------------------code----------------------
print(path.stat())
# os.stat_result(st_mode=33188,
#                st_ino=22143237,
#                st_dev=16777233,
#                st_nlink=1,
#                st_uid=501,
#                st_gid=20,
#                st_size=31,
#                st_atime=1740950939,
#                st_mtime=1740950938,
#                st_ctime=1740950938)
-------------------code----------------------


- We get a stat result object
with these attributes, for example, st underline size
returns the size of this file in bytes, we can also get
the last access time, the last modify time, and the creation time.

- Now all these time values are in seconds after epic, which is
the start of time on a computer, and that is platform dependent, for example
on unix systems, the epic time is January 1st 1970.

- So to print the human readable time
on the top from the time module we need to import the ctime function.
-------------------code----------------------
from time import ctime
-------------------code----------------------

- now from this stat object we can
pick st underline ctime, that is the creation time, and then pass it
to the ctime function.
-------------------code----------------------
print(ctime(path.stat().st_ctime))
# Mon Mar  3 06:28:58 2025
-------------------code----------------------

- We also have a couple methods for reading data from a file, so
pass the read bytes, which returns the content of the file as a bytes
object for representing binary data.
-------------------code----------------------
path.read_bytes()
-------------------code----------------------

- We also have read text, which returns the content of the file
as a string. So we can simply print the result here,
and this is the content of __init__.py file. 
-------------------code----------------------
print(path.read_text())
# print("Ecommerce initialized")
-------------------code----------------------

- Now using this method is easier than the built-in open function
that we've mentioned throughout the course. With the open function,
we'll have to specify the file name, let's say init.py,
then we need to specify the mode, now this returns a file object,
so we're going to make sure to close it, so as a best practice, we should use the
with statement, then get the file object like this,
and then do something with it.
-------------------code----------------------
with open("ecommerce/__init__.py", "r") as file:
    file.read()
-------------------code----------------------

- In contrast, when we use read text, all this magic
happens inside of this method, so we no longer have to worry about
opening a file, closing it, and so on. Similar to read text and read bytes,
we have write text, so we can call it to write some textual
data to a file, or pass.write bytes, again, both these methods take care of
opening and closing a file.
-------------------code----------------------
path.write_text("....")
path.write_bytes()
-------------------code----------------------

- So with this path object, we can do all kinds of operations with a file.
However, when it comes to copying a file, this path object
is not the ideal way to copy a file.

- So, we're going to comment out this few lines, let's say we want to copy this file
to a different location, so we're going to rename this path to source,
then, we're going to create a target path, which would be, let's say the current
directory, plus __init__.py.
-------------------code----------------------
source = Path("ecommerce/__init__.py")
target = Path() / "__init__.py"
-------------------code----------------------

- Now, to copy this file, we'll have to write code like this.
First, we need to read the content of the source, so read
text, then we need to write it to the target, so target.write text
like this.
-------------------code----------------------
target.write_text(source.read_text())
-------------------code----------------------

- It's a little bit tedious, there is a better way. We have a module called
shutil, or shell utilities, and this module provides
a number of high-level operations for copying and moving files and
directories. 

- So, on the top, let's import shutil.
-------------------code----------------------
import shutil
-------------------code----------------------

- now with this module, we can easily copy source to target.
This approach is cleaner and easier than using a pass object.
-------------------code----------------------
shutil.copy(source, target)
-------------------code----------------------

*** 5- Working with Zip Files ***
- In this lecture we're going to learn how to work with zip files in python.


- So, from the zip file module, let's import the zip file class. 
-------------------code----------------------
from zipfile import ZipFile
-------------------code----------------------

- Now we create a zip file object let's call that files.zip. Then as the second
argument we pass w short for write, because we're going to
write to the zip file. So this statement will create this file
in our current folder. Let's get a reference to this zip file and store it
here, or we could call it zip, that is shorter.
-------------------code----------------------
zip_file = ZipFile("files.zip", "w")
-------------------code----------------------

- Now let's say we want to get all the files in this ecommerce directory
and write them to this zip file. That is pretty easy. So
we create a pass object to reference the ecommerce directory
and then call rglob method to recursively find all the files in this
directory and all its children. As we know this returns a
generator, so we iterate over it for pass in and then call zip.write pass
and finally we should call the close method.
-------------------code----------------------
zip_file = ZipFile("files.zip", "w")

for path in Path("ecommerce").rglob("***"):
    zip_file.write(path)

zip.close()
-------------------code----------------------

- Now if something goes wrong here, chances are this statement may not be called.
So we should either use a try finally block or the with
statement, which is shorter and cleaner. So with this zip file
as zip_file now we indent everything here and then we don't need to call the close
method.
-------------------code----------------------
with ZipFile("files.zip", "w") as zip_file:
    for path in Path("ecommerce").rglob("***"):
      zip_file.write(path)
-------------------code----------------------

-  Let's save the changes
and run this program. Now we have a zip file here "files.zip", so let's go ahead and
read its content. So back in app.py, we're going to comment
out these few lines. This time we're going to create a
zip file that is files.zip, but we're not going to open
this in the right mode because we only want to read from it, right?
So this object has a method called name list
which returns the list of all the files
in this zip file. so these are all the files
we have in this zip file.
-------------------code----------------------
with ZipFile("files.zip") as zip_file:
    print(zip_file.namelist())

# ['ecommerce/shopping/',
#  'ecommerce/sales.py',
#  'ecommerce/__init__.py',
#  'ecommerce/__pycache__/',
#  'ecommerce/customer/',
#  'ecommerce/shopping/sales.py',
#  'ecommerce/shopping/__init__.py',
#  'ecommerce/shopping/__pycache__/',
#  'ecommerce/__pycache__/__init__.cpython-313.pyc',
#  'ecommerce/customer/__init__.py',
#  'ecommerce/customer/__pycache__/',
#  'ecommerce/customer/contact.py',
#  'ecommerce/customer/__pycache__/contact.cpython-313.pyc',
#  'ecommerce/customer/__pycache__/__init__.cpython-313.pyc',
#  'ecommerce/shopping/__pycache__/sales.cpython-313.pyc',
#  'ecommerce/shopping/__pycache__/__init__.cpython-313.pyc']
-------------------code----------------------


- we can get information about any of these files for example
pass the address of this file this returns an info object
from this we can print info.file size we also have info.compress size
let's look at the result
-------------------code----------------------
with ZipFile("files.zip") as zip_file:
    print(zip_file.namelist())

    info = zip_file.getinfo("ecommerce/__init__.py")
    print(info)
    print(info.file_size)
    print(info.compress_size)
# <ZipInfo filename='ecommerce/__init__.py' filemode='-rw-r--r--' file_size=31>

# 31
# 31
-------------------code----------------------

- so in this case we don't have compression because we're dealing with a really simple file

- now finally to extract all the files from the zip file
we call zip.extract_all and optionally specify a different
directory to extract to so here let's extract this
into this extract directory now here we have this extract directory
with the content of the ecommerce directory that we compressed
into a zip file.
-------------------code----------------------
with ZipFile("files.zip") as zip_file:
    print(zip_file.namelist())

    info = zip_file.getinfo("ecommerce/__init__.py")
    print(info)
    print(info.file_size)
    print(info.compress_size)
    zip_file.extractall("extract")
-------------------code----------------------

*** 6- Working with CSV Files ***
- In this lecture we're going to learn how to work with csv files in python.

- csv stands for comma separated value, and it's like a simplified spreadsheet
stored as a plain text file.

- So on the top, we import the csv module.
-------------------code----------------------
import csv
-------------------code----------------------

- first we need to open a file, so for this we need to use
the built-in open function, we cannot use the path class,
so open, let's call this file data.csv.
Now we want to open this in the right mode, because we want to write data to it.
This returns a file object, so when we are done, we should make sure
to close it.
-------------------code----------------------
file = open("data.csv", "w")
file. close()
-------------------code----------------------

- or as we told before, a better approach is to use the
with statement. So, with open
as file. Now we don't need to close the file, that is better.
-------------------code----------------------
with open("data.csv", "w") as file:
-------------------code----------------------

- So this csv module has a method for creating a csv writer.
We call this and pass our file object.
So look at the first parameter here, it has to be a file object, that's why
we cannot use the pass class. So we pass the file object here,
and this gives us a csv writer. And with this we can simply
write tabular data to our csv file.
-------------------code----------------------
with open("data.csv", "w") as file:
    writer = csv.writer(file)
    writer.writerow(["transaction_id", "product_id", "price"])
    writer.writerow([1000, 1, 51])
    writer.writerow([1001, 2, 15])
-------------------code----------------------

- Now let's save the changes and run this
program, okay. So here in our project folder, we have data.csv
as we can see, this is like a simplified spreadsheet. 
So we have a table of data, each line represents a row, and our cells are
separated using a comma. This is a very simple way to store data and transfer it from one
machine to another. 

-  how to read a csv file. So let's
say we have a csv file called data.csv Now we should open this file
in the read mode, so we don't want to supply this second argument. Next,
instead of a csv writer, we need a csv reader.
-------------------code----------------------
with open("data.csv") as file:
-------------------code----------------------

- So let's call the reader method, and rename this variable to reader.
Now we can call the list function to get all the data
in the csv file and convert it to a list object.
-------------------code----------------------
with open("data.csv") as file:
    reader = csv.reader(file)
    print(list(reader))
    # [['transaction_id', 'product_id', 'price'], ['1000', '1', '51'], ['1001', '2', '15']]
-------------------code----------------------


- as we see we get a list of lists,
so each line in our csv file is a list of objects.
Note that the value of each cell is represented as a string even if we're dealing with a number.
So we have to manually convert these strings
to integers, floats, and so on.

- We can also iterate over this reader object
because it's iterable. So for row
in reader, let's print row. Run the program, now we don't see anything here.
We only see the output of line 5 where we convert this reader to a list object.
-------------------code----------------------
with open("data.csv") as file:
    reader = csv.reader(file)
    print(list(reader))
    # [['transaction_id', 'product_id', 'price'], ['1000', '1', '51'], ['1001', '2', '15']]

    for row in reader:
        print(row)
-------------------code----------------------

- So what happened to these two lines?
Well, this reader object has an index or a position that is initially set to the beginning of the file.
When we convert this reader to a list, that position goes to the end of the file.
So at that point, when we iterate over it,
we are already at the end of the file.
That is why we cannot iterate this reader twice.

So let comment out line 5,
and run the program one more time. There we go. Now we have three rows,
each row is an array of strings.
-------------------code----------------------
with open("data.csv") as file:
    reader = csv.reader(file)
    # print(list(reader))

    for row in reader:
        print(row)
    # ['transaction_id', 'product_id', 'price']
    # ['1000', '1', '51']
    # ['1001', '2', '15']

-------------------code----------------------

- So as we see working with csv files
is pretty easy in python.
With these objects we can do some interesting things.
For example, let's say we have a directory
of a hundred or a thousand csv files.

- We can iterate this directory, open each csv file,
and remove the first row, which is the header row.
Or perhaps we want to combine these csv files into one file,
we can easily do that here.

- Another interesting thing we can do is
to summarize the value of these csv files.
Let's say we have 10 csv files,
and each csv file represents the transactions
for a given product.
With only a few lines of code,
we can read all these csv files,
and calculate the sum of sales for each product,
and then store the result in another csv file.
The possibilities are endless.

*** 7- Working with JSON Files ***
In this lecture we're going to learn how to work with json files in python.
- json stands for javascript object notation, and it's a popular
way to format data in a human readable way. These days
it's very important to know json, because a lot of popular websites like
facebook, twitter, yelp, youtube, and so on, provide their data
in json format. Also, if we have a website, we can provide our
data in json format.

- So, how to work with
json files. On the top, we import the json module.
-------------------code----------------------
import json
-------------------code----------------------

- Now let's create an array of movie objects.
So movies, we set it to an array. Each item in this array
is going to be a dictionary, because each movie object has properties like id,
title, year, and so on. So each movie object is essentially
a collection of key value pairs. 
-------------------code----------------------
movies = [
    {"id": 1, "title": "Terminator", "year": 1989},
    {"id": 2, "title": "Kindergarten Cop", "year": 1993}
]
-------------------code----------------------

- So here we have a movies object, now we can call json
dot dumps, pass this movies object here,
and get a string that includes our movies data formatted as json.
-------------------code----------------------
data = json. dumps(movies)
print(data)

# [{"id": 1, "title": "Terminator", "year": 1989},
# {"id": 2, "title": "Kindergarten Cop", "year": 1993}]
-------------------code----------------------

- So this is an example of json data.
Now in this case, what we see here
happens to be identical to the syntax that we use
to define an array of dictionaries in python. But this is not the case
when working with other languages.

- Now, back here, so we have this data variable which is a
simple string, now we can write it to a file. So on the top,
-------------------code----------------------
from pathlib import Path
-------------------code----------------------

- then instead of printing this
on the terminal, we're going to create a pass object,
let's say, movies dot json.
And then call, write
text on it, and pass this data string.
-------------------code----------------------
Path("movies.json").write_text(data)
-------------------code----------------------

- now here in our project folder we have, movies dot json,
beautiful.

- So we learn how to write data to a json file.

- Now let's imagine we get this json file from somewhere else, this could be the data
we get from facebook, twitter, imdb, yelp,
youtube, and so on. So we should be able to read this data in python.

- Back to app.py. we're going to delete this movies array,
as well as the line where we dump it to a json string.
So we start with this file, movies dot json,
and read all
its text, and store it in this variable.
-------------------code----------------------
data = Path("movies.json").read_text()
-------------------code----------------------

- So now data is a string that includes data formatted as json.
Next we need to parse this string into an array of objects.

**************************************************************
Parsing in IT refers to the process of analyzing a text or structured data according
to specific rules to convert it into a format that computers can understand and process.
**************************************************************

- So we call json dot loads past this string here,
and this will return an array of dictionaries.
-------------------code----------------------
movies = json.loads(data)
print(movies)
# [{'id': 1, 'title': 'Terminator', 'year': 1989},
#  {'id': 2, 'title': 'Kindergarten Cop', 'year': 1993}]
-------------------code----------------------

- So we can simply get any items in this array.
Here's the first movie, now we have a dictionary, using square brackets
we can get the value of any of these keys.
-------------------code----------------------
print(movies[0])
# {'id': 1, 'title': 'Terminator', 'year': 1989}
-------------------code----------------------

For example, let's get the title of the first movie
around the program, we get terminator. So this is all about
working with json files in python.
-------------------code----------------------
print(movies[0]["title"])
# Terminator
-------------------code----------------------

*** 8- Working with a SQLite Database ***

- In this lecture we're going to learn how to work with sqlite in python.

- sqlite is a very lightweight database that we use for storing data
of an application. It's often the technology of choice for smaller applications
like the apps that we run on phones and tablets. So it allows
us to easily store our data in a structured format like a table of rows
and columns.

- So, let's start by importing the sqlite 3 module.
-------------------code----------------------
import sqlite3
-------------------code----------------------

- Now in the last lecture we created this movies.json file, so let's
go ahead, read all the movies from this json file, and store them
in our sqlite database. So,
back in app.py, we should also import the json
module, and from the pathlib module, we should import the pass class. 
-------------------code----------------------
import sqlite3
import json
from pathlib import Path
-------------------code----------------------

- Now, we create a pass object to load movies
that json file, read all its content, this
will give us a string, so we can pass that to json
dot loads, and this will give us the list of movies.
-------------------code----------------------
movies = json.loads(Path("movies.json").read_text())
-------------------code----------------------

- Now, before going any further, let's print
this movies object and see if everything is working
up to this point. So, let's run the application.
-------------------code----------------------
movies = json.loads(Path("movies.json").read_text())
print(movies)
# [{'id': 1, 'title': 'Terminator', 'year': 1989},
#  {'id': 2, 'title': 'Kindergarten Cop', 'year': 1993}]
-------------------code----------------------

- now we want to store this list in a database. So,
this sqlite object has a method called connect.
We pass the name of our database file here, let's call it db
dot sqlite 3.
-------------------code----------------------
connection = sqlite3.connect("db.sqlite3")
-------------------code----------------------

- We could call it anything, it doesn't matter.
Now, if this file doesn't exist, this
method will create it for us.
So, it will return a connection object, this connection object,
similar to files, should be closed when
we're done with it. So, a better approach, is to use the
with statement, and then get the connection.
-------------------code----------------------
with sqlite3.connect("db.sqlite3") as conn:
-------------------code----------------------

- Next, we need to create a command. This command is basically the
instruction we send to the database, for creating data, updating data,
deleting it, and so on. Quite often we use a language called sql,
that is beyond the scope of this course, so if
we're not familiar with it, don't worry. It's pretty easy to learn, in fact,
it's far easier than python.

- so we're assuming we have a table called
movies, where we store all our movies. Then we add values,
parenthesis, and in parenthesis we add three question
marks, separated by a comma. So, these question marks 
are placeholders for the values that we're going to supply in the next step. 
-------------------code----------------------
command = "INSERT INTO Movies VALUES(?, ?, ?)"
-------------------code----------------------

- So, here's an example. we're going to create a
command, and set it to a string like this. Insert
into, movies, So our table of movies will have three columns,
id, title, and year.

- So next, we need to iterate over our movies list,
now we need to execute this command. So we use our connection object,
this has a method called execute, as the first argument
we pass our command, and as the second argument
we need to pass the actual values. So each movie object
in this for loop is a dictionary,
it has key value pairs like id, title,
and year. All we want here is the actual values.
so, we call "movie.values" now we need to get
these values, and put them in a tuple, so
we use the built in tuple function like this.
-------------------code----------------------
for movie in movies:
    conn.execute(command, tuple(movie.values()))
-------------------code----------------------

- So here we're iterating over our movies
list, for each movie we execute this command, when we're done
we should call connection
dot commit. At this point all these changes
will be written to the database. Let's save the changes,
now if we run this program,
we're going to get an error, there we go, operational error,
no such table, movies.
-------------------code----------------------
with sqlite3.connect("db.sqlite3") as conn:
    command = "INSERT INTO Movies VALUES(?, ?, ?)"

    for movie in movies:
        conn.execute(command, tuple(movie.values()))
    conn.commit()

# sqlite3.OperationalError: no such table: Movies
-------------------code----------------------

- Because here we're dealing with an empty
database, this database doesn't have any tables, so we need to create the movies
table first. Here on google, if we search for
-------------------code----------------------
db browser for sqlite
-------------------code----------------------

- we will find this website,
-------------------code----------------------
https://sqlitebrowser.org/
-------------------code----------------------


- On this website we can find an application
to open a sqlite database and look at its content. As we can see
on the right side we have executables
for various operating systems, so go ahead and download the right executable
for our operating system.

- When we open db browser we're going to see something like this.
So on the top, let's go to open database, here in our project
directory, let's open our database file,
there we go, so as we see we don't have any
tables here.

- Let's go ahead and create a table,
we're going to call that "Movies", and then we need to add
three fields, or three columns to it. So add field, the first one
is id, the type of this column should be integer,
and we're going to mark this as primary key, which means we're going to
use the value of this column as a unique identifier for each movie.
We want to make sure each movie has a
unique id. Okay? Now let's add another
field, we're going to call that title, the type of this column
should be text. And finally another field,
we're going to call that year, once again the type of this is going to be integer,
because here we're going to store values like
1984. So, this is how we create a table, as we can see
that's pretty easy. 

- finally now we need to click, "write changes", beautiful,
so, back to our program, let's run it one more time,
okay, this time we didn't get
an error, so back to db browser, now if we select the movies
table, and go to browse data, we can see, both our movies ended
up here, they're stored in a structured format, so we have a table with
columns and rows, it's beautiful.

- Now how to read data from this database.
to read data from a database, first we need to connect to it.
-------------------code----------------------
with sqlite3.connect("db.sqlite3") as conn:
-------------------code----------------------

- instead of inserting a movie into the movies table, we're going to select
all the movies. 
The command that we should write is select star from movies.
-------------------code----------------------
command = "SELECT * FROM Movies"
-------------------code----------------------

- Now, we don't need to iterate
over the movies object, we simply need to execute this
command, so, connection dot execute, we pass the
command, and this will return a "cursor", so when we read data
from a database, we'll get a "cursor", let's store that here, a cursor
is an iterable object, so we can iterate over it, and get one
row at a time, for row in cursor.
-------------------code----------------------
with sqlite3.connect("db.sqlite3") as conn:
    command = "SELECT * FROM Movies"
    cursor = conn.execute(command)
    for row in cursor:
        print(row)

    # (1, 'Terminator', 1989)
    # (2, 'Kindergarten Cop', 1993)
-------------------code----------------------

- We also have this method, so
fetch all, that will return all the rows in this table in one go.
So, here we'll get a list, let's call that movies,
and then print it on the terminal. Now, if we run this, we're not
going to get any result, because after we iterate over this cursor,
we'll get to the end of the cursor, so we won't be able to read it again.
So, we're going to comment out these two lines, save the changes, and run the
program.
-------------------code----------------------
with sqlite3.connect("db.sqlite3") as conn:
    command = "SELECT * FROM Movies"
    cursor = conn.execute(command)
    # for row in cursor:
    #     print(row)

    movies = cursor.fetchall()
    print(movies)
    # [(1, 'Terminator', 1989), (2, 'Kindergarten Cop', 1993)]
-------------------code----------------------

*** 9- Working with Timestamps ***

Over the next few lectures, we're going to learn how to work with date and time in python.
Basically we have two modules for working with date and time,
one is the time module, which gives us a time stamp, and the other is date time, which gives us date time objects
with attributes like year, month, and so on.

- In this lecture we're going to
look at the time module, and we'll look at the date time module next.
-------------------code----------------------
import time
-------------------code----------------------

- So, this time module has a method called time, that returns the current date time as a time stamp, let me show we.
So print, the result this is what we get.
-------------------code----------------------
print(time.time())
# 1741823482.881205
-------------------code----------------------

- this floating point number represents the number of seconds
from the beginning of time, no we're not talking about big bang here, that is the beginning
of time on our operating system. On Unix that is January 1st
1970, on windows honestly we're not sure, so this floating
point number we see here, is the number of seconds after
January 1st 1970, which is referred to as Unix epic time.

- As we can see, these timestamps are not human readable, so we
use them to perform calculations. Here is an example.
we're going to define a function to simulate sending an email
to 10,000 recipients. So send emails,
let's just do a for loop for i in range 10,000,
we're going to do a pass here.
-------------------code----------------------
def send_emails():

    for i in range(10000):
        pass
-------------------code----------------------

- Now, we're going to call this function, but before calling
that, we're going to call time.time to get the current time,
store it here, and one more time after we send
the emails, so time.time that is the end time.
-------------------code----------------------
start = time.time()
send_emails()
end = time.time()
-------------------code----------------------

- Now we set duration
to end minus start.
Let's print the result,
duration. So this is the amount of time
it took to execute this function.
-------------------code----------------------
duration = end - start
print(duration)
# 0.00016498565673828125
-------------------code----------------------

- Now earlier in the course, we also
talked about the time it module, we can also use that to calculate
the execution time of some piece of code.

- Both approaches are perfectly fine.
So as we learn more about Python
or any other programming languages,
we will realize that there are multiple
ways to solve a problem.
So these are timestamps in Python.

*** 10- Working with DateTimes ***

- In this lecture we're going to learn how to work with
datetime objects in python. So on the top, let's import
the datetime module.
-------------------code----------------------
import datetime
-------------------code----------------------

- This module has a class called
datetime. There are a few different ways to create a datetime object.
-------------------code----------------------
datetime.datetime()
-------------------code----------------------

- Here's one way. We can pass the year, the month,
and the day, and optionally we can pass the hour, minute,
and second as well. So this returns
a datetime object, let's call that dt.
-------------------code----------------------
dt = datetime.datetime(2018, 1, 1)
-------------------code----------------------

- Now what we don't like about this code that we see in a lot of tutorials
is this datetime.datetime. That is just ugly. It is better to import the datetime
class from this module. 
-------------------code----------------------
from datetime import datetime

dt = datetime(2018, 1, 1)
print(dt)
# 2018-01-01 00:00:00
-------------------code----------------------

-  So this is a method defined in the datetime class.
And this returns the current datetime.
-------------------code----------------------
dt = datetime.now()
print(dt)
# 2025-03-13 10:02:31.675504
-------------------code----------------------

- We also have datetime.strip time. That is for parsing or converting
a datetime string. This is particularly useful
when we get input from the user or read it from a file.
-------------------code----------------------
dt = datetime.strptime()
-------------------code----------------------

- In both these scenarios, we're dealing with strings.
So our datetime values are represented as strings
and we need to convert them to datetime objects.
So, let's say we have a string like this.
2018, 01, 01.
-------------------code----------------------
dt = datetime.strptime("2018/01/01")
-------------------code----------------------

- Now we need to tell python how to parse
or how to convert this string into a datetime object.
So we need to tell it what parts represent
the year, the month, and the day.
For that, we use directives. So, as the second argument, we pass
a format string that includes the directives that specify various components of this datetime string.
So we use a percent capital Y to represent a four digit year.
Then we have a slash
percent lowercase m to represent a two digit month
and percent d to represent a two digit day.
We also have directives for hour, minute, and second.
-------------------code----------------------
dt = datetime.strptime("2018/01/01", "%Y/%m/%d")
print(dt)
# 2018-01-01 00:00:00
-------------------code----------------------

- Now don't worry about memorizing any of these,
we can always find this in the documentation. So if we search 
-------------------code----------------------
python3 strptime
-------------------code----------------------

- on this page, down the bottom, we have this table of directives,
so we can see various directives and their meaning.
-------------------code----------------------
https://docs.python.org/3/library/datetime.html
-------------------code----------------------


- Now back to our code, so this method returns a datetime object
and we can store it. We can also convert a timestamp
into a datetime object.

So on the top, let me import the time module,
we call time the time, let's say we have this timestamp somewhere in our program,
perhaps we read it from a file.
Now, we want to convert it to a datetime object.
So, this datetime class has another class method called
from timestamp. You can pass this timestamp,
this returns a datetime object, so we store it.

- and now let's print it to see what we get.
So this is the current datetime on our machine.
-------------------code----------------------
dt = datetime.fromtimestamp(time.time())
print(dt)
# 2025-03-13 11:20:19.657717
-------------------code----------------------


- So these are a few different ways to create a datetime object.
Now, our datetime object has attributes like year, month, day, and so on.
So, we can print a formatted string.
-------------------code----------------------
dt = datetime.fromtimestamp(time.time())

print(f"{dt.year}/{dt.month}")
# 2025/3
-------------------code----------------------

-  We also have a method for formatting datetimes.
This method is the opposite of strftime. So, with this method,
we convert a string into a datetime object.
With strftime, we convert a datetime object into a string.
So, we need to specify our directives.
-------------------code----------------------
print(dt.strftime("%Y/%m"))
# 2025/03
-------------------code----------------------


- We can also compare datetime objects
for example. We can see if dt2 is greater than dt1.
-------------------code----------------------
dt1 = datetime(2018, 1, 1)
dt2 = datetime.now()
print(dt2 > dt1)
# True
-------------------code----------------------

*** 11- Working with Time Deltas ***
- In the last lecture we learned about date time objects, these objects represent
a point in time. In the date time module we also have a class called
time delta, which represents a duration.
-------------------code----------------------
from datetime import datetime, timedelta
-------------------code----------------------

- Now when we subtract these two dates, we get a time delta object.
So let's add duration to dt2 minus dt1 and print it on the terminal.
-------------------code----------------------
dt1 = datetime(2018, 1, 1)
dt2 = datetime.now()

duration = dt2 - dt1
print(duration)
# 2628 days, 11:38:36.052896
-------------------code----------------------

- Now this time delta object has a few interesting attributes. We have
duration, the days, let's print that on the terminal
and add a label for clarity. We also
have seconds, let's take a look,
and run the program. 

- 11 hours and 38 minutes is equivalent to 41,970 seconds.
-------------------code----------------------
print(duration)
# 2628 days, 11:38:36.052896

print("days", duration.days)
# days 2628

print("seconds", duration.seconds)
# seconds 41970
-------------------code----------------------


- We also have a method called total seconds. This is a method,
not an attribute. Let's see what this returns.
So this value we see here is the total
duration represented as seconds. So if we calculate
the number of seconds in
2628 days, 11 hours and 38 minutes, we get this value "227101230.113785".
-------------------code----------------------
print("total_seconds", duration.total_seconds())
# total_seconds 227101230.113785
-------------------code----------------------

- So these are a few interesting members of the time delta class.
Now in case we're wondering why we don't have month or year here, the reason is that we can
have a varying amount of time in a month or in a year.
That's why we only have days, seconds, and microseconds.

- Now we can also add a time delta object to a date time object, let me show we.
So, for our first date time, we're going to add a time delta
of one day.

Now if we print
dt1,
we get
January the 2nd.
And the difference is 323 days.
-------------------code----------------------
dt1 = datetime(2018, 1, 1) + timedelta(1)
print(dt1)
# 2018-01-02 00:00:00
-------------------code----------------------

- However,
someone else looking at this code may not be quite sure what this one here represents.
Is it one day, one hour, one second?
So it's better to use keyword arguments here for clarity.
We set days to one. We can also set seconds
to a thousand.
-------------------code----------------------
dt1 = datetime(2018, 1, 1) + timedelta(days=1, seconds=1000)
print(dt1)
# 2018-01-02 00:16:40
-------------------code----------------------

*** 12- Generating Random Values ***

- In this lecture we're going to learn how to generate random values in Python.

- So on the top we import the random module. This module has
a method called random that generates a random value between 0
and 1. we get a floating point number. Every time we run
this program, we get a different value.
-------------------code----------------------
import random

print(random.random())
# 0.7764312619933015
-------------------code----------------------

- Now, we also have another method, rand-int
that generates a random integer between two numbers, let's say 1
and 10. So we get 10, now we get 2, 8, and so on.
-------------------code----------------------
print(random.randint(1, 10))
# 9
-------------------code----------------------

- We have another
super useful method called choice, that takes an array,
let's say an array of numbers, and randomly picks one of the items
in this array. 
-------------------code----------------------
print(random.choice([1, 2, 3, 4]))
# 2
-------------------code----------------------

- Now we have a similar method, choices, that selects multiple
values from this array. So here as the second argument, after
this array, we need to supply a keyword argument, that is k,
we set it to 2, and this returns two random items from
our original array. 
-------------------code----------------------
print(random.choices([1, 2, 3, 4], k=2))
# [4, 2]
-------------------code----------------------

- Now, with this choices method, we can generate
a random password. Let me show we. So, let's duplicate this line,
set k to 4, let's say we want a password
of 4 characters. Now, instead of an array,
we should pass a string. So, A, B, C, D, E, F, G, H, whatever. Basically,
we can pass any sequence to this method, and it will pick 4 items
from that sequence.
-------------------code----------------------
print(random.choices("abcdefghi", k=4))
# ['i', 'c', 'i', 'd']
-------------------code----------------------

- So, to generate a password, we should combine
all these items in this array into a string.
To do that, we create an empty string, and call
the join method on it, and this will join all the items
in an array using an empty string as a separator.
-------------------code----------------------
print("".join(random.choices("abcdefghi", k=4)))
# cddg
-------------------code----------------------

- So, when we run the program, we get a string instead of an array.
Now, if we use a comma in the string, that comma will be used
as the separator when joining the
items of this array.So, let's run the program one more time.
See what we get? We don't want that. We want an empty string. that's why we used 
empty string with join method.
-------------------code----------------------
print(",".join(random.choices("abcdefghi", k=4)))
# c,b,c,b
-------------------code----------------------
 
-  Now the only issue we have here
is the limited choice of characters. Now one way is to type all the lowercase
and uppercase as well as digits,
but that is tedious. There is a better way. We have this string module,
let's import that. 
-------------------code----------------------
import string
-------------------code----------------------

- This module has a few interesting attributes.
Let's print string.ascii letters. This returns a string
that includes all the lowercase and uppercase letters.
We also have ascii lowercase, uppercase, as well as digits.
-------------------code----------------------
print(string.ascii_lowercase)
# abcdefghijklmnopqrstuvwxyz

print(string.digits)
# 0123456789
-------------------code----------------------

- Take a look. So we get all the numbers
from 0 to 9.
Now, instead of passing
a string in choices method, we can pass string dot ascii letters plus string
dot digits.
And here's our random password.
-------------------code----------------------
print("".join(random.choices(string.ascii_lowercase + string.digits, k=9)))
# 9qd99f64n
-------------------code----------------------


- We also have another useful method
for shuffling an array. So let's say we have an array of numbers.
One, two, three, four.
We can call random.shuffle and pass this array here.
Now, when we print this, the order of these items
are randomly changed.
-------------------code----------------------
numbers = [1, 2, 3, 4]
random.shuffle(numbers)
print(numbers)
# [3, 4, 2, 1]
-------------------code----------------------

*** 13- Opening the Browser ***
- in this lecture we're going to learn how to open a web browser in a python script.

- this is particularly useful if we're building an automation script
that does a bunch of tasks and at the end we want to open up a browser window
for example, let's say we're building a script to deploy our website
so we build our website locally on our development machine, when we're done
we want to run this script to deploy it to a web server, at the end we will have to
open a browser window, type the address of our website and press enter
this is manual and we can automate it. so we can have our python script
open up a web browser at the end of deployment, so here let's print
deployment completed.

- now to open a web browser, we need to import the web browser
module, this module has this method called open, we simply pass the url
of the target website, let's say google.com
now, when we run this program
we see this message here
and a browser window opens
pointing to google.com, so we don't have to manually type this
button on our website, the explorer window
-------------------code----------------------
import webbrowser

print("Deployment completed")
webbrowser.open("http://google.com")
-------------------code----------------------
