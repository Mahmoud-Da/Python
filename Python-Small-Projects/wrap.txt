*** 1-Getting Started ***

PREREQUISITES
• Basic familiarity with Python
• Variables
• Loops
• Functions
• File handling

*** 2-Dice Rolling Game ***
Problem:
- First we get this question, roll the dice.
-------------------code----------------------
Roll the dice? (y/n):
-------------------code----------------------

- Here we have only two options, yes or no.
If we type anything else, we get an error message saying invalid choice.
-------------------code----------------------
Roll the dice? (y/n): z   
Invalid choice!
-------------------code----------------------

- Now we can type a y, either lower case or upper case, it doesn't matter.
And every time we get two new random numbers, just like how we roll a dice.
-------------------code----------------------
Roll the dice? (y/n): Y
(2, 5)
Roll the dice? (y/n): y
(4, 1)
-------------------code----------------------

- Now if we type n, our program terminates and displays a message saying thanks for playing.
-------------------code----------------------
Roll the dice? (y/n): n
Thanks for playing!
-------------------code----------------------

Solution:
- Before we jump into coding, we always take a moment to map out what we want to do. Kind
of like checking a map before we start a road trip. It helps us to see the big picture and
avoid getting lost along the way.


-  So let's quickly plan our approach before we start
writing any code. it makes things much smoother. So in this python file, we're
going to use comments to map out how this program should behave. 

- So first we should ask the user a question, like roll the dice, then we should check the user input. So if
user enters y, then we should generate two random numbers and print them. Otherwise, if the
user enters no, then we should print a thank we message and terminate the program. Otherwise,
if the user types anything else, we want to print an error message like invalid choice.
Now we want to make sure that the user can keep playing until they decide to terminate the
game. So we should put these instructions inside a loop for repetition. So everything here should
go inside a loop, an infinite loop.
-------------------code----------------------
# Loop
# Ask: roll the dice?
# If user enters y
# Generate two random numbers
# Print them
# If user enters n
# Print Thank You message
# Terminate
# Else
# Print invalid choice
-------------------code----------------------

- Okay? Now let's start converting these comments into
actual code. So first we're going to ask the user to roll the dice and to do that we use
the input function. Now here we should type a prompt, we can use double quotes or single
quotes, different people have different preferences. Whatever we like, just make sure to stick to
that. So here we're going to ask, roll the dice and give the options yes or no. We add a colon
followed by a white space, so whatever the user types will be separated from our prompt.
finally store the result in a variable, we can call it choice.
-------------------code----------------------
# Loop
choice = input('Roll the dice? (y/n): ').lower()
# If user enters y
# Generate two random numbers
# Print them
# If user enters n
# Print Thank You message
# Terminate
# Else
# Print invalid choice
-------------------code----------------------

- Okay? Now we'll  Next we should check
if choice equals y. So if choice equals a lowercase y or choice equals an uppercase y.
-------------------code----------------------
if choice == 'y' or choice == 'Y':
-------------------code----------------------

- that's one way to do this, but there is a smarter way. We can treat whatever the user types as
lowercase. So look, if we hover our mouse over this choice variable, look at the type,
the type is a string. So the input function returns a string and we know that in python,
string objects have a bunch of methods. So here we can use the lower method to convert
whatever the user types into lowercase. 
With that we can get rid of the second condition.
-------------------code----------------------
choice = input('Roll the dice? (y/n): ').lower()
  if choice == 'y':
-------------------code----------------------

- Okay? Now we should generate two random numbers. And to do that, first we have to import
the random module. Now in this module we have a method, we can call random.randint to generate
a random integer or a random number between these two numbers, a and b. In this case,
1 and 6. Now this returns a random number, so we store it in a variable like die1. Now we
have to repeat this to generate the second random number.
-------------------code----------------------
import random

choice = input('Roll the dice? (y/n): ').lower()
if choice == 'y':
    die1 = random.randint(1, 6)
    die2 = random.randint(1, 6)
-------------------code----------------------

- Next we should print these numbers.
So here we call print. Now for simplicity, we can use a formatted or an f string. So we
type an f before our quotes. And here we add parentheses. Inside the parentheses, we want
to print our random numbers like 1 and 2. But instead of hard coding these numbers, we
want to print the actual random numbers that are generated here. So we replace one with curly
braces to add a placeholder or a hole in our string. And inside this hole, we add die1. And
similarly, replace two with curly braces and add die2. So we print these numbers.
-------------------code----------------------
print(f'({die1}, {die2})')
-------------------code----------------------

- Next we should check if the user types an n. So elif choice equals n, then we want to print a thank
we message. So thanks for playing. Now to terminate the
program, we want to break out of our loop. Now we haven't added the loop here, so
on the top, now there are two ways to do this. Some people like to declare a variable
like running or playing and initialize it to true. Then
they add it as the loop condition. So while playing is true, then we're going to
repeat these instructions. And when the user types an n, we can use the break
statement to jump out of this loop.
-------------------code----------------------
playing = True

while playing:
    choice = input('Roll the dice? (y/n): ').lower()
    if choice == 'y':
        die1 = random.randint(1, 6)
        die2 = random.randint(1, 6)
        print(f'({die1}, {die2})')
    elif choice == 'n':
        print('Thanks for playing!')
        break
-------------------code----------------------

- That's one way, but there is a better way.
This variable here is really unnecessary. So we can use true as the condition for this
loop and get rid of one extra line of code. Also note that it's a good practice to add a line break
between our import statements and the rest of the code. It makes our code cleaner
and easier to the eyes.
-------------------code----------------------
while True:
    choice = input('Roll the dice? (y/n): ').lower()
    if choice == 'y':
        die1 = random.randint(1, 6)
        die2 = random.randint(1, 6)
        print(f'({die1}, {die2})')
    elif choice == 'n':
        print('Thanks for playing!')
        break
-------------------code----------------------

- Now finally,
if the user types anything else, we want to print an error message. So print
invalid choice. As simple as that. That was our first project.
-------------------code----------------------
import random


while True:
    choice = input('Roll the dice? (y/n): ').lower()
    if choice == 'y':
        die1 = random.randint(1, 6)
        die2 = random.randint(1, 6)
        print(f'({die1}, {die2})')
    elif choice == 'n':
        print('Thanks for playing!')
        break
    else:
        print('Invalid choice!')
-------------------code----------------------

*** 3-Number Guessing Game ****
Problem:
- Alright, for our next project, we're going to build a number guessing game.
So here's how it's going to work. When we run our program, it generates a random number between
1 and 100 that we have to guess.
-------------------code----------------------
Guess the number between 1 and 100:
-------------------code----------------------

- Now if we type an invalid number like A, we get an error message.
So let's type a valid number like 50. Now the program is giving us feedback.
It says this is too high. So let's try 25. It's still too high. What if we try 10?
Still too high. How about 5? Now it's too low. So the number that the computer has generated
is between 5 and 10. Let's try 7. It's too low. Let's try 8. There we go. We guessed the number.

-------------------code----------------------
Please enter a valid number
Guess the number between 1 and 100: 50
Too high!
Guess the number between 1 and 100: 25
Too high!
Guess the number between 1 and 100: 10
Too high!
Guess the number between 1 and 100: 5
Too low!
Guess the number between 1 and 100: 7
Too low!
Guess the number between 1 and 100: 8
Congratulations! You guessed the number.
-------------------code----------------------

Solution:

- Alright, once again, before we write any code, let's map out
what exactly we're going to do. So first we should have our program generate
a random number, then we should ask the user to make a guess. Now we want to make sure
that the user enters a valid number. So if the user enters
an invalid number, so if not a valid number, then we want to print an error, otherwise
we should give the user some feedback. So we can say if this number
that the user entered is less than the number to guess,
we can say this is too low.
Otherwise, if this number that the user entered is higher
than the number to guess, we can say this is too high.
Otherwise, that means number equals
guess, right? So in this situation we should say, hey, well done,
we made a guess. Now we want to make sure that the user can make multiple
guesses. So except the first line, we should put the rest of our
code inside a while loop for repetition. So here's the structure
of our program.
-------------------code----------------------
#  Generate a random number
# Loop
# Ask the user to make a guess
# If not a valid number
#   Print an error
# If number ‹ guess
#   Print too low
# If number › guess
#   Print too high
# Else
#   Print well done
-------------------code----------------------
PS: We don't want to add the first line inside
a loop because we want to generate a random number only once.

- Now let's convert these comments into actual code.
To generate a random number, first we import
the random module, then we add a line break
to separate our import statement from
the rest of our program. Next we call
random.randint to generate a number between 1 and 100.

- Let's store this in a variable
called number2 guess.
Always use descriptive names for our variables. So don't use variable
names like n or x or a
because someone else reading our code
they have no clue what these variables represent.
Okay? So number2 guess.
-------------------code----------------------
import random


number_to_guess = random.randint(1, 100)
-------------------code----------------------

- Next, we should ask the user to make a guess.
So we don't want to add the loop yet,
let's just convert this comment into code.
So here we call the input function and tell the user to guess
the number between 1 and 100.
-------------------code----------------------
user_input = input( 'Guess the number between 1 and 100: ')
-------------------code----------------------

- Now we know that the input function
returns a string, so we can
store it in a variable like user input.
Now we should convert this to a number. And to do that we use the int function,
we pass user input, and store the result in a variable called
guess.
-------------------code----------------------
user_input = input( 'Guess the number between 1 and 100: ')
guess = int(user_input)
-------------------code----------------------

- Now look, user input is only used in a single place. There is no need
for this variable anywhere else in this program. Because for the rest of our
program we're going to work with
this integer. So we can simplify our code and make it more concise
by removing this variable.
It's unnecessary. So we can
get the string that is returned from the input function
and pass it directly to the int function.
With this we can remove this unnecessary variable.
So when this program is executing,
first, the input function is called, then the return value which is a string is
passed to the int function.
-------------------code----------------------
guess = int(input('Guess the number between 1 and 100: '))
-------------------code----------------------

- Now how can we validate
that this is a valid number? Well, before we do that, let's just print
guess on the terminal to see if our program works up to this
point. So this is a good technique
for building larger programs. Always do it in baby steps.
So instead of implementing the entire program
do it in baby steps, make sure it works and then move on.
So here in the terminal, let's run
our program and enter an invalid number like a.
-------------------code----------------------
guess = int(input('Guess the number between 1 and 100: '))
print(guess)

# Guess the number between 1 and 100: a Traceback (most recent call last):
# File "number_guessing_gam
# e-py", line 5, in ‹module>
# guess = int (input ( 'Guess the number between 1 and 100: '))
# ValueError: invalid literal for int() with base 10: 'a'
-------------------code----------------------

- Alright, look, our program crashed
because an exception is thrown on this line.
And here's the type of the exception, value error. So to handle
this situation and prevent our
program from crashing, we have to add this line inside a try block.
So we type try then add indentation now right after try we should
type accept, followed by the type of error we want to handle
in this case value error.
Okay? Now if we end up here, we want to print an error message and say, please
enter a valid number.
-------------------code----------------------
try:
    guess = int(input('Guess the number between 1 and 100: '))
  except ValueError:
    print('Please enter a valid number')
-------------------code----------------------

- Okay, let's run our program one more time.
So we type a. Okay, this time our program didn't crash
instead we got a friendly error message.
-------------------code----------------------
Guess the number between 1 and 100: a 
Please enter a valid number
-------------------code----------------------

- So we're done with this step. Now, we should give the user some feedback.
So after the accept block we want to add a line break
to separate this bit of logic from the rest of the logic
which is about giving the user some feedback.
So using these line breaks is like how we break up a story
into multiple paragraphs. Imagine if we read a book and there are no paragraphs.
Obviously reading that book is very difficult.
So here we can check if guess is less than number to guess reprint a message and say too low.
-------------------code----------------------
try:
    guess = int(input('Guess the number between 1 and 100: '))
  except ValueError:
    print('Please enter a valid number')

if guess < number_to_guess:
  print('Too low!')
-------------------code----------------------

- Now here we have an error message
on the guess variable saying guess is possibly unbound.
we know this is a weird error message
but basically this is happening because
we have declared this variable inside the try block.
so it's only meaningful inside the try block.
This is called the scope of this variable. So to fix this error
we have to move these two lines inside our try block
and add indentation.

-------------------code----------------------
try:
    guess = int(input('Guess the number between 1 and 100: '))
    
    if guess < number_to_guess:
      print('Too low!')
  except ValueError:
    print('Please enter a valid number')

-------------------code----------------------

- So we read a number then we check
if it's less than the number to guess
otherwise elif guess is greater than
number to guess we print too high
otherwise that means the user guessed it correctly
so here we can say
congratulations we guessed the number.
Now let's get rid of these comments
we don't need them anymore.

finally we put all these instructions inside an infinite loop.
-------------------code----------------------
import random


number_to_guess = random.randint(1, 100)

while True:
    try:
        guess = int(input('Guess the number between 1 and 100: '))

        if guess < number_to_guess:
            print('Too low!')
        elif guess > number_to_guess:
            print('Too high!')
        else:
            print('Congratulations! You guessed the number.')
            break
    except ValueError:
        print('Please enter a valid number')
-------------------code----------------------

*** 4-Rock Paper Scissor ***

Problem:
- Alright, our next project
is a fun game that we have all played in our childhood. Rock, paper,
scissors game. 
-------------------code----------------------
Rock, paper, or scissors? (r/p/s):
-------------------code----------------------

- Now this project is a little bit more challenging than the previous
project, so let me run the program and show we how it works. First we
get a question, rock, paper, or scissors. Here we only have three
choices, R, P, or S. 
-------------------code----------------------
Rock, paper, or scissors? (r/p/s): a
Invalid choice!
-------------------code----------------------

- If we type anything else, we get an error message saying, invalid choice. 
-------------------code----------------------
Rock, paper, or scissors? (r/p/s): r
You chose
Computer chose
You lose
Continue? (y/n):
-------------------code----------------------

- Now let me go with R, that is short for rock. So we chose rock, computer chose
paper, and we lost. Now right after we get asked if we want to continue.
-------------------code----------------------
Continue? (y/n): y
Rock, paper, or scissors? (r/p/s): s
You chose *
Computer chose
You win
-------------------code----------------------

- Let's try again. This time we're going to go with scissors.
So we chose scissors, computer chose paper, we won.
-------------------code----------------------
Continue? (y/n): n
-------------------code----------------------

- Now, we don't want to continue, so let's type N, the game
ends. Again, this project is a bit more challenging than the previous ones,

Solution:

- Alright, once again, before we write any code, let's map out what we're going to do.
So first we're going to ask the user to make a choice.
Now if the choice is not valid, we're going to print an error.
Otherwise, we should let the computer to make a choice as well.
Next we should print the choices using emojis, and this is the fun part.
Next, we should determine the winner, and finally we ask the user if they want to continue.
If not, we're going to terminate the game.
So this is the structure of our program. 
-------------------code----------------------
# Ask the user to make a choice
# If choice is not valid
#  Print an error
# Let the computer to make a choice
# Print choices (emojis)
# Determine the winner
# Ask the user if they want to continue
# If not
#  Terminate
-------------------code----------------------

- Now let's start coding.
So first we should ask the user to make a choice, to do that we use the input function.
Here we type rock, paper, or scissors.
And in parenthesis we can type the valid option, so r, p, and s.
Now we get the result and store it in a variable called user choice.
Next we should validate the choice. So just like before, here we're going to call the lower method,
so we can treat the user's input as lowercase text.
We talked about this technique in one of our earlier projects.
Now to validate the user's choice, here we can use a bunch of if statements.
So we can say if user choice does not equal r, and user choice does not equal p, and user
choice does not equal s, then we can print an error message and say invalid choice.
That's one way, but this is not a very clever or very professional way to implement this.
-------------------code----------------------
user_choice = input('Rock, paper, or scissors? (r/p/s): ').lower()
if user _choice != 'r' and user_choice != 'p' and user_choice != 's':
  print('Invalid choice!')
-------------------code----------------------

- There is a better way.
We can store the list of valid choices in a list, and then check to see if the user's
choice is in that list or not.
So in the first line, we can declare a variable called choices, and initialize it to a list
a list of valid choices.
So r, p, and s. Now we can simplify this if statement and say if user choice not in choices, then print an error message.
This implementation is more concise and more elegant.
-------------------code----------------------
choices = ['r', 'p', 's']
user_choice = input('Rock, paper, or scissors? (r/p/s): ').lower()
if user_choice not in choices:
  print( 'Invalid choice!')
-------------------code----------------------


- Now we can further improve this and convert this list to a tuple.
Why?
Because lists can be modified in our program.
So somewhere we might accidentally modify the list and use the append method to add a
new item to the list or remove method to remove one of the existing items.
This could be an accidental mistake.
-------------------code----------------------
choices = ['r', 'p', 's']
choices.remove('r')
-------------------code----------------------

- But if we convert this to a tuple, it becomes read only.
So topples look, they don't have the remove or append methods.
So a tuple is just like a read only list.
So we have our valid choices. And we are done with this step.
-------------------code----------------------
choices = ('r', 'p', 's')
user_choice = input('Rock, paper, or scissors? (r/p/s): ').lower()
if user_choice not in choices:
  print('Invalid choice!')
-------------------code----------------------


- Now before going further, let's test our program.
So we're going to remove these two lines.
Now back to the terminal, let's run our program.
So if we type a, we get an error message, beautiful.
-------------------code----------------------
Rock, paper, or scissors? (r/p/s): a
Invalid choice!
-------------------code----------------------

- But if we type r, we don't get an error. Great.
-------------------code----------------------
Rock, paper, or scissors? (r/p/s): r
-------------------code----------------------

- Next, we should let the computer to make a choice.
And to do that, first we have to import an error.
We have to import the random module.
-------------------code----------------------
import random
-------------------code----------------------

Now earlier we used the randint method to generate a random number between two numbers.
But here we want to use a different method and that is choice.
With this we can pass a list or a tuple like choices and let the computer choose one
of these valid choices.
So let's store the result in a separate variable like computer choice.
So we're done with this step.
Now, let's print the choices. So, first we want to print the choices without emojis just to make sure that our program is
working up to this point.
So here we can type, we chose, and then use concatenation to append user's choice here.
-------------------code----------------------
computer_choice = random.choice(choices)
print('You chose' + user_choice)
-------------------code----------------------

- That's one way, but a better and more elegant way is to use a formatted string.
So we prefix the string with an F, which is short for formatted, and here we add curly braces
to insert a value dynamically.
In this case, user choice. With this we don't have to use concatenation.
Okay. Similarly, we can duplicate this line and say computer chose, and here we add computer choice.
-------------------code----------------------
computer_choice = random.choice(choices)
print(f'You chose {user_choice}')
print(f'Computer chose {computer_choice}')
-------------------code----------------------

- Let's run our program. and test our code.
-------------------code----------------------
Rock, paper, or scissors? (r/p/s): s
You chose s
Computer chose r
-------------------code----------------------


- Now we should print emojis. How can we do that?
Well, there are two ways. One way is to use an if statement and say, if user choice.
equals R, then we can print an emoji.
On Mac we can bring up the emoji keyboard by pressing control, command, and space.
On windows IDK.
So here we can type rock and select this rock.
Now similarly we can add a second condition and say if user choice equals S, then we're going
to print scissors.
-------------------code----------------------
if user_choice == 'r':
  print('🪨')
elif user_choice == 's':
  print('✂️')
-------------------code----------------------

- But again, this approach is not the best way because we need three if statements to map
these letters to emojis. a better way.
Now in python we have a data structure called a dictionary.
A dictionary is used to map a key to a value. So we can map the character R to the emoji of a rock.
Similarly we can map the letter S to scissors.
Okay. Now how can we declare a dictionary?
Well, here we can declare a variable called emojis and set it to curly braces.
Inside the braces we type key value pairs.
So our key is going to be R, then we type a colon and map it to the emoji of a rock.
Note that in this case both our key and value are strings. But this is not a requirement.
So we can map a string to a number or an object, whatever we want to do.
Now similarly, let's map S to scissors and also P to paper.
-------------------code----------------------
emojis = {r: '🪨', s: '✂️', p: '📃'}
-------------------code----------------------


- Back to the part about printing the user's choice.
Instead of printing the user's choice, which is a letter like R, P or S, we are going to
go to this dictionary and look up the value associated with a given key.
So here we type emojis, then using square brackets we can look up the value associated
with one of these keys.
Now here in the auto completion box we can see the valid keys which are P, R or S, but
we are going to replace this with user choice.
Now similarly, here we type emojis and pass computer choice.
-------------------code----------------------
print(f'You chose {emojis[user_choicel]'})
print(f'Computer chose {emojis[computer_choice]}')
-------------------code----------------------


- Alright, we are done with this step.
The next step is determining the winner.
Now before moving forward, we want to add some line breaks to divide our code into different
segments, just like the paragraphs of an article.
So, on the top, we are declaring our emojis and valid choices.
These two lines are highly related, so we want to keep them together.
But look at the next line. The next line is about getting the user's input.
This line has nothing to do with the previous lines. So it's like a different paragraph in a story.
So here we add a line break.
Now again, these three lines are highly related because they are part of getting the user's input.
So we want to keep them together, but separate them from getting the computer's choice.
Now once again, we add a line break here, because this segment is all about printing the user's
and computer's choice.
-------------------code----------------------
emojis = {r: '🪨', s: '✂️', p: '📃'}
choices = ('r', 'p', 's')

user_choice = input( 'Rock, paper, or scissors? (r/p/s): '). lower()
if user_choice not in choices:
  print( 'Invalid choice!')

computer_choice = random. choice (choices)

print(f'You chose {emojis[user_choicel]'})
print(f'Computer chose {emojis[computer_choice]}')
-------------------code----------------------


- Now, let's move on to the next segment, which is determining the winner.
So we add a line break, and here we can check if user choice is the same as computer choice,
then we print tie, else if, or elif.
Now, here we want to implement the scenario where the user wins. There are three scenarios.
One is user choice is rock, and computer choice is scissors.
In this case, we want to print we win. There's another scenario where user's choice is scissors, and computer choice is
paper.
-------------------code----------------------
if user_choice == computer_choice:
  print( 'Tie!')
elif user_choice == 'r' and computer_choice == 's':
  print( 'You win')
elif user _choice == 's' and computer_choice == 'p':
  print( 'You win')
-------------------code----------------------


- Again, here we can print we win, but there is a better way.
We can combine these two statements into a single statement using the logical or operator.
So, this is one scenario or one condition where the user wins.
As we can see, we've selected this expression.
Now we type left bracket, so the entire expression is now surrounded by parenthesis.
Right after, we type or, now here, we should select our second condition.
Again, we type a left bracket to surround this with parenthesis.
Now we select the entire expression, cut it, and put it right here.
Now similarly, we type another or operator and add the third condition.
And that is user choice equals p or paper, and computer choice equals rock.
So, if any of these conditions is true, the user wins.
Otherwise, the user loses.
-------------------code----------------------
if user_choice == computer_choice:
 print( 'Tie!')
elif (user_choice == 'r' and computer_choice == 's') or (user_choice == 's' and computer_choice == 'p') or (user_choice == 'p' and computer_choice == 'r'):
 print( 'You win')
else:
 print( 'You lose')
-------------------code----------------------

- Now this line is getting a little bit too long. So, to make our code more readable, we can break it down into multiple lines.
So, right after this or operator, we add a line break.
Now, here we have an error saying expected expression.
Because python interpreter expects a colon here.
So, to tell the interpreter that this is a multiline statement, here we add a backslash.
Now, to better format our code, it's better to line up all these conditions.
So, we put this on a new line, add tab.
Again, on this line, we add a backslash.
Now, these two conditions are perfectly aligned.
Now similarly, let's add another backslash and put this condition on a new line.
So, this is one way to break this code down into multiple lines.
But all these backslashes are kind of ugly.
-------------------code----------------------
if user_choice == computer_choice:
 print( 'Tie!')
elif \
 (user_choice == 'r' and computer_choice == 's') or \
 (user_choice == 's' and computer_choice == 'p') or \
 (user_choice == 'p' and computer_choice == 'r'):
 print( 'You win')
else:
 print( 'You lose')
-------------------code----------------------

- better way.
Look, here we have three conditions, each surrounded by parenthesis.
Now, we can grab all these three conditions and wrap them with parenthesis like this.
We can remove the backslash. we add parenthesis.
So, the left one is here and the right one should be at the end.
Right here. With this, we no longer need these backslashes anymore.
So, Python interpreter knows that this outer parenthesis represents a long expression.

-------------------code----------------------
elif(
  (user _choice == 'r' and computer_choice == 's') or
  (user_choice == 's' and computer_choice == 'p') or
  (user_choice == 'p' and computer_choice == 'r')):
-------------------code----------------------



- We determined the winner.
Next, we should ask the user if they want to continue.
So, once again, we add a line break to separate this segment from the previous segment, which
is about determining the winner.
And then, use the input function to ask the user if they want to continue or not.
So, right away we call the lower method.
And then store the result in a variable like should continue.
We cannot use the word continue because this is a reserved keyword in python.
-------------------code----------------------
should_continue = input('Continue? (y/n): ').lower()
  if should_continue == 'n':
-------------------code----------------------

- So, here we check if should continue equals n, then we want to terminate the program.
Now, to do this, first we have to add these statements inside a while loop.
So, here we add a while loop with true as the condition.
Now, let's indent all these lines.
So, if the user types an n, then we want to break out of this loop to terminate the program.
Otherwise, if they type y or anything else, we can treat it as yes.
-------------------code----------------------
import random

emojis = {r: '🪨', s: '✂️', p: '📃'}
choices = ('r', 'p', 's')

user_choice = input( 'Rock, paper, or scissors? (r/p/s): '). lower()
while True:
  if user_choice not in choices:
    print( 'Invalid choice!')
  
  computer_choice = random. choice (choices)
  
  print(f'You chose {emojis[user_choicel]'})
  print(f'Computer chose {emojis[computer_choice]}')
  
  if user_choice == computer_choice:
   print( 'Tie!')
  elif(
    (user _choice == 'r' and computer_choice == 's') or
    (user_choice == 's' and computer_choice == 'p') or
    (user_choice == 'p' and computer_choice == 'r')):
      print( 'You win')
  else:
   print( 'You lose')
  
  should_continue = input('Continue? (y/n): ').lower()
    if should_continue == 'n':
      break
-------------------code----------------------

- So, let's run our program. First, let's try an invalid choice, like a.
Alright, our program crashed on this line, line 13 where we try to show the emoji associated
with the user's choice. Now, obviously, in this dictionary, dictionary of emojis, up here, we don't have a key with
the value of a, right? So, look, down here, we are validating the user's choice.
If the user types an invalid choice, we just print an error message.
But the rest of the code gets executed.
So, we end up on this line, and this line throws an exception.
-------------------code----------------------
Rock, paper, or scissors? (r/p/s): a
Error: print(f'You chose {emojis[user_choice]}')
-------------------code----------------------


- To fix this issue, right after printing an error, we should use the connection.
We should use the continue statement to jump back to the beginning of the while loop.
So, we ask the user one more time to make a choice.
-------------------code----------------------
import random

emojis = {r: '🪨', s: '✂️', p: '📃'}
choices = ('r', 'p', 's')

user_choice = input( 'Rock, paper, or scissors? (r/p/s): '). lower()
while True:
  if user_choice not in choices:
    print( 'Invalid choice!')
    continue
  
  computer_choice = random.choice(choices)
  
  print(f'You chose {emojis[user_choicel]'})
  print(f'Computer chose {emojis[computer_choice]}')
  
  if user_choice == computer_choice:
   print( 'Tie!')
  elif(
    (user _choice == 'r' and computer_choice == 's') or
    (user_choice == 's' and computer_choice == 'p') or
    (user_choice == 'p' and computer_choice == 'r')):
      print( 'You win')
  else:
   print( 'You lose')
  
  should_continue = input('Continue? (y/n): ').lower()
    if should_continue == 'n':
      break
-------------------code----------------------

- Let's try one more time.
If we type an a, we get an error message and our program doesn't crash.
Beautiful.

-------------------code----------------------
Rock, paper, or scissors? (r/p/s): a
Invalid choice!
Rock, paper, or scissors? (r/p/s): b
Invalid choice!
Rock, paper, or scissors? (r/p/s): r
You chose
Computer chose *
You win
Continue? (y/n): y
Rock, paper, or scissors? (r/p/s): p
You chose
Computer chose
You win
Continue? (y/n): n
-------------------code----------------------

Refactor:

- All right, our program is working, but just because it's working, it doesn't mean our
work is finished. We should always review our code and find opportunities to refine
and improve it. In coding, this is called refactoring. It's basically a fancy term for
changing the structure of our code without changing its functionality. In this lesson,
we're going to look at a common refactoring technique called modularization. Modularizing
code means breaking down a large program into smaller reusable parts called modules or
functions. 

- Think of it like organizing a messy room into different boxes, each holding specific
items. Instead of having one big pile of everything, we put related things together, making it easier
to find what we need and keep things tidy. 

- Now, back to this code, earlier we talked about different segments in our program. So we have a segment for displaying choices, we have another
segment for determining winner and so on. Now we're going to extract these segments into
small functions, each having a single responsibility.  

- So we start from the top. These few lines have a single responsibility, and that is getting the user's choice. So we
can extract these few lines into a separate function called get user choice. So up here, after we
declare our emojis and choices, let's define a function called get user choice. Always
use descriptive names for our functions. Now let's move these few lines inside this function.
-------------------code----------------------
def get_user_choice():
  user_choice = input('Rock, paper, or scissors? (r/p/s): ').lower()
  if user_choice not in choices:
    print( 'Invalid choice!')
    continue
-------------------code----------------------

- Now here we have an error because the continue keyword can only be used inside a loop. So here
we need to add a while loop, while true, then we move these few lines inside this loop. 
-------------------code----------------------
def get_user_choice():
  while True:
    user_choice = input('Rock, paper, or scissors? (r/p/s): ').lower()
    if user_choice not in choices:
      print( 'Invalid choice!')
      continue
-------------------code----------------------

- So if the user enters an invalid choice, we print an error and then continue which means we jump
to the beginning of the while loop. Otherwise, we break out of this loop, and at the end we
should return a value from this function. What value? User's choice. So here we use the
return statement to return user choice.
-------------------code----------------------
def get_user_choice():
  while True:
    user_choice = input('Rock, paper, or scissors? (r/p/s): ').lower()
    if user_choice not in choices:
      print( 'Invalid choice!')
      continue
    else:
      break
    return user_choice
-------------------code----------------------


- Now there is a better way to write this code. Instead
of breaking out of this loop, we can return user choice right here. So return user choice. With
this we can make our function slightly shorter.
-------------------code----------------------
def get_user_choice():
  while True:
    user_choice = input('Rock, paper, or scissors? (r/p/s): ').lower()
    if user_choice not in choices:
      print( 'Invalid choice!')
      continue
    else:
      user_choice
-------------------code----------------------

- what happens if we swap these if and else statements. So instead of checking if user choice is not in the list of choices, we check if user
choice is in the list of choices. In this case, we are going to return immediately. So return
user choice. Otherwise, we are going to print an error message and continue.
-------------------code----------------------
def get_user_choice():
  while True:
    user_choice = input('Rock, paper, or scissors? (r/p/s): ').lower()
    if user_choice in choices:
      user_choice
    else:
      print( 'Invalid choice!')
      continue      
-------------------code----------------------

- Okay? Now with this implementation, we don't even need the continue keyword, because if we end up here, we print
an error and then the control automatically moves to the beginning of the while loop. So we can get
rid of the continue statement and make our code slightly shorter.
-------------------code----------------------
def get_user_choice():
    while True:
        user_choice = input('Rock, paper, or scissors? (r/p/s): ').lower()
        if user_choice in choices:
            return user_choice
        else:
            print('Invalid choice!')
-------------------code----------------------

- Now back to our main while loop. Earlier we had a few lines for getting users input. Those
lines are now inside the get user choice function. So here we call get user choice. Get
the result and store it in a variable called user choice. 
-------------------code----------------------
user_choice = get_user_choice()
-------------------code----------------------

- Next we are going to apply the same technique to these two lines. These two lines are highly related and have a single
responsibility, displaying choices. So let's select these two lines, cut. Now, after this
function, we define another function called display choices. 
-------------------code----------------------
def display_choices():
    print(f'You chose {emojis[user_choice]}')
    print(f'Computer chose {emojis[computer_choice]}')
-------------------code----------------------

- back to our while loop.
after we have an error, we have an error, we have an error, we have an error, we have an error
for determining the winner. Again, select cut. Let's define a new function. Determine winner. Now here we have an error because we need to add indentation here. Good. Now back to our
while loop. 
-------------------code----------------------
def determine_winner():
    if user_choice == computer_choice:
        print('Tie!')
    elif (
        (user_choice == ROCK and computer_choice == SCISSORS) or
        (user_choice == SCISSORS and computer_choice == PAPER) or
            (user_choice == PAPER and computer_choice == ROCK)):
        print('You win')
    else:
        print('You lose')
-------------------code----------------------

- After we after we display the choices, recall, determine
good. Now we can do the same thing with our while loop. So we can extract this
entire logic and put it into a separate function.Let's call that
play game. This is where we have our game logic. Let's select all this code and
add indentation. 
-------------------code----------------------
def play_game():
    while True:
        user_choice = get_user_choice()

        computer_choice = random.choice(choices)

        display_choices()

        determine_winner()

        should_continue = input('Continue? (y/n): ').lower()
        if should_continue == 'n':
            break
-------------------code----------------------

- Now if we look up, we have a bunch of errors
because in this function, display choices, we do not
have a variable called user choice. This variable is declared inside
our play game function. So to fix this issue,
we have to pass user choice and computer choice to these functions. So
we go to our display choices function and
give it two parameters, user choice and computer choice.
Now the errors are gone. 
-------------------code----------------------
def display_choices(user_choice, computer_choice):
-------------------code----------------------

- Similarly, in determine winner, we add two parameters,
user choice and computer choice. The errors are gone.
-------------------code----------------------
def determine_winner(user_choice, computer_choice):
-------------------code----------------------

- Now when calling these functions, we should
pass these values as arguments. User choice and
computer choice. One more time.
User choice and computer choice.
-------------------code----------------------
def play_game():
    while True:
        user_choice = get_user_choice()

        computer_choice = random.choice(choices)

        display_choices(user_choice, computer_choice)

        determine_winner(user_choice, computer_choice)

        should_continue = input('Continue? (y/n): ').lower()
        if should_continue == 'n':
            break
-------------------code----------------------

- Now one last thing.
If we run our program, nothing happens.
Because after this refactoring, we move
different lines of our code inside different functions.
But currently none of these functions is getting called.
So at the end,
we have to call the play game function. So our program starts.
-------------------code----------------------
play_game()
-------------------code----------------------

- We have one more opportunity for improving this code. Look, there are multiple places
where we have defined our choices. This is bad for two reasons.
-------------------code----------------------
emojis = {r: '🪨', s: '✂️', p: '📃'}
choices = ('r', 'p', 's')
-------------------code----------------------

- One reason is that if we have a typo in our code, our program is not
going to work. That's number one problem.
-------------------code----------------------
emojis = {r: '🪨', s: '✂️', p: '📃'}
choices = ('r', 'p', 'test')
-------------------code----------------------

- The second problem is that if
tomorrow we decide to change our choices from R, S, and P
to something else like 1, 2, and 3, there are multiple
places that we have to modify. 

- In programming, we have this principle called dry, which is short for don't repeat yourself.
So we don't want to have repetition or duplication in our code. Most of the time
it's a bad practice. 

- So how can we solve this problem? Well, we can
generate this tuple based on this dictionary. In this dictionary
we have three key value pairs. Our keys are R, S, and P. So, let me show we how we can convert this dictionary to
a tuple with these values. First, we're going to select this line
and the rest of the code. Now, we can convert all these lines to a comment by pressing command and slash on
mac or control and slash on windows. Now, all these lines are commented out, so they're not going to get executed. We only
have the declaration of our dictionary. Now, let's print let's print emojis dot
look here we have a method called keys which returns the keys of this dictionary using
this structure, dict keys.
-------------------code----------------------
emojis = {r: '🪨', s: '✂️', p: '📃'}
print(emojis.keys())

dict_keys(['r', 'p', 's'])
-------------------code----------------------


- But this is not exactly what we want.
What we want is a tuple. But this is very easy to fix. We can
pass the object that is returned from this method
to the tuple function and with this
we get a tuple exactly like the tuple that we declared in choices.
-------------------code----------------------
tuple(emojis.keys())
# ('r', 'p', 's')
-------------------code----------------------

- So, we can set choices to tuple itself emojis dot keys.
With this technique we removed duplication in our code.
-------------------code----------------------
choices = tuple(emojis.keys())
-------------------code----------------------

- Now, look there are other places where
we have repeated our choices. Again, if we have a typo, our program
is not going to work.
So, realistically we need a single place
for defining our choices. To do that, we can go to the top
and declare a bunch of constants.
By convention, we use uppercase letters to declare constants.
So, we can declare a constant like rock and set it to R.
Similarly, scissors and paper. This is a single place where
we declare our choices. Now, anywhere we have R, S, and P, we replace them with
our constants.
-------------------code----------------------
ROCK = 'r'
SCISSORS = 's'
PAPER = 'p'
-------------------code----------------------

- we press command and D on mac
or control and D on windows. Look, this instance is also selected.
One more time we press command and D.
There we go. Now, we have three cursors, all of them selecting R. So, we can replace them all with rock in one go.

PS: to cancel multi-cursor editing, we press the escape button twice.

- Now, we have a single place where
we have defined our choices, so no chance for typos
and if we decide to change the choices
from R, S, and P to something else in the future,
there is a single place we have to update.
We can change this to 1, 2, and 3, and
everything will work.

- But there is another benefit here.
Look, down here where
we determine the winner,
our code is more descriptive.
So, instead of comparing user choice and computer choice with R and S,
we can clearly see that
if the user has a rock and the computer has scissors,
the user is the winner.
-------------------code----------------------
elif (
        (user_choice == ROCK and computer_choice == SCISSORS) or
        (user_choice == SCISSORS and computer_choice == PAPER) or
            (user_choice == PAPER and computer_choice == ROCK)):
        print('You win')
-------------------code----------------------

*** 5-QR Code Generator ***

Problem:

- Alright, for our next project we're going to build a QR
code generator. So first we enter some text or URL.
we're going to enter the address of google.
-------------------code----------------------
Enter the text or URL: https://www.google.com/
-------------------code----------------------

- next we enter a file name, let's enter google.jpg
now we have a QR code saved in this file.
-------------------code----------------------
Enter the filename: google.jpg
-------------------code----------------------


Solution:

Alright, the first thing we're going to do is set up a virtual environment using pipenv.

- A virtual environment in python is like a separate, isolated workspace on our computer
where we can install packages and run python projects.
Think of it as a clean, organized room that's separate from the rest of our house.
In this room, we have everything we need to work on a specific project
without affecting anything else in the house.

- Now why do we need a virtual environment?
Well, imagine we're working on two different python projects.
One project needs an older version of a library and the other project needs a newer version.
If we install both versions globally for the whole computer, they might conflict with each other.
A virtual environment solves this problem by allowing each project to have its own separate environment
with its own specific versions of libraries.

So, to set up a virtual environment, here we open the terminal window and type python if we're on windows
or python 3 if we're on mac. we can use pipenv
to install it 
-------------------code----------------------
pip3 install pipenv
-------------------code----------------------

- then we install the dependencies
-------------------code----------------------
pipenv install qrcode
pipenv install Pillow
-------------------code----------------------

- finally we activate it
-------------------code----------------------
pipenv shell
-------------------code----------------------

- nowm in our code, First, we import the qrcode module.
Next, we use the input function, and tell the user to enter some text, or url.
We get the result and store it in a variable called data.
-------------------code----------------------
import qrcode

data = input('Enter the text or URL: ')
-------------------code----------------------

- Next, we use the input function to get a file name.
So, enter the file name. And we store it.
-------------------code----------------------
filename = input('Enter the filename: ')
-------------------code----------------------

- Now, it's a good practice to remove any white spaces around what the user types.
For example, what if the user types, let's say, the address of my website, as the url.
Whether they type this address, or this address followed by a white space, we want to have
the same qrcode generator.
So, over here, we can call the strip method to get rid of any white spaces around our data.
-------------------code----------------------
data = input('Enter the text or URL: ').strip()
-------------------code----------------------

- Similarly, we would like to strip any white spaces around the file name.
-------------------code----------------------
filename = input('Enter the filename: ').strip()
-------------------code----------------------

- Now we are ready to generate our qrcode.
To do that, we go in the qrcode module, and create a qrcode object.
Here we want to set two parameters, one is box size.
we're going to set it to 10, these are just arbitrary values.
we're going to set border to 4.
-------------------code----------------------
qr = qrcode.QRCode(box_size=10, border=4)
-------------------code----------------------

- This returns a qrcode object, we store it in this variable.
Next we call qr.add data, then we pass our data.
-------------------code----------------------
qr.add_data(data)
-------------------code----------------------

- Next we call qr.make image, and set two arguments here.
One is fill color, which we're going to set to black.
Again, these are arbitrary values, we can use any colors we want.
We also set back color to white.
-------------------code----------------------
image = qr.make_image(fill_color='black', back_color='white')
-------------------code----------------------

- This returns an image that we store in a variable.
And finally we call image.save to save it in this file.
-------------------code----------------------
image.save(filename)
-------------------code----------------------

- And at the end, we print qrcode saved as, now here we want to add the file name, so let's
convert this to a formatted string, and insert the file name here.
-------------------code----------------------
print(f'QR code saved as {filename}')
-------------------code----------------------

*** 6-Currency Converter ***

Problem:
Alright, for our next project we're going to build a currency converter.

- how it works.
So first we have to enter an amount and this has to be a valid positive number.

- So if we type zero or a negative number we get an error, similarly if we type something
that cannot be converted to a number like A or dollar sign, we get the same error.
So let's enter 100 dollars, next we have to select the source currency which can only
be one of these three options.
-------------------code----------------------
Enter the amount: 0
Invalid amount

Enter the amount: -1
Invalid amount

Enter the amount: a
Invalid amount

Enter the amount: $
Invalid amount
-------------------code----------------------

- Once again if we type an invalid currency, we get an error and we have a chance to retry,
now here we can enter one of these currencies in lower case or upper case, it doesn't matter.
So let's convert 100 US dollars to Canadian dollars, here's the result, 125 dollars.
Of course for the exchange rates we are not using live data, we've hard coded some arbitrary
exchange rates in my program.

-------------------code----------------------
Enter the amount: 100
Source currency (USD/EUR/CAD): a
Invalid currency
Source currency (USD/EUR/CAD): usd
Target currency (USD/EUR/CAD): cad
100.0 USD is equal to 125.00
-------------------code----------------------


Solution:

- Alright, let's start by mapping out what we're going to do.
First, we're going to ask the user for an amount.
Now, if the amount is invalid, we're going to print
an error. Now, we want to give the user a chance to retry.
So, we should put these instructions inside a loop for repetition.
Next, we should ask for the source currency.
Once again, if it's invalid, we're going to print an error.
Now, just like before, we want to put these
instructions inside a loop, so if the user enters
an invalid currency, they have a chance to retry. Now, we're
going to have the same structure for getting
the target currency. Okay? Now, after that, we're going to do
the conversion and print the result. That's the basic idea.

-------------------code----------------------
# Loop
#  Ask the user for an amount
#  If invalid
#   Print an error

# Loop
#  Ask for the source currency
#  If invalid
#   Print an error

# Loop
#  Ask for the target currency
#  If invalid
#  Print an error

# Do the conversion
# Print the result
-------------------code----------------------

- Let's start implementing this program. So,
first, we're going to add a while loop here, while true.
Next, we ask the user for an amount. So, here we use the input function
and say, enter the amount.
Now, whatever the user enters, we want to convert it to a floating point
number. So, we should pass the return
value to the float function, and then we store
the result in a variable called amount.
-------------------code----------------------
amount = float(input( 'Enter the amount:'))
-------------------code----------------------

-  Now, if the user enters something that cannot be converted
to a float, we're going to get a value error. We have seen this error
before. So, we have to wrap this inside a try block, try, followed by
accept, and here we catch errors of type value error.
In this case, we print an error and say invalid
amount. Now, if the user enters a valid amount,
we want to break out of this loop. So, here we add a brick statement.
-------------------code----------------------
while True:
  try:
    amount = float(input( 'Enter the amount:'))
    break
  except ValueError:
    print('Invalid amount')
-------------------code----------------------

- Now, before going further,
let's test our program up to this point. 
-------------------code----------------------
Enter the amount: -
Invalid amount

Enter the amount: a
Invalid amount

Enter the amount: d
Invalid amount

Enter the amount: 10
-------------------code----------------------

- Now, what if the user enters 0?
Our program is treating this as a valid
amount, but it doesn't really make sense.
-------------------code----------------------
Enter the amount: 0
-------------------code----------------------

- The same is true if the user enters a negative amount.
-------------------code----------------------
Enter the amount: -1
-------------------code----------------------

So, back to this code, after we read the amount, we should
check if amount is less than or equal to 0.
Now, here we have two options. One option is to print an
error and say invalid amount, but we already have this piece of logic
down here.
-------------------code----------------------
while True:
  try:
    amount = float(input( 'Enter the amount:'))
    if amount <= 0:
      print('Invalid amount')
    break
  except ValueError:
    print('Invalid amount')
-------------------code----------------------

- So, instead of duplicating this, we can raise
an error, we can raise a value error, and this will move
the control to the line where except is. 
-------------------code----------------------
while True:
  try:
    amount = float(input( 'Enter the amount:'))
    if amount <= 0:
      raise ValueError
    break
  except ValueError:
    print('Invalid amount')
-------------------code----------------------

-then we print
the invalid amount error. Let's try it one more time. If we enter 0, we get the same error,
negative 1, good. What if we enter 5?.
it's working without fine.
-------------------code----------------------
Enter the amount:
Invalid amount

Enter the amount: -1
Invalid amount

Enter the amount: 5
-------------------code----------------------

- So, we are done with the first
step. Now we have a valid amount.
Next, we have to read the source currency.
So, once again, we start with a loop, while true,
here we ask for the source currency, so we use the input
function and say source currency. Now, here we're only
going to have three options. US dollars, euro, and Canadian dollars.
-------------------code----------------------
while True:
    source_currency = input('Source currency (USD/EUR/CAD): ')
-------------------code----------------------

- Now, we read this and store it ina variable called source currency.
Now, how can we validate the source currency?
Well, we can store our valid currencies in a
tuple, and then check to see if source currency is in that
tuple or not. So, outside of this loop, we're going to
declare a tuple, we can call it currencies, and initialize it to
US dollars, euro, and Canadian dollars. Now, why
did we put this outside the loop? Because
this is not a piece of logic that should be
repeated. We want to declare this only once.

- So, after we read the source currency, we
check if source currency is not in
the list of valid currencies. If so, we print an error and say
invalid currency. Otherwise, if
the user enters a valid currency, we want to break out of this loop.
-------------------code----------------------
currencies = ('USD', 'EUR', 'CAD')

while True:
  source_currency = input('Source currency (USD/EUR/CAD): ')
  if source_currency not in currencies:
    print('Invalid currency')
  else:
    break
-------------------code----------------------



- Let's test our program
one more time. So, we enter
hundred dollars. If we
type an invalid currency, we get
an error. 
-------------------code----------------------
Enter the amount: 100
Source currency (USD/EUR/CAD): a
Invalid currency

Source currency (USD/EUR/CAD): d
Invalid currency

Source currency (USD/EUR/CAD): f
Invalid currency
-------------------code----------------------


- If we type usd,
we still get an error because our program is only expecting usd
in uppercase.
-------------------code----------------------
Source currency (USD/EUR/CAD): usd
Invalid currency

Source currency (USD/EUR/CAD): USD
-------------------code----------------------

- So, to make it more flexible, we have
to come back here and right after we read the source currency,
we should convert it to uppercase text. 
-------------------code----------------------
source_currency = input('Source currency (USD/EUR/CAD): ').upper()
-------------------code----------------------

- Okay? Let's try it
one more time. Hundred dollars, usd in lowercase, beautiful.
Now, we have to repeat the same structure for reading the target
currency. So, let's duplicate this. And we
add a line break to separate these segments just like different paragraphs
in a story, but this time we are
reading the target currency. Let's change
the name of this variable. 
-------------------code----------------------
while True:
  target_currency = input('Target currency (USD/EUR/CAD): ').upper()
  if target_currency not in currencies:
    print('Invalid currency')
  else:
    break
-------------------code----------------------


- Now, the fun part, doing the
conversion. Now, here we have two choices. One option is to have
a bunch of if statements like if source currency is usd
and target currency is cad, then we're going to use whatever value for the
exchange rate. But the problem with this approach
is that we're going to have so many if statements
for every combination of currencies. And the more currencies we support,
the more if statements we need.
-------------------code----------------------
if source_currency == 'USD' and target_currency == 'CAD':
-------------------code----------------------


- So, what can we do here? This is where
we can use a dictionary. You have learned that. Using a dictionary we can
map a key to a value. In this dictionary we can have
our source currencies like usd, euro, and cad. Now, we can map
the source currency to another dictionary where we have
key value pairs for the target currency. 
-------------------code----------------------
# key -> value
# USD: { CAD: 1.12, EUR: 0.8 }
# EUR
# CAD
-------------------code----------------------

- So, in this dictionary our key is going to be let's say
cad, and the value is going to be the exchange rate,
whatever it is. Similarly, we're going to have another key
value pair for another target currency, euro.
With a different exchange rate. Okay, let's implement this. So,
we're going to declare a variable, let's call that
exchange rates, we set it to a dictionary, we add
our source currencies, usd, and map this to a dictionary with
two other currencies. 
-------------------code----------------------
exchange_rates = {
  'USD': {'EUR': 0.85, 'CAD': 1.25},
  'EUR': {'USD': 1.18, 'CAD': 1.47},
  'CAD': {'USD': 0.80, 'EUR': 0.68},
}
-------------------code----------------------


- So,
we have the exchange rates. Finally, to do the conversion,
we declare another variable, we can call it converted amount,
and here we get the amount, and multiply it by, now to find the exchange rate, we have to go to our
exchange rates dictionary, and look up the source currency.
So, here we pass source currency. Now, this expression,
returns a dictionary. So, when we access
exchange rates of let's say, usd, we get another dictionary.
In this dictionary we have two other key value pairs.
So then we're going to look up the target currency using square brackets,
target currency, and that's pretty much it.

Now finally, let's print the result.
-------------------code----------------------
converted_amount = amount * exchange_rates[source_currency][target_currency]
print(converted_amount)
-------------------code----------------------


- Here we're going to use a formatted string.
-------------------code----------------------
converted_amount = amount * exchange_rates[source_currency][target_currency]
print(f'{amount} {source_currency} is equal to {converted_amount}')
-------------------code----------------------

- we test our code 
-------------------code----------------------
Enter the amount: 100
Source currency (USD/EUR/CAD): USD
Target currency (USD/EUR/CAD): CAD
100.0 USD is equal to 125.0
-------------------code----------------------

- Now, we can take this further.
Let's say we only want to show two digits after the decimal point.
To do that, we use a format specifier. So, in our formatted string,
where we add the converted amount,
here we type a colon, and type a format specifier.
Here we can type .2f,
and that means two digits after the decimal point.
-------------------code----------------------
converted_amount = amount * exchange_rates[source_currency][target_currency]
print(f'{amount} {source_currency} is equal to {converted_amount:.2f}')
-------------------code----------------------

- So, if we run our program, and for the amount,
if we enter 123.45678, from usd, to cad, we get the result with
only two digits after the decimal point.

-------------------code----------------------
Enter the amount: 123.45678
Source currency (USD/EUR/CAD): USD
Target currency (USD/EUR/CAD): CAD
123.45678 USD is equal to 154.32
-------------------code----------------------

- Now, let's try another scenario.
What if we enter 100 dollars, from usd, to usd.
Our program crashed.
-------------------code----------------------
Enter the amount: 100
Source currency (USD/EUR/CAD): USD
Target currency (USD/EUR/CAD): USD

KeyError: 'USD'
-------------------code----------------------


- One way to solve this problem
is to add another key value pair here.
So, usd, and the exchange rate
is going to be one. But this is kind of unnecessary,
and adds extra noise in our code. So, after exchange rates,
we can check if source currency is the same as target currency.
We can set the converted amount
to the original amount. Otherwise,
we perform the calculation.



With this, if we select the same currency,
our program doesn't crash.
-------------------code----------------------
if source_currency == target_currency:
        return amount

    return amount * exchange_rates[source_currency][target_currency]
-------------------code----------------------

and this is our full program

-------------------code----------------------
while True:
  try:
    amount = float(input( 'Enter the amount:'))
    if amount <= 0:
      raise ValueError
    break
  except ValueError:
    print('Invalid amount')

currencies = ('USD', 'EUR', 'CAD')

while True:
  source_currency = input('Source currency (USD/EUR/CAD): ')
  if source_currency not in currencies:
    print('Invalid currency')
  else:
    break

while True:
  target_currency = input('Target currency (USD/EUR/CAD): ').upper()
  if target_currency not in currencies:
    print('Invalid currency')
  else:
    break

exchange_rates = {
  'USD': {'EUR': 0.85, 'CAD': 1.25},
  'EUR': {'USD': 1.18, 'CAD': 1.47},
  'CAD': {'USD': 0.80, 'EUR': 0.68},
}

if source_currency == target_currency:
    return amount

  return amount * exchange_rates[source_currency][target_currency]


print(f'{amount} {source_currency} is equal to {converted_amount:.2f}')
-------------------code----------------------

Refactor:

- Our program is working but as we said just because it's working doesn't mean our job is done.
We should always review and refine our code. Earlier we talked about modularizing code
which means breaking down a large program into small reusable and more maintainable functions.

- So let's start modularizing this code. The first thing we're going to do is extract these
few lines into a separate function called get amount.
So let's define a function called get amount and then we move this piece of logic inside this function.
We just have to make a small change. If the user enters a valid value
we don't want to just break out of this loop, we want to return that value.
So we're going to replace the break statement with return amount.
-------------------code----------------------
def get_amount():
  while True:
    try:
      amount = float(input( 'Enter the amount:'))
      if amount <= 0:
        raise ValueError
      return amount
    except ValueError:
      print('Invalid amount')
-------------------code----------------------


- Next we're going to extract a function for reading the source and target currencies.
Now here we have two segments and as we can see these segments are almost identical.
All the logic is the same, the only difference is the label that we are printing on the terminal.
So we can extract this logic into a reusable function called get currency.
So we're going to select the first while loop, copy these few lines.
Now after our first function, let's define another function called get currency.
And we give it a parameter called label.
Now we're going to paste the code that we just copied. 
Now here we're going to use a formatted string, so we can insert the label dynamically.
ONow in this function we are not necessarily working with the source currency,
so we can simplify our code and make it cleaner by renaming this variable to currency.
Now if the user enters a valid value, we don't want to just break out of this loop,
we want to return that currency. 
Okay.
Now look, at currencies tuple that we declared earlier, it's only used in get_currency.
So we want to move this line in this function because this is where we need this.
So in a function we should only have the statements that are highly related.
So here we have a small function for getting the currency,
now we can use it for reading both the source and the target currencies.
-------------------code----------------------
def get_currency(label):
    currencies = ('USD', 'EUR', 'CAD')
    while True:
        currency = input(f'{label} currency (USD/EUR/CAD): ').upper()
        if currency not in currencies:
            print('Invalid currency')
        else:
            return currency
-------------------code----------------------


- So, we're going to replace this while loop with a call to get currency,
and for the label we pass source. Then we get the result and store it,
in source currency. Similarly, we're going to replace
this piece of logic with a call to our new function.
Get currency, target, and then store the result in target currency.
And of course before these two lines, we should call get amount,
and store the result in a variable called amount.
-------------------code----------------------
amount = get_amount()
source_currency = get_currency('Source')
target_currency = get_currency('Target')
-------------------code----------------------


- Alright, next we're going to extract the logic for performing the conversion
into a separate function called convert. So, we're going to grab
all this code, exchange rates, as well as the logic for conversion, cut it,
and then, we're going to define a new function here, convert,
with three parameters. amount, source currency, and target currency.
Then we paste the logic, and fix the problem with indentation.
So, here's what we have, but we have to make a small change.
Instead of setting the converted amount variable, we just want to return this value.
And similarly here, now we can make this code a bit more concise and cleaner,
by removing the else statement, because it's not needed here.
Why?
Look, if source and target currencies are the same,
we're going to return this amount, so the rest of this function is not executed.
That's why, we don't really need the else statement here.
So, let's remove this, and fix the indentation. Our code is cleaner.
-------------------code----------------------
def convert(amount, source_currency, target_currency):
    exchange_rates = {
        'USD': {'EUR': 0.85, 'CAD': 1.25},
        'EUR': {'USD': 1.18, 'CAD': 1.47},
        'CAD': {'USD': 0.80, 'EUR': 0.68},
    }

    if source_currency == target_currency:
        return amount

    return amount * exchange_rates[source_currency][target_currency]
-------------------code----------------------


- we have broken down this program into
a bunch of functions, each having a single responsibility.
These functions are very self-explanatory, they are properly named,
and each has only a few lines of code. So, if there is a bug in this program,
we only have to focus on a small piece of logic.


- Now the final step. So, we have a bunch of reusable functions,
but we don't want to have these statements at the end of the script.
It would be nicer to move these inside a separate function.
So, by convention, we know that, we use the main function for that,
that is the entry point for our program.
So, when we run our program, this piece of logic should get executed.
So, this is the main function. Now, the final step is to call it.
So, right after we define it, we call the main function.
Now there is one more thing we want to improve here.
So, currently we are running these scripts directly.
But if we import this module into a separate module,
the main function in this module will get executed.
And this is not what we want. Because if we import this module into a separate module,
perhaps we're going to do that to reuse these functions we have defined here.
So, we want to execute the main function only if we execute this script directly from the terminal.
not as part of importing this module into a separate module using the import statement.
To do that, we have to add a bit of logic here. So,
we have this special variable called
name that is automatically set by the python interpreter.
When we execute this script directly from the terminal,
So, we want to execute the main function only if name is equal to main.
This is the mini module using the canvas via às a vector board.
-------------------code----------------------
def main():
    amount = get_amount()
    source_currency = get_currency('Source')
    target_currency = get_currency('Target')
    converted_amount = convert(amount, source_currency, target_currency)
    print(f'{amount} {source_currency} is equal to {converted_amount:.2f}')


if __name__ == "__main__":
    main()
-------------------code----------------------

*** 7-Quiz Game ***

Problem:

- Alright, for our next project, we're going to build a fun and interactive quiz game. 

- Let's see how it works. Here's our first question
What is the capital of France? Let's select Paris.
That was correct. 

-------------------code----------------------
Question 1: What is the capital of France?
A. Berlin
B. Madrid
C. Paris
D. Rome
Your answer:
Correct!
-------------------code----------------------
- The second question is, which planet is known
as the red planet? We know the answer, it's Mars, but let's see what happens
if we select Earth. Wrong, the correct answer is B.

-------------------code----------------------
Question 2: Which planet is known as the red planet?
A. Earth
B. Mars
C. Jupiter
D. Saturn
Your answer:
Wrong! The correct answer is B
-------------------code----------------------

- So if the user answers correctly, we display some text in green
otherwise we display it in red.

- We have one more question, what is the
largest ocean on Earth? That is Pacific, correct?
So the quiz is over, and our final score is 2 out of 3. 

-------------------code----------------------
Question 3: What is the largest ocean on Earth?
A. Atlantic
B. Indian
C. Arctic
D. Pacific
Your answer: d
Correct!
Quiz over! Your final score is 2 out of.
-------------------code----------------------

Solution:

- Alright, let's start by mapping out what exactly
we're going to do. First, we're going to define our questions,
options, and the correct answer.
Next, we're going to shuffle the questions, so every time we run our
program, we get questions in a different order. Then, we're going to loop
over questions, we're going to print one question at a time,
next we should get user input.
And here we check, if input is correct,
we're going to print a message like correct answer, and
at the same time, we should also increase the user's
score. Otherwise, if the input is
incorrect, we're going to say wrong answer.
And at the end, we should print the final score.
-------------------code----------------------
# Define questions, options, correct answer
# Shuffle the questions
# Loop over questions
  # Print question
  # Get user input
  # If input is correct
    # Print correct answer 
    # Increase score
  # Else
  # Print wrong answer
# Print the final score
-------------------code----------------------

- First, we have to figure out a way to represent
our questions, their options, and correct answers. There are different ways
we can go about this, we can use tuples,
we can use dictionaries, we can create
classes. A simple beginner friendly way is to use a dictionary.
Now, because we're going to have multiple questions, we need a list of
dictionaries. So, we can declare a variable called
quiz, and set it to a list. In this list, we're going to have
a bunch of dictionaries. So, we add one dictionary for each item.
Now, here we're going to have three key value pairs.
-------------------code----------------------
quiz = [
        {
            'question': 'What is the capital of France?',
            'options': ['A. Berlin', 'B. Madrid', 'C. Paris', 'D. Rome'],
            'answer': 'C'
        },
        {
            'question': 'Which planet is known as the red planet?',
            'options': ['A. Earth', 'B. Mars', 'C. Jupiter', 'D. Saturn'],
            'answer': 'B'
        },
        {
            'question': 'What is the largest ocean on Earth?',
            'options': ['A. Atlantic', 'B. Indian', 'C. Arctic', 'D. Pacific'],
            'answer': 'D'
        }
    ]
-------------------code----------------------

- next we want to shuffle the question To do that, we have to import
the random module on the top. Then, here we call
random.shuffle and pass our quiz.
-------------------code----------------------
import random

random.shuffle(quiz)
-------------------code----------------------

- We're done with this step. Now, let's loop over the questions.
To do that, we're going to use a for loop. We can say for item
in. Now, here we have to use the enumerate function
to iterate over an iterable. In this case, our quiz.
So, we pass the quiz. This returns a topple with two elements.
The first element is the index of the current element. And the second element is
the actual item. 
-------------------code----------------------
for index, item in enumerate(quiz):
  print(item['question'])
-------------------code----------------------

- Now, before going further, let's just print
the question and see if our code is working up to this point.
Back to the terminal, let's run our quiz game.
-------------------code----------------------
$ python3 quiz_game.py

What is the capital of France?
What is the largest ocean on Earth?
Which planet is known as the red planet?
-------------------code----------------------

- Okay, we have our questions. If we run this program again,
the order of questions has changed.
-------------------code----------------------
$ python3 quiz_game.py

What is the largest ocean on Earth?
Which planet is known as the red planet?
What is the capital of France?
-------------------code----------------------

*****************************************************************************
enumerate() in Python is used to add a counter to an iterable (like a list, tuple, or string). It returns pairs of index numbers and values, 
which is particularly useful when we need both the index and value in a loop.

More practical examples:
1.Creating a dictionary with positions
Without enumerate:
-------------------code----------------------
# If we need both index and value, we need a separate counter
fruits = ["apple", "banana", "cherry"]
index = 0
for fruit in fruits:
    print(f"Index {index}: {fruit}")
    index += 1

# Or using range and len (less readable)
for i in range(len(fruits)):
    print(f"Index {i}: {fruits[i]}")
-------------------code----------------------

With enumerate:
-------------------code----------------------
fruits = ["apple", "banana", "cherry"]
for index, fruit in enumerate(fruits):
    print(f"Index {index}: {fruit}")

# You can also start counting from a different number
for index, fruit in enumerate(fruits, start=1):
    print(f"Number {index}: {fruit}")
-------------------code----------------------


2. Finding indices of specific elements:

# Without enumerate
-------------------code----------------------
numbers = [1, 4, 6, 4, 8, 4]

indices = []
for i in range(len(numbers)):
    if numbers[i] == 4:
        indices.append(i)
-------------------code----------------------
# With enumerate (more readable)
-------------------code----------------------
numbers = [1, 4, 6, 4, 8, 4]
indices = [i for i, num in enumerate(numbers) if num == 4]
-------------------code----------------------

3.Creating numbered lists:


# Without enumerate
-------------------code----------------------
tasks = ["Learn Python", "Practice coding", "Build project"]
print("Todo List:")
for i in range(len(tasks)):
    print(f"{i+1}. {tasks[i]}")
-------------------code----------------------
# With enumerate (cleaner)
-------------------code----------------------
tasks = ["Learn Python", "Practice coding", "Build project"]
print("Todo List:")
for num, task in enumerate(tasks, 1):  # start=1 for natural counting
    print(f"{num}. {task}")
-------------------code----------------------

Benefits of using enumerate():
1. More readable and Pythonic code
2. Less prone to errors (no manual index tracking)
3. More efficient than maintaining a separate counter
4. Can start counting from any number using the start parameter
5. Reduces the need for multiple variables or complex indexing
PS: Remember that enumerate() returns an enumerate object, which can be converted to a list if needed:

-------------------code----------------------
letters = ['a', 'b', 'c']
enum_list = list(enumerate(letters))
print(enum_list)  # [(0, 'a'), (1, 'b'), (2, 'c')]
-------------------code----------------------
*****************************************************************************

- let's take this to the next level. Instead of printing the question,
we want to print something like this. Question
1, and then here we're going to add the actual question.
To do that, we're going to use a formatted string here. 
-------------------code----------------------
for index, item in enumerate(quiz):
  print(f'Question {index}: {item ['question']}')
-------------------code----------------------

- Now, let's run our program
one more time. Okay, getting better, but we don't want to start with question 0.
-------------------code----------------------
$ python3 quiz_game.py

Question 0: Which planet is known as the red planet?
Question 1: What is the largest ocean on Earth?
Question 2: What is the capital of France?
-------------------code----------------------

-To fix this problem, here we can pass a second argument and that is the starting
index. So, if we set this to
1, index is going to start from
-------------------code----------------------
for index, item in enumerate(quiz, 1):
  print(f'Question {index}: {item ['question']}')
-------------------code----------------------

- let's run it one more time.
-------------------code----------------------
$ python3 quiz_game.py

Question 1: Which planet is known as the red planet?
Question 2: What is the largest ocean on Earth?
Question 3: What is the capital of France?
-------------------code----------------------

1. So,  There we go. That's better.
Now, let's move on to the next step. After printing the question, we
want to print all the options. So, once again, we're going to use a for loop.
-------------------code----------------------
for index, item in enumerate(quiz, 1):
  print(f'Question {index}: {item[ 'question']}')
  for option in item['options']:
    print(option)
-------------------code----------------------

- Now, we should get the user's input. So, we're going to add a line break
to separate this segment from the next one, because this
segment is all about printing a question
and all its options. Now, we're going to move on to the next step or next
segment, which is about getting the user's input. So, here we use the
input function and say our answer. Now, to simplify our if
statements, we're going to convert whatever the user types to uppercase
and also remove any accidental white space around
the answer. We store the result in a variable called answer.
Now, we have to do our comparisons. So, we check if answer equals item of
answer, then we're going to print
correct.
-------------------code----------------------
answer = input( 'Your answer: ').upper().strip()
if answer == item['answer']:
  print( 'Correct!')
-------------------code----------------------

- and increase the score. So, outside of this for loop,
we have to declare a variable called score and initialize it to 0. Then,
every time the user answers a question, we're going to increment
the score. So, score plus equal 1. Okay?
Now, otherwise, if the answer is incorrect,
we're going to print wrong, the correct answer is, well, we're going to use
a formatted string here. So, here we're going to print item
of answer. Okay? And of course, we have to prefix this with F.
-------------------code----------------------
score = 0

for loop statement ...

if answer == item ['answer']:
print( 'Correct!')
score += 1
else:
print( 'Wrong! The correct answer is f{item['answer']})
-------------------code----------------------

- Finally, we have to print the final score.
-------------------code----------------------
print(f'Quiz over! Your final score is {score} out of {len(quiz)}')
-------------------code----------------------

Alright, now we're going to take this to the next level.
We're going to colorize the text in the terminal. And to do that,
we're going to use a popular package called term color.
-------------------code----------------------
termcolor

https://pypi.org/project/termcolor/
-------------------code----------------------
 It's very easy
to use, we install it with pip, and down here we can see an example
of using this library. In this lesson, we're going to use the cprint
function that is defined in this module.
-------------------code---------------------- 
from termcolor import cprint
-------------------code----------------------

- This is exactly like our print function, but as a second argument, we can pass a color.
Now, where we give user feedback, instead of the print function,
we're going to use cprint. So if the answer is correct, we're going to use green color.
-------------------code----------------------
cprint('Correct!', 'green')
-------------------code----------------------

- Otherwise, we're going to use red. 
-------------------code----------------------
cprint(f'Wrong! The correct answer is {item['answer']}', 'red')
-------------------code----------------------
- Now, to separate the questions after we give user feedback,
we would like to add an empty line, because this makes the output cleaner.
-------------------code----------------------
cprint(f'Wrong! The correct answer is {item['answer']}', 'red')

print()
-------------------code----------------------

- So let's run our project one more time. and test it

Refactor:

Alright, we're done with our solution, but there is one thing that stands out. The repeated
use of these string keys 'question', 'answer' , 'option'. If we have a typo in our code, like an extra n here or a white
space, our code is not going to work, right? These kind of mistakes can be tricky to catch
and can cause bugs that are hard to trace. Earlier we talked about the "dry" principle
encoding, don't repeat yourself. So let's clean up this code by replacing these string
keys with constants. This simple change can make our code more robust, easier to maintain
and less prone to errors.

- So up here, we declare three constants. Question, we set it to question,
options, and answer. Now let me clarify something here. In python, we don't really have constants
the way we have in languages like java, c++, or c sharp. So there is nothing that stops
me from reassigning one of these so called constants. So essentially this is just a variable, but
by convention, we use uppercase letters to tell other programmers to treat these as constants.
-------------------code----------------------
QUESTION = 'question'
OPTIONS = 'options'
ANSWER = 'answer'
-------------------code----------------------

- next Now we're going to replace these string keys with constants.

- Alright, now we're going to refactor our code to make it more
modular and easier to work with. We want to break down this script
into smaller functions. 

- Now there are different ways we can do this, for example
we can extract these few lines into a function called display question. That's one way.
-------------------code----------------------
print(f'Question {index}: {question}')
  for option in options:
      print(option)
-------------------code----------------------
 
- but we can also include this line
as well and extract all of this into a function called ask
question. we prefer this approach because the act of asking a
question and getting an answer are highly related. So to make our code
more modular, we want to have all the logic, all the lines that are
highly related inside a single function.

- Now we need three pieces of information in this function. The index of the question
so we add it here. The second is the question itself
and third is the options. Now here we can add
item as a parameter and then access the question and
options key here. But we don't like this approach because someone else
looking at this code, they have no idea about the shape of this item object.
It's kind of ambiguous. So we prefer to get a bit more explicit here.
We can replace item with two parameters, question
and options. Now our code is very straightforward.
-------------------code----------------------
def ask_question(index, question, options):
    print(f'Question {index}: {question}')
    for option in options:
        print(option)

    answer = input('Your answer: ').upper().strip()
-------------------code----------------------

- Now let's put the rest of the code inside a function like run quiz.
So run quiz. Now we should move all the logic inside this function.
Okay, here's what we have. In this function we need to have access to our quiz.
Now we have declared quiz globally so we can access it anywhere in these functions
but generally speaking it's best to stay away from global variables
global variables because they can cause bugs that are hard to trace.
So we would prefer to pass quiz as an argument to this function.
-------------------code----------------------
def run_quiz(quiz):
    random.shuffle(quiz)

    .....


-------------------code----------------------


- Now let's replace these few lines with our ask question function.
Here we have three parameters, index, question, and options.
Now when calling this function, we should pass three arguments.
So index, item of question, and item of answer.
-------------------code----------------------
for index, item in enumerate(quiz, 1):
    answer = ask_question(index, item[QUESTION], item[OPTIONS])
-------------------code----------------------

- So, we have this now, this function should return an answer.
We forgot to do that earlier. So this is where we get the answer. We can return it right away.
We can also make our code more concise by returning
the return value of the input function immediately.
so There is no need to declare an extra variable.
-------------------code----------------------
def ask_question(index, question, options):
    print(f'Question {index}: {question}')
    for option in options:
        print(option)

    return input('Your answer: ').upper().strip()
-------------------code----------------------

- let's add a main function. In this function, we call run quiz and give it our quiz object.
Now, earlier we told we that it's best to stay away from global variables.
-------------------code----------------------
def main():
    quiz = [
        {
            QUESTION: 'What is the capital of France?',
            OPTIONS: ['A. Berlin', 'B. Madrid', 'C. Paris', 'D. Rome'],
            ANSWER: 'C'
        },
        {
            QUESTION: 'Which planet is known as the red planet?',
            OPTIONS: ['A. Earth', 'B. Mars', 'C. Jupiter', 'D. Saturn'],
            ANSWER: 'B'
        },
        {
            QUESTION: 'What is the largest ocean on Earth?',
            OPTIONS: ['A. Atlantic', 'B. Indian', 'C. Arctic', 'D. Pacific'],
            ANSWER: 'D'
        }
    ]
    run_quiz(quiz)
-------------------code----------------------

- Now, the final step.
At the end, we should check, if name equals main, then we call the main function.

-------------------code----------------------
if __name__ == '__main__':
    main()
-------------------code----------------------
